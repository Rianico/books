---
title: Linux 零拷贝实现
date: 2020-07-23 09:51:33
---
# Linux零拷贝实现

### 1. I/O 中断与 DMA

CPU访问外部数据分为 **I/O 中断** 方式与 **DMA 方式（Direct Memory Access，直接内存访问）**。

* I/O 中断：外部存储设备（e.g. 磁盘，键盘，鼠标）**采用中断方式主动通知 CPU**，CPU 中断响应一次，拷贝数据到内核缓冲区，再拷贝到用户缓冲区，CPU全程参与。这样就会有**上下文切换的开销以及CPU拷贝的时间**，频繁的中断会让人感觉操作系统响应缓慢。

![传统I/O](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/IO%E4%B8%AD%E6%96%AD.png)

* DMA：CPU 通知 DMA 控制器拷贝外部存储设备数据到内核缓冲区，DMA 完成后再通知 CPU 拷贝到用户缓冲区。也就是在 I/O 中断的基础上改由 DMAC（DMA Controller）来执行外部存储器数据的 I/O 操作，这样就不需要 CPU 全程参与，减轻了 CPU 负担，且CPU 读取内存比读取外部存储设备速度快。

![DMA&#x65B9;&#x5F0F;](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/DMA%E6%96%B9%E5%BC%8F.png)

### 2. 传统I/O方式

当前计算机传统的 I/O 访问方式都是通过 DMA 方式来进行，如下：

![&#x4F20;&#x7EDF;I/O](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/%E4%BC%A0%E7%BB%9FIO.png)

传统的 I/O 方式在进行一次读写的时候共涉及了 4 次上下文切换，2 次 DMA 拷贝以及 2 次 CPU 拷贝。

这个步骤流程如下：

1. 用户进程向内核发起一次read\(\)调用，上下文从用户态切换为内核态。（第一次上下文切换）
2. CPU通知DMA控制器从外部存储设备拷贝数据到内核缓冲区。（DMA Copy）
3. CPU将内核缓冲区的数据拷贝到用户缓冲区，上下文从内核态切换到用户态（CPU Copy，第二次上下文切换）
4. 用户进程向内核发起一次 write() 调用，上下文从用户态切换到内核态。（第三次上下文切换）
5. CPU 从用户缓冲区拷贝数据到内核空间的Socket缓冲区。（CPU Copy）
6. CPU 通知 DMA 控制器将 Socket 缓冲区的数据拷贝到网卡进行传输，上下文从内核态切换为用户态并返回。（DMA Copy，第四次上下文切换）

### 3. 零拷贝

传统的 I/O 方式中，**如果不需要操作数据内容，那么从内核空间拷贝到用户空间再拷贝回去是完全多余的**。为了应对这种场景，出现了零拷贝（ Zero-copy ）这一优化方式。

零拷贝有多重实现方式，这里只讨论 sendfile 相关方式（这也是 Java NIO 的 FileChannel 以及 Kafka 发送消息采用的方式）。

#### 3.1 sendfile方式



![sendfile](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/sendfile.png)

如上图，基于 sendfile 方式总共会有 2 次上下文切换，2 次 DMA 拷贝以及 1 次 CPU 拷贝，由于用户进程没有任何手段能够接触到数据，因此这种方式只适合单纯的数据传输。

```c
sendfile(socket_fd, file_fd, len);
```

在 Java 的 NIO 方式中，`FileChannel` 的 `transferTo()` 方法可以实现此过程：

```java
public void transferTo(long position, long count, WritableByteChannel target);
```

在Linux系统中，这个调用最终会被传递给 sednfile() 系统调用，从而实现零拷贝。

#### 3.2 sendfile + DMA gather

在前面的 sednfile 方式中，CPU 仍需要参与一次拷贝，从 Linux 2.4 版本的内核开始，针对套接字缓冲区描述符做了相应调整，DMA 自带了收集功能，可以将对应的数据描述信息（内存地址、地址偏移量）记录到相应的网络缓冲区（socket buffer），由 DMA 根据这些数据描述信息拷贝到网卡设备中，从而省下了最后一次 CPU 参与的拷贝工作。

```cpp
sendfile(socket_fd, file_fd, len);
```

![sendfile + DMA gather](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/sednfile_DMA_Gather.png)

### 4. Reference

* [深入剖析Linux IO原理和几种零拷贝机制的实现](https://juejin.im/post/5d84bd1f6fb9a06b2d780df7#heading-0)
* [蚂蚁二面，面试官问我零拷贝的实现原理，当场懵了…](https://www.jianshu.com/p/2581342317ce)

