---
title: 观察者模式
date: 2020-05-26 17:06:04
---
# 观察者模式

观察者模式-&gt;伪双分派模式

方法的宗量：方法的接收者与方法参数。 

Java静态类型绑定：双分派，在编译时，根据方法的接收者以及参数来确定方法的选择。 

Java动态类型绑定：单分派，在运行时，根据方法的接收者来确定方法的选择。

动态类型绑定只会发生在方法的调用者身上，而**方法的参数类型则会在编译期由编译器决定**。

因此如果要实现双分派，我们可以这样实现：

```scala
trait SuperClass {
    def fake() { println("SuperClass") }
}
class SubA extends SuperClass {
    def commonMethod(sub: SuperClass) { sub.fake() }
    override def fake() { println("SubA") }
}
class SubB extends SuperClass {
    def commonMethod(sub: SuperClass) { sub.fake() }
    override def fake() { println("SubB") }
}

val a = new SubA()
val b = new SubB()
a.commonMethod(b)

// output:
SubB
```

此处第一次方法调用者触发一次动态单分派，接着在参数传递进去后，再将参数作为方法的调用者，从而触发第二次动态单分派。

但这样一旦需要为所有类添加功能，又得每个类添加方法，因此这里可以使用观察者模式。

观察者模式的步骤： 

1. 将一组类的重载方法放到一个 `Visitor` 里 

2. 在每个类里添加 `def accept(v: Visitor) { v.visit(this) }` ，接收定义的 Visitor 即可。 

3. 之后一旦需要增加新的功能，只需要新增加新的 `Visitor` ，类直接调用 `accept(v: Visitor)` 即可而无需对原有的类进行改动。

实现如下：

```scala
class Visitor {
    def visit(sub: SubA) { print("SubA") }
    def visit(sub: SubB) { print("SubB") }
}

trait SuperClass {
    def accept(visitor: Visitor): Unit = { }
}
class SubA extends SuperClass { 
    override def accept(visitor: Visitor): Unit = { visitor.visit(this) }
}
class SubB extends SuperClass { 
    override def accept(visitor: Visitor): Unit = { visitor.visit(this) }
}



val visitor = new Visitor()
val a = new SubA()
a.accept(visitor)

val b = new SubB()
b.accept(visitor)

// output:
SubA
SubB
```

参考：

* [Visitor and Double Dispatch](https://refactoring.guru/design-patterns/visitor-double-dispatch)
* [面向对象语言的多分派、单分派、双重分派](https://blog.csdn.net/yeluosc/article/details/19043395)
* [访问者模式和双分派](https://www.cnblogs.com/jiaoyiping/p/9769554.html)

