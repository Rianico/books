---
title: 责任链模式
date: 2020-07-22 10:56:51
---
# 责任链模式

## 1. 介绍

责任链模式（Chain of Responsibility）：是由一个源输入以及一系列处理器组成的，在责任链中的每一个处理对象都主要负责一种特定类型的指令，一旦处理完成，则会将其传递给下一个处理对象，如图：

![&#x8D23;&#x4EFB;&#x94FE;&#x6A21;&#x5F0F;](https://raw.githubusercontent.com/Rianico/Image/master/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F.png)

责任链模式主要有利于：

* 对指令中的发送者和接收者进行解耦
* 抽象非核心部分，以链式调用的方式对源输入进行处理

标准的责任链模式有以下几个特点：

* 需要先定义源输入（往往是业务核心部分）和多个处理器（抽象出来的非核心部分，可拔插）。
* 链上的每个处理器都有机会处理源输入。
* 每个处理器都持有对下个处理器的引用（**此处仅指代最原始的责任链模式，有些实现方式节点之间的链接可能交由其他对象如数组来管理**）。
* 链上的某个对象无法处理当前请求，那么它会把相同的请求传给下一个对象。

## 2.责任链模式实践

以一个用户登录时进行的验证流程为例，我们来实践一下

### 1. 定义源输入

我们先定义一个提供源输入的用户验证类型的抽象类`AuthenticationProvider` ：

```java
public interface AuthenticationProvider {

}
```

接着是两个用户验证类型的具体实现：

```java
// 定义具体的用户验证类型OAuthProvider
public class OAuthProvider implements AuthenticationProvider {
}

// 定义具体的用户验证类型UsernamePasswordProvider
public class UsernamePasswordProvider implements AuthenticationProvider {
}
```

### 2. 定义处理器

接下来定义一个名为`AuthenticationProcessor`的抽象验证类：

```java
public abstract class AuthenticationProcessor {

    AuthenticationProcessor nextProcessor;

    AuthenticationProcessor(AuthenticationProcessor nextProcessor) {
        this.nextProcessor = nextProcessor;
    }

    public abstract boolean doFilter(AuthenticationProvider authProvider);

}
```

接着定义以下几种用户验证方式的具体实现类：

* OAuthProcessor

```java
public class OAuthProcessor extends AuthenticationProcessor {

    OAuthProcessor(AuthenticationProcessor nextProcessor) {
        super(nextProcessor);
    }

    @Override
    public boolean doFilter(AuthenticationProvider authProvider) {
        if (authProvider instanceof OAuthProvider) {
            System.out.println("OAuthProcessor success...");
            return true;
        } else if (null != nextProcessor) {
            return nextProcessor.doFilter(authProvider);
        }
        return false;
    }
}
```

* UsernamePasswordProcessor

```java
public class UsernamePasswordProcessor extends AuthenticationProcessor {

    UsernamePasswordProcessor(AuthenticationProcessor nextProcessor) {
        super(nextProcessor);
    }

    @Override
    public boolean doFilter(AuthenticationProvider authProvider) {
        if (authProvider instanceof UsernamePasswordProvider) {
            System.out.println("UsernamePasswordProcessor success...");
            return true;
        } else if (null != nextProcessor) {
            nextProcessor.doFilter(authProvider);
        }
        return false;
    }
}
```

### 3. 验证

接着对结果进行验证，客户端构造一个责任链，以`OAuthProcessor`为责任链的开头，持有对责任链下一个节点`UsernamePasswordProcessor`的引用，以null为结束标志，并传入`UsernamePasswordProvider`，期待能够以`UsernamePasswordProcessor`的方式进行验证。

```java
import org.junit.jupiter.api.Test;

public class TestClass {

    @Test
    void testUserPasswordProvider() {
        AuthenticationProvider provider = new UsernamePasswordProvider();

        AuthenticationProcessor usernamePasswordProcessor = new UsernamePasswordProcessor(null);
        AuthenticationProcessor oAuthProcessor = new OAuthProcessor(usernamePasswordProcessor);

       assertTrue(oAuthProcessor.doFilter(provider));
    }

}
```

输出结果：

```vim
UsernamePasswordProcessor success...
```

这样一来，无论后面需要增加多少种验证，只需要将各个验证类衔接，最终调用源输入即可。

**思考**：上面的写法虽然符合开闭原则，但是一旦增加验证操作，客户端的代码就需要调整，而且验证类之间相互衔接的方式也不够优雅。

## 3. 升级版责任链模式

标准的责任链模式存在缺点，因此需要其进行优化，我们可以参考Servlet的Filter实现方式，其实现方式就是一个经典责任链优化后的模式。

### 1. 定义源输入

我们先定义一个提供源输入的用户验证类型的抽象类`AuthenticationProvider` ，此处跟2.1中的源输入一致：

```java
public interface AuthenticationProvider {

}
```

接着是两个用户验证类型的具体实现：

```java
// 定义具体的用户验证类型OAuthProvider
public class OAuthProvider implements AuthenticationProvider {
}

// 定义具体的用户验证类型UsernamePasswordProvider
public class UsernamePasswordProvider implements AuthenticationProvider {
}
```

### 2. 定义处理器

首先定义一个接口`AuthenticationProcessorPlus`：

```java
public interface AuthenticationProcessorPlus {

    public void doFilter(AuthenticationProvider authProvider, AuthenticationProcessorPlus filterChain);

}
```

接着定义一条责任链`FilterChain`，其中就使用了一个数组将各个处理器节点连接起来：

```java
public class FilterChain implements AuthenticationProcessorPlus {
    // 计数器
    private int pos = 0;
    // 连接处理器的数组
    private List<AuthenticationProcessorPlus> filterList;

    public void addAuth(AuthenticationProcessorPlus auth) {
        if (filterList == null) {
            filterList = new ArrayList<>();
        }
        filterList.add(auth);
    }

    @Override
    public void doFilter(AuthenticationProvider authProvider, AuthenticationProcessorPlus filterChain) {

        if (pos == filterList.size()) {
            return;
        }

        filterList.get(pos++).doFilter(authProvider, filterChain);

    }
}
```

接下来是两个具体的验证处理器实现类`UsernamePasswordProcessorPlus`和`OAuthProcessorPlus`：

```java
public class UsernamePasswordProcessorPlus implements AuthenticationProcessorPlus {

    @Override
    public void doFilter(AuthenticationProvider authProvider, AuthenticationProcessorPlus filterChain) {
        if (authProvider instanceof UsernamePasswordProvider) {
            System.out.println("UsernamePasswordProcessor success...");
            return;
        }
        filterChain.doFilter(authProvider, filterChain);
    }
}


public class OAuthProcessorPlus implements AuthenticationProcessorPlus {

    @Override
    public void doFilter(AuthenticationProvider authProvider, AuthenticationProcessorPlus filterChain) {
        if (authProvider instanceof OAuthProvider) {
            System.out.println("OAuthProcessor success...");
            return;
        }
        filterChain.doFilter(authProvider, filterChain);
    }

}
```

### 3. 验证

```java
public class TestClass {

    @Test
    void testUserPasswordProviderPlus() {
        AuthenticationProvider provider = new OAuthProvider();

        AuthenticationProcessorPlus usernamePasswordProcessor = new UsernamePasswordProcessorPlus();
        AuthenticationProcessorPlus oAuthProcessor = new OAuthProcessorPlus();

        FilterChain filterChain = new FilterChain();
        filterChain.addAuth(usernamePasswordProcessor);
        filterChain.addAuth(oAuthProcessor);

        filterChain.doFilter(provider, filterChain);

    }

}
```

输出结果：

```vim
OAuthProcessor success...
```

可能有人会觉得，一旦添加/减少处理器，还是需要改动客户端代码，但在实际项目中，我们往往可以借助Spring Bean注入调用链即可：

```markup
<bean id="filterChain" class="xxx.xxx.xxx.FilterChain">
    <property name="filterChain">
        <list>
            <ref bean="usernamePasswordProcessor" />
            <ref bean="oAuthProcessor" />
        </list>
    </property>
</bean>
```

## 4. 使用场景

责任链最典型的应用就是Servlet中的Filter了，经过上述实践后，也可以明白为什么在web项目中Filter需要一个一个配置在web.xml中。

假如一个流程中有多个if，并且每个if之间都有一个统一的抽象流程，那么可以考虑使用责任链模式将辅助流程抽出来，将一个个if作为链式调用，从而达到实现优雅，易拔插，可扩展的目的。

## 5. Scala版

最后在此附上一个Scala版，Scala中的**偏函数**可以说是一个天然的责任链模式，输入源仍然沿用前面Java代码的AuthenticationProvider及其子类即可，下面只列出处理器实现：

```scala
// 定义验证类特质
trait _AuthenticationProcessor {
  def canAuth(provider: AuthenticationProvider): Boolean

  def doFilter(provider: AuthenticationProvider): String
  // 定义一个统一的偏函数模板
  def processor(provider: AuthenticationProvider => Boolean, doFilter: AuthenticationProvider => String): PartialFunction[AuthenticationProvider, Option[String]] = {
    case input: AuthenticationProvider if provider(input) => Try(doFilter(input)).toOption // 用于处理异常
  }
}
// 定义验证流程的具体实现类
object _OAuthProcessor extends _AuthenticationProcessor {

  override def canAuth(provider: AuthenticationProvider): Boolean = provider.isInstanceOf[OAuthProvider]

  override def doFilter(provider: AuthenticationProvider): String = "OAuthProcessor success..."

  def node(): PartialFunction[AuthenticationProvider, Option[String]] = super.processor(provider => this.canAuth(provider), provider => this.doFilter(provider))
}
// 定义验证流程的具体实现类
object _UsernamePasswordProcessor extends _AuthenticationProcessor {

  override def canAuth(provider: AuthenticationProvider): Boolean = provider.isInstanceOf[UsernamePasswordProvider]

  override def doFilter(provider: AuthenticationProvider): String = "UsernamePasswordProcessor success..."

  def node(): PartialFunction[AuthenticationProvider, Option[String]] = super.processor(provider => this.canAuth(provider), provider => this.doFilter(provider))
}

object TestCase {

  def main(args: Array[String]): Unit = {

    val provider = new UsernamePasswordProvider()

    val filterChain = _UsernamePasswordProcessor.node orElse _OAuthProcessor.node

    println(filterChain lift provider)
  }
}
```

上述第8行中使用了Try包含了对异常的处理，并转化为`Option[T]`类型（若无异常则为Some\(...\)，否则返回一个None），这是一种比较通用的方式。还有一种偏函数专用的处理法，在将参数传入责任链的时候使用`lift`方法，返回一个类型为`Option[T]`的结果：

```scala
filterChain.lift(provider)
```

## 6. Reference

* [Chain of Responsibility Design Pattern in Java](https://www.baeldung.com/chain-of-responsibility-pattern)
* [Java设计模式13：责任链模式](https://www.cnblogs.com/xrq730/p/10633761.html)
* [责任链模式Scala的7种实现](https://www.cnblogs.com/barrywxx/p/11212211.html)，里面有一个响应式实现，日后再看。

