---
title: TCP 协议
date: 2020-07-23 09:51:53
---
# TCP 协议

### 1. 什么是 TCP ？

传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。

建立 TCP 连接需要经过三次握手，断开 TCP 连接需要经过四次挥手，如下图：

![image](https://raw.githubusercontent.com/Rianico/Image/master/ARTS_Tips/202006040829.png)

### 2. 建立连接-三次握手

1. 客户端发送 SYN 包 \(syn=x\) 到服务器，并进入 `SYN_SEND` 状态，等待服务器确认;
2. 服務端收到 SYN 包，返回代表自身的 SYN\(syn=y\) 及代表確認收到並應答的 ACK\(ack=x+1\) 包，進入 `SYN_RCVD` 狀態；
3. 客戶端收到服務端的 `SYN` 跟 `ACK` 后，返回代表確認的 ACK\(y+1\) 包。雙方進入 `ESTABLISHED` 狀態。

### 3. 断开连接-四次挥手

连接的其中一端调用 close 发起断开，则称该端执行 “主动关闭”（active close），對應接受的端執行“被动关闭”（passive close）。断开连接需要经过四次挥手，过程如下：

1. 主动关闭端發送一个 `FIN` 包，表示数据发送完毕，進入 `ESTABLISHED -> FIN_WAIT_1` 狀態。
   * `FIN` **会被放在被動端排隊等候的任何其他数据之后**。
2. 被動端接收到 FIN 并处理后，返回一個 ACK，進入 `ESTABLISHED -> CLOSE_WAIT` 狀態，此時若有數據则會繼續發送。
   * 主動端接收到 ACK 后，進入 `FIN_WAIT_1 -> FIN_WAIT_2` 狀態，之后等待對方發送完數據。
3. 被動端傳輸完數據後，也發送一個 FIN 報文，進入`CLOSE_WAIT -> LAST_ACK` 狀態。
4. 主動方收到了对方的 `FIN` 报文，并发送出了 `ACK` 报文，进入 `FIN_WAIT_2 -> TIME_WAIT` 状态，等待 `2MSL`（2min/MSL） 后进入 `CLOSED` 状态，释放端口。
   * 被动接受端接收到 ACK 后，进入 `LAST_ACK -> CLOESD` 状态，释放端口。
   * 主动方如果在 `FIN_WAIT_1` 状态下，收到了对方同时带 `FIN` 标志和 `ACK` 标志的报文，可以直接 `FIN_WAIT_1 -> TIME_WAIT` 状态，而无须经过 `FIN_WAIT_1 -> FIN_WAIT_2 -> TIME_WAIT` 状态。

### 4. 思考

#### **1. 为什么需要 `TIME_WAIT` 状态？**

主要有两个原因：

* 主动发起断开连接的一端，在发送完最后一个 ACK 后，仍有可能接收到来自对端的数据（如网络抖动、延迟等因素），为了表面其被认为是一个新的 TCP 连接，需要一个状态来标记为端口暂时不可用，直到延迟到达的数据消失，这就是 TIME\_WAIT 的作用之一，通常该状态维持 2MSL。
* TCP 为了实现可靠的全双工连接的终止，需要考虑到主动发起端在接收到对端的 FIN 后发送最终的 ACK 时可能会因为网络等种种因素没有到达对端，这时对端会再次发送 FIN ，需要一个 `TIME_WAITE` 状态能够处理重新接收到的 FIN。

#### 2. 如果主动关闭端进入 TIME\_WAIT 状态后，对端立刻复用同个端口会发生什么？

1. 对端发起一个 SYN。
2. 由于正处于 `TIME_WAIT` 状态，主动关闭端会认为该报文属于 “迟到” 的报文，因此会重新发送之前四次挥手时最后的 ACK 报文。
3. 对端接收到 ACK 报文，发现跟自己发起的 SYN 中的 Seq 对不上，于是发送一个 RST 报文。
4. 主动关闭端接收到 RST 报文后，立刻进入 `CLOSED` 状态。
5. 对端重新发送之前的 SYN，开始重新三次握手建立连接。

#### 3. 什么是 RST 报文？

RST（Reset the connection），TCP 报文的其中一种，在接收到 RST 报文后，无论当前连接处于什么状态，都立即进入 `CLOSED` 状态。

#### 4. 什么时候会发送 RST 报文？

1. connect 一个不存在的端口；
   * 通常来讲，为了避免被外部通过此方式扫描到该端口是否有在提供端口，位于不明连接通常是不返回任何报文较为安全。
2. A 要与 B 建立连接，A 发送报文的时间超过了 B 的超时时间，B会返回一个 RST；
3. TCP 想要放弃一个当前已有的连接：
   * 比如客户端连接服务器，触发了服务器安全入侵策略，服务器发送 RST 中断连接。
4. 接收到了一个并不存在当前记录信息的报文：
   * 比如前面提到的端口复用
   * 比如某服务器重启，客户端却又保留着之前的连接

