(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{771:function(t,e,r){"use strict";r.r(e);var n=r(70),a=Object(n.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"线程数应该如何确定？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#线程数应该如何确定？"}},[t._v("#")]),t._v(" 线程数应该如何确定？")]),t._v(" "),r("p",[r("a",{attrs:{href:"https://www.jianshu.com/p/a8f653fc0c54",target:"_blank",rel:"noopener noreferrer"}},[t._v("数据库连接池到底应该设多大？这篇文章可能会颠覆你的认知"),r("OutboundLink")],1)]),t._v(" "),r("p",[t._v("虽然这篇文章讲的是关于数据库连接池的线程数设定，但是也可以从中窥见一些关于线程数设定的经验。")]),t._v(" "),r("p",[t._v("根据计算机原理，并发执行其实只是 CPU 对时间片上的分配，一旦线程数超过处理器的核心数，加上线程之间切换的开销，这时候越增加线程只会越慢。。。因此思考线程数的问题不是最大应该给多大，而是最少应该分配多少。一般最佳的线程数起步设定是从**（（核心数 * 2）or 超线程数目） + 有效磁盘数** 起步进行测试调整。")]),t._v(" "),r("p",[t._v("一般来说，task可以分为 I/O 密集型以及 CPU 密集型两种。")]),t._v(" "),r("p",[t._v("I/O 密集型的可以根据 task 的阻塞情况，比如读写磁盘，socket访问等，机器通常表现为 "),r("strong",[t._v("CPU 利用率低，但是 load 高（CPU 密集型则反之）")]),t._v("。由于"),r("strong",[t._v("线程需要阻塞直到处理完成")]),t._v("，因此这时候就可以根据具体磁盘的数量增加线程数，增加的线程数也就对应了上面的 "),r("strong",[t._v("有效磁盘数")]),t._v(" 。")]),t._v(" "),r("p",[t._v("再说个与缓存有关系的地方，假如有效数据都能在缓存中命中，那么这时候其实对磁盘的读写基本没有，那么这时候就不用考虑有效磁盘数了。")]),t._v(" "),r("p",[t._v("但即便如此，想要一次直接得到线程数的最佳数量是不可能的，并且根据业务流量不同时间段也有不同的配置，因此在大致确定适合的线程数范围后，应该着眼于是否可以将修改线程的成本降低。")]),t._v(" "),r("p",[t._v("所幸的是， Java 的线程池支持运行时修改线程数量等参数，详见：")]),t._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Java线程池实现原理及其在美团业务中的实践"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://juejin.im/post/5e93e2e7f265da47ff7ccd21",target:"_blank",rel:"noopener noreferrer"}},[t._v("如何设置线程池参数？美团给出了一个让面试官虎躯一震的回答。"),r("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=a.exports}}]);