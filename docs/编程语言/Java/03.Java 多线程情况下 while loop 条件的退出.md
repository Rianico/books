---
title: Java 多线程情况下 while loop 条件的退出
date: 2020-06-09 11:30:14
---
# Java 多线程情况下 while loop 条件的退出

这几天在掘金上看到一篇很有意思的文章[【编程玄学】一个困扰我122天的技术问题，我好像知道答案了。](https://juejin.im/post/5e7771446fb9a07cce7507f2)

里面提及到一段代码：

```java
public class VolatileExample {

    private static boolean flag = false;
    private static int i = 0;

    public static void main(String[] args) throws InterruptedException {
        new Thread(() -> {
            try {
                TimeUnit.SECONDS.sleep(1);
                flag = true;
                System.out.println("修改为true");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();

         while (!flag) {
            i++;
        }
        System.out.println(i);
    }
}
```

请问，这个程序能不能正常结束？

稍微有点基础的 Java 开发人员都会说不能，**因为变量 flag 不是 volatile 类型的，一个线程对 flag 做出的修改，另一个线程无法看到**，因此这里会导致 while 循环的条件恒为 true，从而进入无限循环。

其实这里面包含的东西不仅仅那么简单， 实际上，一个线程对某个公共变量做出的修改， **在变量不是 volatile 类型的前提下，Java 内存模型只能保证其他线程尽可能的看到该变量的修改（而 volatile 是一定能够看到）**。

这个结论与一般直觉相背，因为如果这么说的话，那么上面的程序应该是应该能够正常结束的，但实际运行的结果是程序无法正常结束。

这里先卖个关子（tips：与 JIT 有关），接下来下面逐个介绍可以令程序正常结束的 n 种方式。

## 1. flag 设置为 volatile 类型

这应该是个老生常谈的方法，当 flag 为 volatile 类型的时候，Java 内存模型保证一个线程对该变量做出的修改，其他线程一定能够看到，但这里要注意 volatile 并不保证复合操作（e.g. i++）能够立刻被其他线程看到。

## 2.while loop 中添加 synchronized 关键字

其实 volatile 可以看成是轻量级的 synchronized，在 Java 内存模型中，这两个关键字都有以下内存语义：

* 当前线程的写操作，会强制刷新到主存中。
* 当前线程的读操作，会强制先从主存中获取。

上面两句的说法并不严谨，但这里不是重点，重点是由于存在上述两个内存语义，可以让 volatile 以及 synchronized 能够在多线程环境下读取到正确的变量。

while 循环代码如下：

```java
while (!flag) {
    i++;
    // 查看源代码，可以发现 System.out.println 里面有个 synchronized 关键字
    System.out.println(i);
}
```

## 3. while 循环里执行 sleep\(\)、yield\(\)

这个停止的方式可能不那么常见了，代码如下：

```java
while (!flag) {
    Thread.sleep(1);
    i++;
}
```

或许很多人会想，`Thread.sleep()` 是不是也有类似锁的内存语义，答案是并没有。

其实这里的原理在官方文档有介绍过，链接：[17.3. Sleep and Yield](https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.3)。

其中有这么一段话：

> It is important to note that neither `Thread.sleep` nor `Thread.yield` have any synchronization semantics. In particular, the compiler does not have to flush writes cached in registers out to shared memory before a call to `Thread.sleep` or `Thread.yield`, nor does the compiler have to reload values cached in registers after a call to `Thread.sleep` or `Thread.yield`.

这段话明确说明了，sleep 以及 yield 是没有同步语义的，也不需要像 volatile 以及 synchronized 一样会强制刷新结果到内存，以及强制从内存中读取结果，但是下面还有一段：

> For example, in the following \(broken\) code fragment, assume that `this.done` is a non-`volatile boolean` field:
>
> while \(!this.done\) Thread.sleep\(1000\);
>
> The compiler is free to read the field `this.done` just once, and reuse the cached value in each execution of the loop. This would mean that the loop would never terminate, even if another thread changed the value of `this.done`.

The compiler is **free** to read the field `this.done` just once, and reuse the cached value in each execution of the loop. 这句话是重点，free 用的很精髓，也就是说，如果在循环中使用了 sleep\(\)、yeild\(\) 方法，编译器可能会重新从主存中重新读取变量，也可能不会。

## 4. 禁用 JIT 优化

从这里开始要开始论证 **在变量不是 volatile 类型的前提下，Java 内存模型只能保证其他线程尽可能的看到该变量的修改（而 volatile 是一定能够看到）** 这句话了。

在我们运行最开始的程序的之前，可以加上 `-Djava.compiler=NONE` 禁用 JIT 编译，运行结果如下：

![image](https://raw.githubusercontent.com/Rianico/Image/master/ARTS_Tips/Snipaste_2020-05-04_12-49-21.png)

可以看到，程序居然正常结束了！

所以可以证明前面的结论：**在变量不是 volatile 类型的前提下，Java 内存模型只能保证其他线程尽可能的看到该变量的修改（而 volatile 是一定能够看到）** 。之所以我们常见到的程序不能正常结束的原因，就是 JIT 搞的鬼。

那么 JIT 做了什么事情？其实这是编译器为我们做的一个优化，当一个代码被判定为热点代码的时候，编译器会对其做一个优化提升，而在这里做的一个优化便是**循环表达式外提（Loop Expression Hoisting）**，导致形成死循环。

JIT 优化后的代码可以看成如下：

```java
while (!flag) {
    while (true) i++;
}
```

由于修改 flag 的线程休眠了一段时间，导致 while 循环的次数超过了一定的次数，从而触发了 JIT 优化，造成了死循环。

从这句话，我们又可以衍生出一个方式，修改 flag 的线程如果不休眠，那么程序能否正常结束？

答案是能，运行结果如下：

![image](https://raw.githubusercontent.com/Rianico/Image/master/ARTS_Tips/image-20200504130107956.png)

这里不做休眠，从而让 while 循环不会成为热点代码，也就不会触发 JIT 的优化了。

## 5. 修改 i 为 volatile 类型

我们将 i 修改为 volatile 也能达到同样的效果：

![image](https://raw.githubusercontent.com/Rianico/Image/master/ARTS_Tips/Snipaste_2020-05-04_13-04-16.png)

但是 while 循环里判断的不是 flag 变量么？为什么 i 为 volatile 也可以正常结束？

其实线程一点，这里可以理解为跟循环体内有 synchronized 关键字一样，但是我们还可以再深一步挖掘，可以发现，最后还是跟 JIT 有关。

这里我使用 JITWatcher 来查看代码编译后的汇编代码。

### 5.1 修改 i 为 volatile 之前

我们查看最开始的代码的汇编结果，其中 while 循环的汇编代码如下：

![image](https://raw.githubusercontent.com/Rianico/Image/master/ARTS_Tips/Snipaste_2020-05-03_13-12-01.png)

这里看不懂也没关系，只要看 L0000 跟 jmp L0000 之间的汇编代码后面提示的代码行数就行了，我这里 line 45 对应着 `i++`。可以看到，在 JIT 优化后，查看汇编结果，实际上代码一直就再也没有去到过 line 44（对应 `while(!flag)` ）了。

### 5.2 修改 i 为 volatile 之后

接下来我们将 i 修改为 volatile 类型，查看汇编代码

![image](https://raw.githubusercontent.com/Rianico/Image/master/ARTS_Tips/Snipaste_2020-05-03_13-11-54.png)

依然看不懂。。。不过没关系，我们可以看到在黄色部分执行的 `i++` 操作后，下面又回到了 line 44，也就是实际程序又再一次重新去获取 flag 变量了！因此最终程序能够正常结束。

### 5.3 结论

当 while loop 里有 volatile、synchronized 这类有同步语义操作的时候，会对 JIT 产生一些影响。而这里就是令 JIT 不会产生死循环优化。

## 6. 修改 i 为 Integer 包装类型

将 i 修改为 Integer 包装类型，运行结果如下：

![image](https://raw.githubusercontent.com/Rianico/Image/master/ARTS_Tips/Snipaste_2020-05-04_13-20-02.png)

可以看到，程序居然也正常结束了。

但目前此处尚未探究明白，待后面在做研究。

## 7. 结语

虽然这道程序以前自己就看到过，但是说来惭愧，当时并没能够引起如此多的思考，而是在掘金看到那篇文章后才恍然醒悟。在这里感谢所有发布优质文章，分享自己思考成果的作者们。

参考列表：

* [【编程玄学】一个困扰我122天的技术问题，我好像知道答案了。](https://juejin.im/post/5e7771446fb9a07cce7507f2)
* [17.3. Sleep and Yield](https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.3)
* [Understanding volatile via example](https://plumbr.io/blog/locked-threads/understanding-volatile-via-example)
* [为什么volatile注释变量，对其下面的变量也会有影响？](https://www.zhihu.com/question/348513270)

