---
title: CPU Cache 与缓存行
date: 2020-07-22 10:57:05
---
# CPU Cache 与缓存行

详见：[https://www.cnkirito.moe/cache-line/](https://www.cnkirito.moe/cache-line/)

CPU 缓存行中如果有多个对象，其中一个对象（或者对象部分数据）被修改了，那么对于 CPU 来说，该缓存行就是失效的，需要重新从主存中获取，这样一来，就会影响其他并不需要修改的对象。如果一个缓存行中经常有部分对象需要修改，那么就令 CPU CACHE 失去了意义。

通过字节填充（注意对象头填充 8 字节），使得某个对象直接占用了一个缓存行，这样一来，即使修改了其他对象，也不会使得缓存失效，从而保证能被 CPU CACHE 命中。

在 某些 JDK 版本（&gt;= 1.7）,JVM 可能会将填充的字节当做无效代码优化掉，有两种方法可以避免优化：

* 将填充字段定义在一个抽象父类，并继承。
* 使用 Java 8 的官方注解 `@Contended` 自动填充对齐，同时 JVM 需要开启 `-XX:-RestrictContended=false`

```vim
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD, ElementType.TYPE})
public @interface Contended {
    String value() default "";
}
```

> NOTE：@Contended 注解会增加目标实例大小，要谨慎使用。默认情况下，除了 JDK 内部的类，JVM 会忽略该注解。要应用代码支持的话，要设置 -XX:-RestrictContended=false，它默认为 true（意味仅限 JDK 内部的类使用）。当然，也有个 –XX: EnableContented 的配置参数，来控制开启和关闭该注解的功能，默认是 true，如果改为 false，可以减少 Thread 和 ConcurrentHashMap 类的大小。参加《Java 性能权威指南》210 页。
>
> — @Im 的补充

一些官方代码以及优秀开源软件的最佳实践：

*  **ConcurrentHashMap\#CountCell**
*  **Thread\#threadLocalRandomSeed**
*  **RingBuffer**

