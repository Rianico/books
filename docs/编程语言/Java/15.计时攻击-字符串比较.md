---
title: 15. 计时攻击-字符串比较
date: 2021-08-14
---

## 计时攻击-字符串比较

Java 的 Play Framework 里有一段验证字符串的代码：

```java
boolean safeEqual(String a, String b) {
   if (a.length() != b.length()) {
       return false;
   }
   int equal = 0;
   for (int i = 0; i < a.length(); i++) {
       equal |= a.charAt(i) ^ b.charAt(i);
   }
   return equal == 0;
}
```

不像 JDK 中常用的字符串比较方法，这种方式会遍历完整的字符串，性能会略差一点，但本质上还是为了**安全**，抵御计时攻击。

在**传统的字符串比较方式**中，一旦检测到不一致的字符串会立刻返回，与完整的遍历字符串相比，这种方式存在一个执行时间的微小差异（可能只有几微秒），但计时攻击就可以利用这种方式反推出密码。

由于时间差异很小，往往噪音会干扰判断结果，因此计时攻击首先针对第一个字符串发送多次请求，统计各个字符的检测时间排序，这样就可以通过放大的方式识别出噪音，从而推断出字符的内容，剩余字符串重复循环即可。

因此，对于那些字符范围很小的加密算法，如果不采用安全比较，往往很容易被攻破。

计时攻击往往用于攻击一些性能较弱的计算机设备（想想也正常，这类硬件一般为了性能，只能采用较为简单的加密算法），但在普通软件系统也是可用的（如基于 OpenSSL 的 Web 系统）。

安全比较字符串的实现思想为，定义一个状态变量，在遍历字符串的过程中，使用位操作符改变状态变量，JDK8 实现如下：

```java
public static boolean MessageDigest.isEqual(byte[] digesta, byte[] digestb) {
    if (digesta == digestb) return true;
    if (digesta == null || digestb == null) {
        return false;
    }
    if (digesta.length != digestb.length) {
        return false;
    }

    int result = 0;
    // time-constant comparison
    for (int i = 0; i < digesta.length; i++) {
        result |= digesta[i] ^ digestb[i];
    }
    return result == 0;
}
```

Refs：

- [计时攻击 TIMING ATTACKS](https://coolshell.cn/articles/21003.html)

