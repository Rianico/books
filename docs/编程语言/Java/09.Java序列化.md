---
title: Java序列化
date: 2020-08-02
---



# Java序列化

Java 的对象序列化将那些实现了 `java.io.Serializable` 接口的对象转化为字节，并且能够再将这些字节恢复为对象。

在 Java 中，当我们涉及将对象输出到外部（e.g. 网络传输、持久化到磁盘、存储到数据库等）时，就需要将对象序列化。

对象序列化时会保存对象在序列化那一刻的状态（包括其引用，静态变量较为特殊，后面会讨论），接着在反序列化时就能得到那一刻的状态：

```java
// serialization/Worm.java
// Demonstrates object serialization
import java.io.*;
import java.util.*;
class Data implements Serializable {
    private int n;
    Data(int n) { this.n = n; }
    @Override
    public String toString() {
        return Integer.toString(n);
    }
}
public class Worm implements Serializable {
    private static Random rand = new Random(47);
    private Data[] d = {
            new Data(rand.nextInt(10)),
            new Data(rand.nextInt(10)),
            new Data(rand.nextInt(10))
    };
    private Worm next;
    private char c;
    // Value of i == number of segments
    public Worm(int i, char x) {
        System.out.println("Worm constructor: " + i);
        c = x;
        if(--i > 0)
            next = new Worm(i, (char)(x + 1));
    }
    public Worm() {
        System.out.println("No-arg constructor");
    }
    @Override
    public String toString() {
        StringBuilder result = new StringBuilder(":");
        result.append(c);
        result.append("(");
        for(Data dat : d)
            result.append(dat);
        result.append(")");
        if(next != null)
            result.append(next);
        return result.toString();
    }
    public static void main(String[] args) throws ClassNotFoundException, IOException {
        Worm w = new Worm(6, 'a');
        System.out.println("w = " + w);
        try(
                ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("worm.dat"))
        ) {
            out.writeObject("Worm storage\n");
            out.writeObject(w);
        }
        try(
                ObjectInputStream in = new ObjectInputStream(new FileInputStream("worm.dat"))
        ) {
            String s = (String)in.readObject();
            Worm w2 = (Worm)in.readObject();
            System.out.println(s + "w2 = " + w2);
        }
        try(
                ByteArrayOutputStream bout = new ByteArrayOutputStream();
                ObjectOutputStream out2 = new ObjectOutputStream(bout)
        ) {
            out2.writeObject("Worm storage\n");
            out2.writeObject(w);
            out2.flush();
            try(
                    ObjectInputStream in2 = new ObjectInputStream(new ByteArrayInputStream(bout.toByteArray()))
            ) {
                String s = (String)in2.readObject();
                Worm w3 = (Worm)in2.readObject();
                System.out.println(s + "w3 = " + w3);
            }
        }
    }
}

```

输出为：

```bash
Worm constructor: 6
Worm constructor: 5
Worm constructor: 4
Worm constructor: 3
Worm constructor: 2
Worm constructor: 1
w = :a(853):b(119):c(802):d(788):e(199):f(881)
Worm storage
w2 = :a(853):b(119):c(802):d(788):e(199):f(881)
Worm storage
w3 = :a(853):b(119):c(802):d(788):e(199):f(881)
```

Worm 内的 Data 数组使用了随机数，然而在反序列化后，却还是原来的数字，这可以说明，**Java 的 java.io.Serializable 接口在反序列化的时候，并不会重新调用其构造器，所有数据都是从 InputStream 中获取的**。

## 1. 查找类

Java 在将对象序列化为字节后，如果要将其字节重新序列化为对象，那么要求序列化的 JVM 中必须能够找到对应类：

```java
// serialization/Alien.java
// A serializable class
import java.io.*;
public class Alien implements Serializable {}

// 新建 Alien 对象将其序列化后存到文件中
import java.io.*;
public class FreezeAlien {
    public static void main(String[] args) throws Exception {
        try(
                ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("X.file"));
        ) {
            Alien quellek = new Alien();
            out.writeObject(quellek);
        }
    }
}

// 读取文件，并得到其反序列化后的对象，查看属于哪个 class
package serialization.xfiles;
import java.io.*;
public class ThawAlien {
    public static void main(String[] args) throws Exception {
        ObjectInputStream in = new ObjectInputStream(new FileInputStream(new File("X.file")));
        Object mystery = in.readObject();
        System.out.println(mystery.getClass());
    }
}

// output：
class Alien
```

可以看到，反序列化后的对象属于 Alien，也就是要求 JVM 中存在该 class 。

## 2. 控制序列化

通常我们只需要让需要序列化的对象类继承 `java.io.Serializable`  即可，其余操作交由 Java 自己去执行，但有时候我们可能需要对序列化行为进行控制。

控制序列化行为的方式有好几种，其中常用的有 继承`java.io.Externalizable` 接口、使用 `transient` 关键字、添加 `readObject(...)/writeObject(...)`方法。

### 2.1 Externalizable

当一个类继承了 `java.io.Externalizable` 后，需要重写两个空方法：`public void writeExternal(ObjectOutput out){}` 以及 `public void readExternal(ObjectInput in){}`：

```java
// serialization/Blips.java
// Simple use of Externalizable & a pitfall
import java.io.*;
class Blip1 implements Externalizable {
    public Blip1() {
        System.out.println("Blip1 Constructor");
    }
    @Override
    public void writeExternal(ObjectOutput out) throws IOException {
        System.out.println("Blip1.writeExternal");
    }
    @Override
    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
        System.out.println("Blip1.readExternal");
    }
}
class Blip2 implements Externalizable {
    Blip2() {
        System.out.println("Blip2 Constructor");
    }
    @Override
    public void writeExternal(ObjectOutput out) throws IOException {
        System.out.println("Blip2.writeExternal");
    }
    @Override
    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
        System.out.println("Blip2.readExternal");
    }
}
public class Blips {
    public static void main(String[] args) {
        System.out.println("Constructing objects:");
        Blip1 b1 = new Blip1();
        Blip2 b2 = new Blip2();
        try(
                ObjectOutputStream o = new ObjectOutputStream(
                        new FileOutputStream("Blips.serialized"))
        ) {
            System.out.println("Saving objects:");
            o.writeObject(b1);
            o.writeObject(b2);
        } catch(IOException e) {
            throw new RuntimeException(e);
        }
        // Now get them back:
        System.out.println("Recovering b1:");
        try(
                ObjectInputStream in = new ObjectInputStream(new FileInputStream("Blips.serialized"))
        ) {
            b1 = (Blip1)in.readObject();
        } catch(IOException | ClassNotFoundException e) {
            throw new RuntimeException(e);
        }
        // OOPS! Throws an exception:
        //- System.out.println("Recovering b2:");
        //- b2 = (Blip2)in.readObject();
    }
}

// output：
Constructing objects:
Blip1 Constructor
Blip2 Constructor
Saving objects:
Blip1.writeExternal
Blip2.writeExternal
Recovering b1:
Blip1 Constructor
Blip1.readExternal
```

如果这里对 Blip2 进行反序列化，由于其默认构造器作用域不是 public 的，会导致错误并抛出异常。

这里可以看出， `java.io.Externalizable` 在反序列化的时候还会调用到类的默认构造器，且作用域必须为 public，这是与 `java.io.Serializable` 不同的一点。

下面是一个完整重写 Externalizable 的例子 ：

```java
// serialization/Blip3.java
// Reconstructing an externalizable object
import java.io.*;
public class Blip3 implements Externalizable {

	...

	@Override
    public void writeExternal(ObjectOutput out)
            throws IOException {
        System.out.println("Blip3.writeExternal");
// You must do this:
        out.writeObject(s);
        out.writeInt(i);
    }
    @Override
    public void readExternal(ObjectInput in)
            throws IOException, ClassNotFoundException {
        System.out.println("Blip3.readExternal");
// You must do this:
        s = (String)in.readObject();
        i = in.readInt();
    }
    
    ...
    
}
```

我们需要在 `writeExternal` 中对 `s` 以及 `i` 进行序列化，后面的 `readExternal` 进行反序列化并赋值，之后我们才能读取到 `s` 以及 `i` ，并且**反序列化 `readExternal` 发生于默认构造器之后**。

### 2.2 transient 关键字

当我们序列化对象的时候，如果有某些特定子对象不想让 Java 序列化机制保存其内容（e.g. 敏感信息等），那么可以用 `transient` 进行修饰，这样 Java 序列化时就不会保存其内容：

```java
// serialization/Logon.java
// Demonstrates the "transient" keyword
import java.util.concurrent.*;
import java.io.*;
import java.util.*;
import onjava.Nap;
public class Logon implements Serializable {
    private Date date = new Date();
    private String username;
    private transient String password;
    public Logon(String name, String pwd) {
        username = name;
        password = pwd;
    }
    @Override
    public String toString() {
        return "logon info: \n username: " +
                username + "\n date: " + date +
                "\n password: " + password;
    }
    public static void main(String[] args) {
        Logon a = new Logon("Hulk", "myLittlePony");
        System.out.println("logon a = " + a);
        try(
                ObjectOutputStream o =
                        new ObjectOutputStream(
                                new FileOutputStream("Logon.dat"))
        ) {
            o.writeObject(a);
        } catch(IOException e) {
            throw new RuntimeException(e);
        }
        new Nap(1);
// Now get them back:
        try(
                ObjectInputStream in = new ObjectInputStream(
                        new FileInputStream("Logon.dat"))
        ) {
            System.out.println(
                    "Recovering object at " + new Date());
            a = (Logon)in.readObject();
        } catch(IOException | ClassNotFoundException e) {
            throw new RuntimeException(e);
        }
        System.out.println("logon a = " + a);
    }
}
// output：
logon a = logon info:
username: Hulk
date: Tue May 09 06:07:47 MDT 2017
password: myLittlePony
Recovering object at Tue May 09 06:07:49 MDT 2017
logon a = logon info:
username: Hulk
date: Tue May 09 06:07:47 MDT 2017
password: null
```

### 2.3 writeObject() 和 readObject()

如果不想使用 Externalizable 接口从头实现一套序列化，那么也可以在继承 `Serializable` 接口的前提下，通过**添加** `writeObject()` 和 `readObject()` 来控制序列化的一些行为，并且这两个方法签名必须如下：

```java
private void writeObject(ObjectOutputStream stream) throws IOException

private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException
```

> NOTE：这两个方法确实比较混乱，Serializable 接口中并没有规定这两个方法，但序列化中又能够通过反射来调用这两个方法。

这里有个技巧，就是我们可以在 `writeObject()` 中调用 `defaultWriteObject()` 来选择执行默认的 `writeObject()`，` readObject()`  则是调用 `defaultReadObject()`：

```java
// serialization/SerialCtl.java
// Controlling serialization by adding your own
// writeObject() and readObject() methods
import java.io.*;
public class SerialCtl implements Serializable {
    private String a;
    private transient String b;
    public SerialCtl(String aa, String bb) {
        a = "Not Transient: " + aa;
        b = "Transient: " + bb;
    }
    @Override
    public String toString() { return a + "\n" + b; }
    private void writeObject(ObjectOutputStream stream)
            throws IOException {
        stream.defaultWriteObject();
        stream.writeObject(b);
    }
    private void readObject(ObjectInputStream stream)
            throws IOException, ClassNotFoundException {
        stream.defaultReadObject();
        b = (String)stream.readObject();
    }
    public static void main(String[] args) {
        SerialCtl sc = new SerialCtl("Test1", "Test2");
        System.out.println("Before:\n" + sc);
        try (
                ByteArrayOutputStream buf =
                        new ByteArrayOutputStream();
                ObjectOutputStream o =
                        new ObjectOutputStream(buf);
        ) {
            o.writeObject(sc);
// Now get it back:
            try (
                    ObjectInputStream in =
                            new ObjectInputStream(
                                    new ByteArrayInputStream(
                                            buf.toByteArray()));
            ) {
                SerialCtl sc2 = (SerialCtl)in.readObject();
                System.out.println("After:\n" + sc2);
            }
        } catch(IOException | ClassNotFoundException e) {
            throw new RuntimeException(e);
        }
    }
}
// output：
Before:
Not Transient: Test1
Transient: Test2
After:
Not Transient: Test1
Transient: Test2
```

可以看到，transient 的行为也可以被控制。

### 2.4 版本控制

版本控制场景很少见到，而且非常难，这里可以参考 https://www.oracle.com/java/technologies/ ，此处不做赘述。

## 3. 持久化

序列化的本质是存储对象的一些状态为字节，之后再转化为对象。那这里可以引申出几个问题：

1. 如果两个不同的对象都持有同一个第三方对象的引用，那么前面两个不同的对象在 序列化-反序列化 后，第三方对象还是只有一个吗？
2. 如果将这两个对象序列化为不同的文件，再反序列化读取出来，结果又会如何？

看以下例子：

```java
// 序列化工具
import java.io.*;
public class SerializeTools {

    static void serAndDesc(Object obj) {
        Object res = null;
        try(
                ByteArrayOutputStream bos = new ByteArrayOutputStream();
                final ObjectOutputStream oos = new ObjectOutputStream(bos)
        ) {
            oos.writeObject(obj);
            oos.flush();
            try(
                    final ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
                    final ObjectInputStream ois = new ObjectInputStream(bis)
            ) {
                res = ois.readObject();
                System.out.println(res);
            }
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }

}

// 序列化的类
import java.io.Serializable;
public class Animal implements Serializable {

    private House house;
    private String name;

    public Animal(House house, String name) {
        this.house = house;
        this.name = name;
    }

    @Override
    public String toString() {
        return "\n" + super.toString() + " , " + house.toString();
    }
    
        public static void main(String[] args) {
        House house = new House();
        Animal tom = new Animal(house, "Tom");
        Animal jerry = new Animal(house, "Jerry");
        List<Animal> animals = new ArrayList<>();
        animals.add(tom);
        animals.add(jerry);
        SerializeTools.serAndDesc(animals);
        SerializeTools.serAndDesc(tom);
        SerializeTools.serAndDesc(jerry);
    }
}

// output：
[
my.serializable.Animal@9807454 , my.serializable.House@3d494fbf, 
my.serializable.Animal@1ddc4ec2 , my.serializable.House@3d494fbf]

my.serializable.Animal@133314b , my.serializable.House@b1bc7ed

my.serializable.Animal@7cd84586 , my.serializable.House@30dae81
```

我们首先将两个持有相同第三方对象引用的不同对象放到数组中，送到同一个 I/O 流中，结果不同的对象仍然不同，而原本的第三方对象只出现一次。

接着是将两个持有相同第三方对象引用的不同对象送到不同的 I/O 流中，不同的对象仍然不同，但原本的第三方对象出现了两个实例。

也就是说，不同的流彼此之间并无法相互得知两边有一个同样的 class，因此产生了不同的实例对象。

### 3.1 static 对象序列化

static 对象的序列化与普通对象不一样，普通对象是与类实例绑定的，而静态对象是与 class 绑定的。

Java 序列化实例对象的时候，**默认是不会保存 static 对象的，static 对象会直接去 JVM 的方法区获取**。

> NOTE：方法区实际上是 JVM 规范规定的一块逻辑区域，不同虚拟机的实现也不一样，以 HotSpot 为例，JDK8 之前，方法区处于永久代；JDK8 开始，永久代改为了元数据区，而静态变量则放到了堆中。

如果需要对修改后 static 字段进行保存，那么在前面介绍的控制序列化行为的方法中添加即可。

### 3.2 父类字段序列化  

如果我们定义了一个抽象类，并被继承，如果没有定义相关构造器，默认情况下子类实例对象序列化的时候，父类对象的字段是不会序列化的，除非控制序列化行为：

```java
enum House {
    BIG, MIDIUM, SMALL
}
// 定义父类
public abstract class Animal {

    protected String name;

    public void setName(String name) {
        this.name = name;
    }

    public String toString() {
        return getClass() + " , " + name;
    }

}

// Cat.java
import java.io.Serializable;
public class Cat extends Animal implements Serializable {

    private static House house = House.BIG;

    public Cat(String name) {
        super.setName(name);
    }

    public static void setHouse(House house) {
        Cat.house = house;
    }

    @Override
    public String toString() {
        return super.toString() + " , " + house.toString();
    }
}

// Mouse.java，控制序列化行为
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;

public class Mouse extends Animal implements Serializable {

    private static House house = House.BIG;

    public Mouse(String name) {
        super.setName(name);
    }

    public static void setHouse(House house) {
        Mouse.house = house;
    }

    private void writeObject(ObjectOutputStream stream) throws IOException {
        stream.defaultWriteObject();
        stream.writeObject(house);
        stream.writeObject(super.name);
    }

    private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
        stream.defaultReadObject();
        house = (House) stream.readObject();
        name = (String) stream.readObject();
    }

    @Override
    public String toString() {
        return super.toString() + " , " + house.toString();
    }
}



// output：
class my.serializable.Cat , null , BIG
class my.serializable.Mouse , Jelly , BIG
```

可以看到， Cat 中父类的 name 值为 null，并没有没序列化。

如果父类定义了构造器，那么子类也需要调用父类构造器，同时父类还需要继承 Serializable 接口，这时，父类字段就会被序列化了。

### 3.3 父类静态字段序列化

如果父类字段有继承 Serializable 接口s，并持有一个静态字段，那么 序列化-反序列化 结果会如何？

如果没有重写序列化行为，那么父类的静态字段跟普通的静态字段一样，从 JVM 全局去取。

如果重写了序列化行为，那么父类的静态字段表现的跟普通字段一样，不同 I/O 流反序列出来的实例对象也不一样。