---
title: 理解 Java 中的 Enum
date: 2020-05-26 17:06:05
---
# 理解 Java 中的 Enum



## 1. Enum类型的介绍

枚举类型在JDK1.5开始出现，可以**将一组类似的值包含到一种类型中**，枚举类型的名称会被定义成独一无二的类型描述符（即变量名的名称可以说是类型），对比常量类型，枚举类型可以为申明的变量提供更大的取值范围。

## 2. Enum对比常量的优势

我们先使用常量方式定义七种颜色：

```java
public static class RainbowColor { 

   // 红橙黄绿青蓝紫七种颜色的常量定义
   public static final int RED = 0; 
   public static final int ORANGE = 1; 
   public static final int YELLOW = 2; 
   public static final int GREEN = 3; 
   public static final int CYAN = 4; 
   public static final int BLUE = 5; 
   public static final int PURPLE = 6; 
   // public static final int ERROR = 0; 
}
```

以上方式中， 如果其它常量有相同的int值，若外部错误地调用了其它常量，即使是错误的，也很难发现，编译器也不会有警告（e.g. `switch/case`中）。

改为Enum类型的定义方式：

```java
enum RainbowColor { RED, ORANGE, YELLOW, GREEN, CYAN, BLUE, PURPLE }
```

使用枚举，不仅可以简单的将整形转换为对象，而且也可以为枚举值扩充方法和属性，以及实现任意的接口。

枚举类型默认实现了Comparable 和 Serializable 接口（通过编译可看出，后面会介绍），从而让开发者无需关心这些细节。

## 3. 定制Enum类型

除了前面介绍到的Enum的语法形态之外，我们还可以为Enum类型进行一些定制，如增加一些复杂功能，使用构造函数来给枚举增加属性，如下：

```java
enum RainbowColor {

    // 枚举对象需要遵循构造函数
    RED(0), ORANGE(1), YELLOW(2), GREEN(3), CYAN(4), BLUE(5), PURPLE(6);

    // 枚举对象的属性
    private int color;

    // 枚举对象构造函数
    RainbowColor(int color) {
        this.color = color;
    }

    // 枚举对象获取颜色的方法
    public int getColor() {
        return this.color;
    }

}
```

几个注意点： 1. Enum类型的构造函数默认为`private`或`friendly`，无法在程序中通过直接调用其构造方法来初始化。 2. 定义Enum对象的时候，如果是简单类型，那么最后一个枚举值后面不用跟任何一个符号；但如果有定制方法，那么最后一个枚举值与后面代码要用分号`';'`隔开。 3. Enum类型的实例是在运行期构造出的，在**分布式环境**中，**每个虚拟机都会构造出一个各自的枚举对象，不同虚拟机之间的枚举对象定义相同但不属于同个对象**（e.g. 使用`==`比较结果为false），使用`equals()`进行对比则取决于Enum的具体实现（到jdk1.8为止，equals也是使用`==`）。

## 4. Enum相关工具类

JDK1.5在增加Enum类的同时，也增加了两个工具类：

* **EnumSet**：针对枚举类实现的高性能的Set接口实现，装入EnumSet中的所有枚举类型必须是同一种类型，内部通过bit-vector（使用`elements`变量记录映射的Enum）来实现。EnumSet支持在枚举类型所有值中的某个范围进行迭代，以下面的`RainbowColor`为例：

```java
enum RainbowColor { RED, ORANGE, YELLOW, GREEN, CYAN, BLUE, PURPLE }
```

使用EnumSet取其中的一个范围：

```java
for (RainbowColor color : EnumSet.range(RainbowColor.RED, RainbowColor.BLUE)) {
    System.out.println(color);
}

// 输出：
RED
ORANGE
YELLOW
GREEN
CYAN
BLUE
```

EnumSet也提供了获取子集的 of 方法：

```java
for (RainbowColor color : EnumSet.of(RainbowColor.RED, RainbowColor.BLUE)) {
            System.out.println(color.ordinal());
}

// 输出：
RED
BLUE
```

* **EnumMap**：与EnumSet 类似，EnumMap 也是一个高性能的 Map 接口实现，用来管理使用枚举类型作为 keys 的映射表，内部是通过数组方式来实现。EnumMap 将丰富的和安全的 Map 接口与数组快速访问结合到一起，如果希望要将一个枚举类型映射到一个值，则可以使用使用 EnumMap。

```java
enum WeekDayEnum { Mon, Tue, Wed, Thu, Fri, Sat, Sun }

// 定义一个 EnumMap 对象，映射表主键是日期枚举类型，值是颜色枚举类型
private static Map<WeekDayEnum, RainbowColor> schema = 
           new EnumMap<WeekDayEnum, RainbowColor>(WeekDayEnum.class); 

static{ 
   // 将一周的每一天与彩虹的某一种色彩映射起来
   for (int i = 0; i < WeekDayEnum.values().length; i++) { 
       schema.put(WeekDayEnum.values()[i], RainbowColor.values()[i]); 
   } 
} 

System.out.println("What is the lucky color today?"); 
System.out.println("It's " + schema.get(WeekDayEnum.Sat));

// 输出：
What is the lucky color today? 
It's BLUE
```

## 5. Enum实现原理

首先对如下代码执行`javac RainbowColor.java`进行编译，会得到一个`RainbowColor.class`文件：

```java
enum RainbowColor {

    RED(0), ORANGE(1), YELLOW(2), GREEN(3), CYAN(4), BLUE(5), PURPLE(6);

    // 枚举对象的属性
    private int color;

    // 枚举对象构造函数
    RainbowColor(int color) {
        this.color = color;
    }

    public int getColor() {
        return this.color;
    }

}
```

接着对`RainbowColor.class`进行`javap RainbowColor.class`命令，得到如下输出：

```java
final class RainbowColor extends java.lang.Enum<RainbowColor> {
  public static final RainbowColor RED;

  public static final RainbowColor ORANGE;

  public static final RainbowColor YELLOW;

  public static final RainbowColor GREEN;

  public static final RainbowColor CYAN;

  public static final RainbowColor BLUE;

  public static final RainbowColor PURPLE;

  public static RainbowColor[] values();
    Code:
       0: getstatic     #1                  // Field $VALUES:[LRainbowColor;
       3: invokevirtual #2                  // Method "[LRainbowColor;".clone:()Ljava/lang/Object;
       6: checkcast     #3                  // class "[LRainbowColor;"
       9: areturn

  public static RainbowColor valueOf(java.lang.String);
    Code:
       0: ldc           #4                  // class RainbowColor
       2: aload_0
       3: invokestatic  #5                  // Method java/lang/Enum.valueOf:(Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Enum;
       6: checkcast     #4                  // class RainbowColor
       9: areturn

  public int getColor();
    Code:
       0: aload_0
       1: getfield      #7                  // Field color:I
       4: ireturn

  static {};
    Code:
       0: new           #4                  // class RainbowColor
       3: dup
       4: ldc           #8                  // String RED
       6: iconst_0
       7: iconst_0
       8: invokespecial #9                  // Method "<init>":(Ljava/lang/String;II)V
      11: putstatic     #10                 // Field RED:LRainbowColor;
      // 此处省略部分字节码......
      84: new           #4                  // class RainbowColor
      87: dup
      88: ldc           #21                 // String PURPLE
      90: bipush        6
      92: bipush        6
      94: invokespecial #9                  // Method "<init>":(Ljava/lang/String;II)V
      97: putstatic     #22                 // Field PURPLE:LRainbowColor;
     100: bipush        7
     102: anewarray     #4                  // class RainbowColor
     105: dup
     106: iconst_0
     107: getstatic     #10                 // Field RED:LRainbowColor;
     110: aastore
     111: dup
     // 此处省略部分字节码......
     147: aastore
     148: putstatic     #1                  // Field $VALUES:[LRainbowColor;
     151: return
}
```

从字节码来看，可以得到以下几点信息：

1.枚举类型实质上是通过继承`java.lang.Enum<T>`来实现的，是Java语言枚举类型的公共父类（注意Enum是抽象类），而`java.lang.Enum<T>`自身又实现了Comparable 和 Serializable 接口，并且是final类型，以下为它的常见方法：

| 返回类型 | 方法名称 | 方法说明 |
| :---: | :---: | :---: |
| int | compareTo\(E o\) | 比较此枚举与指定对象的顺序（默认实现） |
| boolean | equals\(Object other\) | 当指定对象等于此枚举常量时，返回 true |
| Class&lt;?&gt; | Class&lt;?&gt; | 返回此枚举常量的名称，在其枚举声明中对其进行声明 |
| int | ordinal\(\) | 返回枚举常量的序数（按照在枚举声明中的位置，其中初始常量序数为0） |
| String | name\(\) | 返回此枚举常量的名称，在其枚举声明中对其进行声明，与roString\(\)同等 |
| String | toString\(\) | 返回枚举常量的名称，它包含在声明中，与name\(\)同等 |
| static&lt;T extends Enum&lt;T&gt;&gt; T | static valueOf\(Class&lt;T&gt; enumType, String name\) | 返回带指定名称的指定枚举类型的枚举常量 |

2.编译器生成了7个`RainbowColor`静态实例对象，这说明我们定义的枚举常量实质上是RainbowColor实例对象。

3.其中的static{}静态代码块是为前面7个静态实例对象进行初始化，并且会将它们保存到一个类型为`RainbowColor`的`$VALUES`数组中。

4.编译器还生成了两个静态方法，分别是`values()`和`valueOf(java.lang.String)`，其中`values()`方法是返回枚举类中的所有枚举对象（从字节码的static{}代码块中可以看出实质上是返回了`$VALUES`数组），而`valueOf(java.lang.String)`则是根据传入的字符串返回相同名称的枚举对象（最终也是调用了Enum父类里的 `valueOf(Class<T> enumType, String name)`方法）：

```java
// values()方法
System.out.println(Arrays.toString(RainbowColor.values()));
// output:
[RED, ORANGE, YELLOW, GREEN, CYAN, BLUE, PURPLE]


// valueOf(java.lang.String)方法
System.out.println(RainbowColor.valueOf("RED"));
// output：
RED
```

需要注意的是，上述两个方法是编译器为枚举实例生成的方法，一旦将其向上转为Enum类型，这两个方法则会失效，因为在Enum类中并没有这两个方法。

即使不使用`values()`方法，Enum类仍可以通过反射获取所有的枚举对象：

```java
Enum e = RainbowColor.RED;
Class<?> clazz = e.getDeclaringClass();
for(RainbowColor color : (RainbowColor[])clazz.getEnumConstants()) {
    System.out.println(color);
}

// 输出
RED
ORANGE
YELLOW
GREEN
CYAN
BLUE
PURPLE
```

## 6. 相关扩展

### 1. Enum中定义抽象方法

Enum允许我们定义一个抽象方法\(`abstract`关键字不是必须的\)，然后每个枚举实例都各自实现该方法，从而产生各自特定的行为，一个比较经典的例子是JDK中的TimeUnit类：

```java
public enum TimeUnit {
    NANOSECONDS {
        public long toNanos(long d)   { return d; }
        // 此处省略其余方法...
    },
    // ...
    DAYS {
        public long toNanos(long d)   { return x(d, C6/C0, MAX/(C6/C0)); }
        // ...
    };

    // ...
    public long toNanos(long duration) { throw new AbstractMethodError(); }

}
```

### 2. 枚举与单例模式

单例模式是个老生常谈的问题了，有各种各样的实现方法，常见的线程安全的方式有饿汉式，双重锁检查，静态内部实例类，这几种方式都有两个共同的缺点：

* 序列化可能会破坏单例模式，比如每次反序列化一个序列化对象后是一个新的实例，解决方案为重写反序列化方法：

```java
public class Singleton implements java.io.Serializable {     
   public static Singleton INSTANCE = new Singleton();     

   protected Singleton() {     
   }  

   //反序列时直接返回当前INSTANCE
   private Object readResolve() {     
            return INSTANCE;     
   }    
}
```

* 使用反射强行调用私有构造器，解决方式可以修改构造器，让它在创建第二个实例的时候抛异常：

```java
public static Singleton INSTANCE = new Singleton();     
private static volatile  boolean  flag = true;
private Singleton(){
    if(flag){
    flag = false;
    // 构造所需信息
    } else {
        throw new RuntimeException("The instance  already exists ！");
    }
}
```

为了解决上述问题，我们新增了不少代码，为了能够更加简单高效，可以使用枚举单例。

```java
public enum  SingletonEnum {
    INSTANCE("SingletonEnum")
    private String name;
    public String getName(){
        return name;
    }
    public void setName(String name){
        this.name = name;
    }
}
```

我们可以按照常规类一样编写enum类，为其添加变量和方法，序列化是由JVM保证的；每一个枚举类型和定义的枚举实例在JVM中都是唯一的，枚举类的序列化和反序列化在Java中有特殊规定：**在序列化时Java仅仅是将枚举对象的name属性输出到结果中，反序列化时再通过java.lang.Enum的valueOf方法来根据名字获取枚举对象，从而避免了新建枚举对象，**并且同时编译器禁用了writeObject、readObject、readObjectNoData、writeReplace和readResolve等方法，从而保证了枚举实例的唯一性。

Enum类同时也无法通过反射创建，可以查看下反射中的newInstance方法源码：

```java
 public T newInstance(Object ... initargs)
        throws InstantiationException, IllegalAccessException,
               IllegalArgumentException, InvocationTargetException
    {
        if (!override) {
            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {
                Class<?> caller = Reflection.getCallerClass();
                checkAccess(caller, clazz, null, modifiers);
            }
        }
        //这里判断Modifier.ENUM是不是枚举修饰符，如果是就抛异常
        if ((clazz.getModifiers() & Modifier.ENUM) != 0)
            throw new IllegalArgumentException("Cannot reflectively create enum objects");
        ConstructorAccessor ca = constructorAccessor;   // read volatile
        if (ca == null) {
            ca = acquireConstructorAccessor();
        }
        @SuppressWarnings("unchecked")
        T inst = (T) ca.newInstance(initargs);
        return inst;
    }
```

## 7. 参考引用

* [深入理解Java枚举类型\(enum\)](https://blog.csdn.net/javazejian/article/details/71333103)，很全面的一篇，强烈推荐！
* [Java 语言中 Enum 类型的使用介绍](https://www.ibm.com/developerworks/cn/java/j-lo-enum/index.html)

