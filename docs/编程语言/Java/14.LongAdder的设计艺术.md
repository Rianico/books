---
title: 14.Longadder 的设计艺术
date: 2021-06-09
---

## LongAdder 的设计艺术

如果存在这样一个场景，多个线程需要对一个共享变量，不断地进行 +1 操作，那么需要怎么设计才能达到性能最优？

![image-20210609131843953](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210609131843953.png)

通常情况下，我们能想到的都是使用原子类或者锁来解决，但这样始终存在多个线程竞争同一个资源的情况，性能并不甚理想。

仔细理清下需求，每个线程只需要不断地进行 +1 操作，而读操作是很少的，那么可以考虑每个线程都维护一个变量，采取空间换时间的方式进行 +1 操作，从而实现无锁化。

再进一步，如果每个线程都维护一个变量，又会导致空间的浪费，**最好能按需创建，即懒加载**，并且尽可能的少创建对象。

Java 并发工具包中的 LongAdder 就是这么一个设计思想，一切都可以从 add() 方法出发：

```java
    public void add(long x) {
        Cell[] as; long b, v; int m; Cell a;
        if ((as = cells) != null || !casBase(b = base, b + x)) {
            boolean uncontended = true;
            if (as == null || (m = as.length - 1) < 0 ||
                (a = as[getProbe() & m]) == null ||
                !(uncontended = a.cas(v = a.value, v + x)))
                longAccumulate(x, null, uncontended);
        }
    }
```

LongAdder 初始情况下会维护一个 long 类型的 base 以及 Cell 类型数组，Cell 内部也维护了一个 long 类型的计数器。

当线程需要执行 +1 操作时，会需要通过 CAS 方式尝试快速修改 base：

- 如果修改成功，则直接返回
- 如果修改失败，则会尝试获取 Cell 数组中的某个元素（按线程中的 PROBE 进行寻址），按需初始化，初始大小为 2，并按照 2 的 n 次方扩容，并对其中的计数器进行 CAS 替换操作。

这样一来，不仅实现了按需创建的目的，同时也将多个线程的竞争分散到多个对象上，比起 Atomic 原子类来看更加高效。并且当竞争不激烈时，所需要做的仅仅是对一个计数器进行 CAS 替换操作。

LongAdder 也是一个经典的用空间换时间的设计，**按需懒加载**，**分摊线程竞争（无锁化、分段锁）**，在写多读少的场景下大大的提高了性能。

参考：

- [破玩意 | 多线程 +1 的最快操作](https://mp.weixin.qq.com/s/Hbz1k5bDhdfPSb05PAZNrw)

