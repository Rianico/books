---
title: 10. Scala 中的 try-with-resources
date: 2021-07-31
---

## Scala 中的 try-with-resources

### 基本使用

Scala 2.13 新增的 `scala.util.Using` 也可以起到 Java 中的 try-with-resources 作用，通常有以下 3 种用法：

1. 只需要管理一个 resource，Using 会使用一个 Try 封装执行结果：

   ```scala
     Using(new BufferedReader(new FileReader("file.txt"))) { reader =>
       Iterator.continually(reader.readLine()).takeWhile(_ != null).toSeq
     }
   ```

2. 需要管理多个 resource，则使用 `Using.Manager(…)` 方式：

   ```scala
   import java.io.{BufferedReader, FileReader}
   import scala.util.{Try, Using}
   
   val lines: Try[Seq[String]] = Using.Manager { use =>
     val r1 = use(new BufferedReader(new FileReader("file1.txt")))
     val r2 = use(new BufferedReader(new FileReader("file2.txt")))
     val r3 = use(new BufferedReader(new FileReader("file3.txt")))
     val r4 = use(new BufferedReader(new FileReader("file4.txt")))
   
     // use your resources here
     def lines(reader: BufferedReader): Iterator[String] =
       Iterator.continually(reader.readLine()).takeWhile(_ != null)
   
     (lines(r1) ++ lines(r2) ++ lines(r3) ++ lines(r4)).toList
   }
   ```

3. 如果不希望使用 Try 进行包装，则可以使用 `Using.resource(…)` 方式，此时一旦执行结果出现异常，则会直接抛出：

   ```
   import java.io.{BufferedReader, FileReader}
   import scala.util.Using
   
   val lines: Seq[String] =
     Using.resource(new BufferedReader(new FileReader("file.txt"))) { reader =>
       Iterator.continually(reader.readLine()).takeWhile(_ != null).toSeq
     }
   ```

> NOTE：需要注意，一旦使用了 Try 进行封装，记得对 Try 进行处理，否则会丢失异常

在 Java 的 try-with-resources 中，如果正常逻辑的代码运行出现异常，同时 `close()` 方法也出现异常，则会自动将其包装 `Suppressed Exceptions`，Scala 中的 Using 也是一样：

```scala
import scala.util.{Failure, Success, Using}

object UsingTest {

  def main(args: Array[String]): Unit = {
    Using(new ExceptionalResource()) { exp =>
      exp.processSomething()
    } match {
      case Success(value) => println("success")
      case Failure(exception) => exception.printStackTrace()
    }
  }

  class ExceptionalResource extends AutoCloseable {

    def processSomething(): Unit = {
      throw new IllegalArgumentException("Thrown from processSomething()")
    }

    override def close(): Unit = throw new NullPointerException("Thrown from close()");
  }

}

// 输出：
java.lang.IllegalArgumentException: Thrown from processSomething()
	at UsingTest$ExceptionalResource.processSomething(UsingTest.scala:17)
	at UsingTest$.$anonfun$main$2(UsingTest.scala:7)
	at UsingTest$.$anonfun$main$2$adapted(UsingTest.scala:6)
	at scala.util.Using$.$anonfun$apply$1(Using.scala:261)
	at scala.util.Using$.apply(Using.scala:113)
	at UsingTest$.main(UsingTest.scala:6)
	at UsingTest.main(UsingTest.scala)
	Suppressed: java.lang.NullPointerException: Thrown from close()
		at UsingTest$ExceptionalResource.close(UsingTest.scala:20)
		at scala.util.Using$Releasable$AutoCloseableIsReleasable$.release(Using.scala:391)
		at scala.util.Using$Releasable$AutoCloseableIsReleasable$.release(Using.scala:390)
		at scala.util.Using$.$anonfun$apply$1(Using.scala:269)
		... 3 more

Process finished with exit code 0

```

### 具体实现

Using 表面上要求传入的 resource 实现 Releasable 接口，但实质上要求实现的是 `java.lang.AutoCloseable` 接口，通过在 Releasable 中提供一个隐式操作执行关闭动作：

```scala
// Using 要求传入一个 Releasable 类型的 resource
def apply[R: Releasable, A](resource: => R)(f: R => A): Try[A] = Try {
    Using.resource(resource)(f)
}

// 传入一个隐式操作 releasable
def resource[R, A](resource: R)(body: R => A)(implicit releasable: Releasable[R]): A = {
	// ......
    try releasable.release(resource)
    // ......
}

object Releasable {

    // 隐式操作匹配到 AutoClosable 则会执行 close 方法
    implicit object AutoCloseableIsReleasable extends Releasable[AutoCloseable] {
        def release(resource: AutoCloseable): Unit = resource.close()
    }
}

```

