---
title: 偏函数（PartialFunction）、部分应用函数（Partial Applied Function）和柯里化\(Currying\)
date: 2020-05-26 17:06:05
---
# 偏函数（PartialFunction）、部分应用函数（Partial Applied Function）和柯里化\(Currying\)



## 偏函数

在scala中，可以利用模式匹配来扩展创建偏函数，偏函数是一种特殊的一元函数，**并不支持处理所输入参数的所有情况**。类型为PartialFunction\[-T,+V\]。`T是接收的类型，V是返回的结果类型`

如下，下列偏函数是求平方根，并且在input为负数的时候不做处理。

```scala
val squareRoot: PartialFunction[Double, Double] = {
  case x if x >= 0 => Math.sqrt(x)
}
```

可以使用isDefinedAt来确认该偏函数是否能够处理某个特定的值。

```scala
squareRoot.isDefinedAt(2) shouldEqual true
squareRoot.isDefinedAt(-2) shouldEqual false
```

偏函数之间彼此也可以使用**orElse** 或者 **andThen**相互连接。

```scala
val positive: PartialFunction[Int, Int] = {
  case x if x >= 0 => x
}

val odd: PartialFunction[Int, Boolean] = {
  case x if x % 2 == 1 => true
}

val even: PartialFunction[Int, Boolean] = {
  case x if x % 2 == 0 => true
}

val evenCheck: PartialFunction[Int, Boolean] = positive andThen even

val oddCheck: PartialFunction[Int, Boolean] = positive andThen odd
```

**compose**可以进行一次预处理。

```scala
// 只处理1
val parfun1:PartialFunction[Int,Int] = {case 1 => 1} 
parfun1(1)    // 1
parfun1.isDefinedAt(2)    // false

// 做一层预处理
val compfun:Function1[String,Int] = parfun1.compose{
    case x=>System.out.println("compose:" + x);Integer.valueOf(x)
}
compfun(1)
// compose:1
// 1
```

偏函数的这项特性，在实现一个验证系统的时候非常有用，我们可以实现一系列的检查去验证输入的数据是否符合要求。

```scala
val finalCheck = check1 andThen check2 andThen check3 ...
```

当新增或者移除的时候也十分方便。

Scala也可以将偏函数应用于collections，**collect**方法将一个偏函数作为输入参数，将这个偏函数作用于各个值上，跳过超出函数中定义的元素。

```scala
val greaterThan20: PartialFunction[Any, Int] = {
  case i: Int if i > 20 => i
}
List(1, 45, 10, "blah", true, 25) collect greaterThan20 
shouldEqual List(45, 25)
```

## 部分应用函数（Partially Applied Functions）

在函数式编程中，对一个有参数的函数的调用也可以看成**将函数应用到参数上**。

当一个函数带着所有参数被调用时，就叫做将函数完整（fully applied）的应用到每个参数上。当**只传递参数的子集到函数**也是可以通过的，将返回一个**部分应用函数（Partially Applied Functions）**。Scala中不会因为你只传递部分参数而抛出一个异常，而是简单的将其应用并返回一个新的带着剩余需要你传递的参数的函数。

```scala
val divide = (num: Double, den: Double) => {
  num / den
}
val halfOf: (Double) => Double = divide(_, 2)
halfOf 20 shouldEqual 10
```

我们在求某个值的一般的时候，可以知道分母必定为2，所以`halfOf`通过部分应用**除**的函数得到求半的功能。`_`占位符表示剩余的参数。

部分应用函数很容易跟Scala中的**柯里化（Currying）**混淆。两者都能减少函数中的参数数量，但是柯里化将部分应用函数的概念进行了更加深层次的扩展。

## 柯里化（**Currying**）

**柯里化是将一个带有多个参数的函数拆分为一系列函数，每个函数带有单独的参数**。

```scala
def curriedDivide(num: Double)(den: Double) = num / den
```

`curriedDivide`函数的类型为`(Double) => (Double) => (Double)`，表示将`divid`函数拆分为两个函数，每个函数各自带着一个参数，参数根据原本的顺讯决定。

```scala
val halfOf: (Double) => Double = curriedDivide(_)(2)

halfOf(20) shouldEqual 10
```

柯里化跟部分应用函数的好处是能够根据原本的通用函数，创建出一个特定的函数而不用创建新的代码，使得代码较为简洁，避免冗余。

