---
title: Scala 排序之 Ordered、Ordering
date: 2020-07-22 10:56:59
---
# Scala 排序之 Ordered、Ordering

### 1. 前言

Scala 中对一个集合进行排序，当集合中的类型为常见的基本类型（如 Int、Long等）时，我们往往可以直接调用 `sorted` 等 API 直接进行排序，但这些实际上都是通过隐式传入一个 Scala 中已经实现好的 `Ordering` 排序器完成的。因此当我们的集合是一个自定义类型的时候，就无法通过隐式传入 Scala 已经实现好的排序器进行排序，而需要自己手动实现一个。

本文主要介绍 Scala 中两种排序器：`Ordered`、`Ordering`。Ordered 和 Ordering 之间的区别大致可以看成 Java 中 `Comparable` 与 `Comparator` 的区别。

### 2. Ordered

查看 Ordered 接口：

```vim
 trait Ordered[A] extends Any with java.lang.Comparable[A] {...}
```

可以看出，Ordered 继承了 Comparable 接口，并补充了一些方法的定义。

Ordered 特质用于提供一个内部的排序，通常用法如下：

```vim
 object OrderedExample {
 ​
   case class Person(id: Int, name: String) extends Ordered[Person] {
     // Sort By Id(int)
     override def compare(that: Person): Int = this.id compareTo that.id
   }
 ​
   def main(args: Array[String]): Unit = {
     val array = Array(Person(1, "c"), Person(3, "a"), Person(2, "b"))
     array.sorted.foreach(println)
   }

 }
 ​
 // output:
 Person(1,c)
 Person(2,b)
 Person(3,a)
```

如上，定义个一个 class 并实现 Ordered 特质，从而自定义一个默认的内部排序器，就可以直接使用 `sorted` 使用默认的内部排序器。

### 3. Ordering

相比 Ordered，Ordering 则是实现了 `Comparator` 接口，定义了一个外部排序器，在集合进行排序的时候从外部传入：

```vim
 trait Ordering[T] extends Comparator[T] with PartialOrdering[T] with Serializable {...}
```

Ordering 使用的方式有很多，这里先介绍一个最常用的：

```vim
 object OrderingExample {
 ​
   case class Person(id: Int, name: String)
 ​
   object Person {
 ​
     implicit def orderById[A <: Person]: Ordering[A] = Ordering.by(_.id)
 ​
     val orderByName: Ordering[Person] = Ordering.by(_.name)
   }
 ​
   def main(args: Array[String]): Unit = {
     val array = Array(Person(1, "c"), Person(3, "a"), Person(2, "b"))
     println("Order By Id:")
     array.sorted.foreach(println)
     println("Order by Name:")
     array.sorted(Person.orderByName).foreach(println)   // 显式传入自定义排序器
   }
 ​
 }
 // output：
 Order By Id:
 Person(1,c)
 Person(2,b)
 Person(3,a)
 Order by Name:
 Person(3,a)
 Person(2,b)
 Person(1,c)
```

通常是定义一个普通的 class，为其新建一个伴生对象，然后隐式定义一个默认的排序器，之后就可以在伴生对象中根据不同的需求灵活定义各种排序器。对于额外定义的排序器，在调用时显式传递即可。

如果不想新建一个伴生对象，也可以排序前隐式创建一个排序器：

```vim
 object OrderingExample {
 ​
   case class Person(id: Int, name: String)
 ​
   def main(args: Array[String]): Unit = {
     implicit def orderById[A <: Person]: Ordering[A] = Ordering.by(_.id)
     val array = Array(Person(1, "c"), Person(3, "a"), Person(2, "b"))
     println("Order By Id:")
     array.sorted.foreach(println)
   }
 ​
 }
 // output:
 Order By Id:
 Person(1,c)
 Person(2,b)
 Person(3,a)
```

同时我们还可以使用 `Sorting` 工具类进行排序，主要是定义一个外部的 `function` 排序器，然后传递进去即可：

```vim
 object OrderingExample {
 ​
   case class Person(id: Int, name: String)
 ​
   def main(args: Array[String]): Unit = {
     val array = Array(Person(1, "c"), Person(3, "a"), Person(2, "b"))
     val fun = (cur: Person, next: Person) => cur.id < next.id
     println("Order By Id:")
     Sorting.stableSort(array, fun)
     array.foreach(println)
   }
 ​
 }
 // output:
 Order By Id:
 Person(1,c)
 Person(2,b)
 Person(3,a)
```

### 4. 总结

Ordered、Ordering 本质上是对 Comparable、Comparator 的扩展，根据不同场景选择不同的排序方式，可以减少一些代码。

