---
title: Scala 中的尾递归
date: 2020-05-26 17:06:05
---
# Scala 中的尾递归

## 1. 尾调用

若函数的最后一步为**纯粹**的函数调用，则称之为尾调用。

例如：

```scala
// 场景一
def f(x: Int): Int = {
    if (x == 0) return x
    return f(x - 1)
}

// 场景二
def f(x: Int): Int = {
    if (x == 0) return x
    return 1 * f(x -1)
}
```

以上两个场景中，只有场景一才是尾调用，**执行的最后一步操作为纯粹的函数调用**即可。

## 2. 尾调用优化

众所周知，在JVM生态语言中，一旦一个函数调用另一个函数，便会有一个叫做**压栈**的操作，每个栈帧还会保存对应的局部变量，引用等。

在递归操作中，一旦压栈的程度深了，需要保存的数据越来越多，那么就很容易造成**堆栈溢出**。

例如，计算前面场景二的代码时，以f\(5\)为例：

```scala
f(5)
if (5 == 0) 1 else 5 * f(5 - 1)
5 * f(4)
5 * (if (4 == 0) 1 else 4 * f(4 - 1))
5 * (4 * f(3))
...
5 * (4 * (3 * (2 * (1 * f(0)))))
5 * (4 * (3 * (2 * (1 * 1))))
```

可以看出，栈中需要保留的数据越来越多，呈线性增加。

若将代码换为场景一，由于是尾调用，**返回的函数结果会被当做当前函数的结果**，因此可以不必保留当前函数的相关栈数据，仅保留被调用函数的栈即可，使得需要使用的栈空间可以保持在**常数级**。

## 3. 尾递归

**若尾调用的函数为自身**，则称之为尾递归。函数式编程提倡多使用递归解决问题，但是递归更加消耗内存，容易造成堆栈溢出的问题，因此通常需要使用尾递归来进行优化。

> 已经证明，所有递归函数都可以被改写为迭代方式，且尾递归可以按照固定步骤改写为迭代，所以很多编程语言会自动执行尾递归优化，如Scala中就会使用@tailrec来标记尾递归优化。

再举一个阶乘的例子，我们经常能够看到有以下实现：

```scala
def factorial(n: Int): Int = if (n == 0) 1 else n * fact(n - 1)
```

上面的例子是一个非常符合直觉的例子，但仔细分析的话没有使用到尾递归优化，一旦n稍微大点，如`factorial(100000)`左右的时候往往会堆栈溢出。

我们可以将其修改为尾递归方式，优化其效率：

```scala
def factorial(n: Int, res: Int): Int = if (n == 0) res else factorial(n - 1, n * res)

factorial(5, 1)    // 输出：120
```

优化后的尾递归只占用常数级的栈空间，但是这样的函数调用未免令人觉得奇怪，因此我们可以使用默认值或者柯里化（建议柯里化，并将尾递归的阶乘设为`private`，避免错误调用），将其改写：

```scala
// 默认值
def factorial(n: Int, res: Int = 1): Int = if (n == 0) res else factorial(n - 1, n * res)

// 柯里化，只向外暴露已经包装好的函数
private def factorial(n: Int)(res: Int): Int = if (n == 0) res else factorial(n - 1)(n * res)
def _factorial: (Int) => Int = factorial(_)(1)
```

## 4. 思考

关于是否使用递归，有非常多的争议，这里参考下关于Databricks 根据自己开发维护 Spark的经验给出的观点：

> 避免使用递归，除非问题可以非常自然地用递归描述（如树、图的遍历）。

并且建议为每个尾递归函数添加 @tailrec 注解，因为闭包、函数变换的使用，许多看似尾递归的函数实际上并非是尾递归，使用`@tailrec`强制编译器检查函数是否是尾递归是个好习惯。

Databricks对于不推荐使用递归给出的理由是：大多数代码使用迭代（循环）和状态机更容易推理，而递归反而难以理解。并举出了以下例子：

```scala
// 尾递归
def max(data: Array[Int]): Int = {
  @tailrec
  def max0(data: Array[Int], pos: Int, max: Int): Int =
    if (pos == data.length) max
    else max0(data, pos + 1, if (data(pos) > max) data(pos) else max)

  max0(data, 0, Int.MinValue)
}

// 迭代
def max(data: Array[Int]): Int = {
  var max = Int.MinValue
  for (v <- data) {
    if (v > max) max = v
  }
  max
}
```

当然，代码的世界里是没有银弹的，还是要根据具体场景选择迭代或者递归，使得代码更易于维护。

## 5. Reference

* [为什么需要尾递归？](http://songkun.me/2018/05/16/2018-05-16-tail-recursion/)
* [尾调用优化](https://www.ruanyifeng.com/blog/2015/04/tail-call.html)

