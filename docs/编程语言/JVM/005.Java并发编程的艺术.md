[TOC]



# 1. Java 内存模型

线程之间的通信有两种方式：消息传递以及内存共享。 Java 内存模型采用的是共享内存方式。

## 1.1 volatile语义

**从 JSR-133 开始（即从 JDK5 开始），volatile 变量的 写-读 可以实现线程之间的通信**。

从内存语义的角度来说，volatile的**写-读**与锁的**释放-获取**有相同的内存语义：

- volatile 写语义：JMM 会把该线程对应的本地内存中的共享变量值刷新到主内存，volatile 写和锁的释放有相同的内存语义。
- volatile 读语义：JMM 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。volatile 读与锁的获取有相同的内存语义。

借由上述两个内存语义，可以得到 volatile 的两个特性：

- 可见性：对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入。
- 原子性：对**任意单个 volatile 变量**的**读/写**具有原子性，但类似于 volatile++ 这种**复合操作**不具有原子性。

volatile 重排序规则：

- 当第二个操作是 volatile 写时，不管第一个操作是什么，都不能重排序。这个规则确保 volatile 写之前的操作不会被编译器重排序到 volatile 写之后。
- 当第一个操作是 volatile 读时，不管第二个操作是什么，都不能重排序。这个规则确保 volatile 读之后的操作不会被编译器重排序到 volatile 读之前。
- 当第一个操作是 volatile 写，第二个操作是 volatile 读时，不能重排序。

为了实现 volatile 语义，编译器是通过插入内存屏障禁止特性类型的处理器重排序实现的，但是找出一个最优布置来最小化插入屏障的总数几乎不可能。为此，JMM 采取保守策略，遵守先保证正确性，再追求性能的原则生成内存屏障：

- 在每个 volatile 写操作的前面插入一个 StoreStore 屏障。
- 在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。
- 在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。
- 在每个 volatile 读操作的后面插入一个 LoadStore 屏障。

**JSR-133 为什么要增强 volatile 的内存语义？**

旧的内存模型中，虽然不允许 volatile 变量之间进行重排序，但是**在两者没有依赖的情况下，允许普通变量跟 volatile 进行重排序**，导致线程之间的通信结果并不可靠，因此并不具备锁的内存语义，有时候会因为重排序导致不可预测的错误。

为了提供一种比锁更加轻量级的线程之间的通信机制，新的内存模型 JSR-133 增强了 volatile 的语义。

## 1.2 锁的内存语义

锁可以让临界区互斥执行，但也有一个很重要的功能：**锁的内存语义**。

锁的内存语义能让一个线程向获取**同一个锁**的线程发送消息，即**当一个线程获取到某个锁的时候，上一个刚释放这个锁的线程（若有）的共享变量都对其可见**。

**为什么能获取上一个线程的共享变量？**

- 释放锁时，JMM 会将该线程的共享变量刷新到主内存中。

- 获得锁时，JMM 会将该线程对应的本地内存置为无效，再去到主内存中读取共享变量。

从这里可以看出，锁与 volatile 的内存语义是相同的。

这里以 ReentrantLock 的公平锁以及非公平锁进行展开：

![image](https://raw.githubusercontent.com/Rianico/Image/master/Netty/Snipaste_2020-03-16_23-25-33.png)

### 1.2.1 公平锁

公平锁是利用 `volatile` 的特性来实现锁的语义的，此处要重点关注 volatile 的 `state` 变量。

首先是获取锁的轨迹：`ReentrantLock:lock() -> FairSync:lock() -> AbstractQueuedSynchronizer:acquire(int arg) -> ReentrantLock:tryAcquire(int acquires)`，真正加锁是在最后一步，代码如下：

```java
protected final boolean tryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        if (!hasQueuedPredecessors() &&
            compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0)
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
```

从上面的代码可以看到，公平锁加锁方法先是 **读取** 了 state 变量。

接下来看下公平锁释放锁的代码 `ReentrantLock:unlock() -> AbstractQueuedSynchronizer:release(int arg) -> Sync:tryRelease(int releases)` ：

```java
protected final boolean tryRelease(int releases) {
    int c = getState() - releases;
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) {
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}
```

在释放锁的最后，**写** volatile 变量 state。

公平锁在释放锁的时候 **写** volatile 变量，在获取锁时 **读** volatile 变量，由于 volatile 的禁止重排序规则，新读取 volatile 变量（新获取锁）的线程能够立刻看到上个线程在写 volatile 变量之前所有可见的共享变量。

> Note：借助 volatile 写-读 的锁语义，以及 if/else 作为边界条件，使得代码块同一时间只有单个线程执行

### 1.2.2 非公平锁

非公平锁的释放与公平锁的释放完全一致，因此这里只需要看非公平锁的加锁方式：`ReentrantLock:lock() -> NonfairSync:lock() -> AbstractQueuedSynchronizer:compareAndSetState(int expect,int update)` 

```java
final void lock() {
    if (compareAndSetState(0, 1))
        setExclusiveOwnerThread(Thread.currentThread());
    else
        acquire(1);
}
```

可以看到，非公平锁直接以 CAS 方式更新 volatile 变量 state。

ReentrantLock 获取锁（非公平）使用了 CAS ，**CAS 同时具有 volatile读-volatile写 的内存语义**。volatile读  禁止对 volatile读 及后面的操作进行重排序， volatile写 禁止对 volatile写 及前面的操作进行重排序。这里也就意味着， 编译器不能对 CAS 以及 CAS 前后面的操作进行重排序。

这里从编译器以及处理器的角度分析 CAS，CAS 调用的是一个本地代码，在多处理器下会在 `cmpxchg` 指令加上 lock 前缀，intel 的手册对 lock 前缀的说明如下：

1. 确保**内存的 读-改-写 操作原子执行**，通过锁总线（开销较大）或者锁缓存（开销较小）的方式来保证。
2. **禁止该指令与之前和之后的读和写指令重排序**。
3. **把写缓冲区中的所有数据刷新到内存中**。

其中第 2 点禁止了处理器重排序，2、3点具有内存屏障效果，也就具有了 **volatile读-volatile写** 的内存语义。

### 1.2.3 总结

- 公平锁和非公平锁释放时，最后都要写一个 volatile 变量 state。
- 公平锁获取时，首先会去读 volatile 变量。
- 非公平获取时，首先会用 CAS 更新 volatile 变量，这个操作同时具有 **volatile读-volatile写** 的内存语义。

## 1.3 concurrent包的实现

从前面可知，锁的内存语义至少可以从以下两个方面实现：

1. volatile变量的 **写-读** 所具有的内存语义。
2. CAS所附带的 **volatile 读和 volatile 写**的内存语义。

因此又可以衍生出以下四种方式实现线程间的通信 （均是 **写-读/CAS** 方式）：
1）A线程写 volatile 变量，随后B线程读这个 volatile 变量。
2）A线程写 volatile 变量，随后B线程用 CAS 更新这个 volatile 变量。
3）A线程用 CAS 更新一个 volatile 变量，随后B线程用 CAS 更新这个 volatile 变量。
4）A线程用 CAS 更新一个 volatile 变量，随后B线程读这个 volatile 变量。


concurrent 包正是借助这几个特性形成的，并且有一个通用的实现模式：

1. 声明共享变量为 volatile；
2. 使用 CAS 的原子条件更新来实现线程间的同步；
3. 同时，配合以 volatile 的写/读和 CAS 所具有的 volatile读-volatile写 的内存语义来实现线程之间的通信。

AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic 包中的类），这些 concurrent 包中的基础类都是使用这种模式来实现的，而 concurrent 包中的高层类又是依赖于这些基础类来实现的。

![AQS 架构图](https://raw.githubusercontent.com/Rianico/Image/master/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/Snipaste_2020-03-29_11-34-59.png)

## 1.4 final域的内存语义

对于final域，编译器和处理器要遵守两个重排序规则。
1）在构造函数内对一个 final 域的写入，与随后把这个被构造对象的引用赋值给一个引用
变量，这两个操作之间不能重排序。
2）初次读一个包含 final 域的对象的引用，与随后初次读这个 final 域，这两个操作之间不能
重排序。

### 1.4.1 写final域

写final域的重排序规则禁止把final域的写重排序到构造函数之外。这个规则的实现包含
下面2个方面。
1）JMM 禁止编译器把 final 域的写重排序到构造函数之外。
2）编译器会在 final 域的写之后，构造函数 return 之前，插入一个 StoreStore 屏障。这个屏障
禁止处理器把 final 域的写重排序到构造函数之外。

### 1.4.2 读final域

在一个线程中，初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读final域操作的前面插入一个LoadLoad屏障。

写final域的重排序规则可以确保：在引用变量为任意线程可见之前，该引用变量指向的对象的final域已经在构造函数中被正确初始化过了。其实，要得到这个效果，还需要一个保证：**在构造函数内部，不能让这个被构造对象的引用为其他线程所见**，也就是对象引用不能在构造函数中“逸出”。

```java
public class FinalReferenceEscapeExample {
	final int i;
	static FinalReferenceEscapeExample obj;
	public FinalReferenceEscapeExample () {
		i = 1; // 1写final域
		obj = this; // 2 this引用在此"逸出"
	}
	public static void writer() {
		new FinalReferenceEscapeExample ();
	}
	public static void reader() {
		if (obj != null) { // 3
			int temp = obj.i; // 4
		}
	}
}
```

由于在构造函数中， obj 指向了 this，此时 obj 能够提前被其他线程所见，从而导致 final 变量“逸出”，其他线程可能会在 final 变量初始化完成之前就访问了构造函数内部信息，从而无法保证 final 内存语义。

在旧的Java内存模型中，一个最严重的缺陷就是线程可能看到final域的值会改变。比如，一个线程当前看到一个整型final域的值为0（还未初始化之前的默认值），过一段时间之后这个线程再去读这个final域的值时，却发现值变为1（被某个线程初始化之后的值）。最常见的例子就是在旧的Java内存模型中，String的值可能会改变。

因此，在JSR-133中增强了final的语义：只要对象是正确构造的（被构造对象的引用在构造函数中没有“逸出”），那么不需要使用同步（指lock和volatile的使用）就可以保证任意线程都能看到这个final域在构造函数中被初始化之后的值。

## 1.5 处理器的内存模型

顺序一致性内存模型是一个理论参考模型，JMM和处理器内存模型在设计时通常会以顺序一致性内存模型为参照。在设计时，JMM和处理器内存模型会对顺序一致性模型做一些放松，因为如果完全按照顺序一致性模型来实现处理器和JMM，那么很多的处理器和编译器优化都要被禁止，这对执行性能将会有很大的影响。

JMM屏蔽了不同处理器内存模型的差异，它在不同的处理器平台之上为Java程序员呈现了一个一致的内存模型。	

happens-before：

1）如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作
可见，而且第一个操作的执行顺序排在第二个操作之前。
2）两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照
happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系
来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）。

happens-before 规则不仅适用于单线程，同时也适用于多线程。

## 1.6 双重锁检查锁定与延迟加载

在单例模式中，为了能够线程安全的实例化一个对象，通常采用基于volatile + synchronized方案，或者借助类初始化的机制来解决这个问题。

### 1.6.1 volatile + synchronized

```java
public class SafeDoubleCheckedLocking {
	private volatile static Instance instance;
	public static Instance getInstance() {
		if (instance == null) {
			synchronized (SafeDoubleCheckedLocking.class) {
				if (instance == null)
					instance = new Instance(); // instance为volatile，现在没问题了
			}
		}
		return instance;
	}
}
```

将所需实例化的对象设置为 volatile 方式，禁止编译器在其实例化的时候重排序，以免在实例化过程中，因为重排序从而导致其他线程在第一个 `instance == null` 处误判，从而在同步代码块内对象还没实例化完成的时候错误的返回 `instance`。

### 1.6.2 基于类初始化的解决方案

这个方案是借助 JVM 在类的初始化阶段（即在 **Class 加载之后， 被线程使用之前**）的线程安全特性来实现的。

```java
public class InstanceFactory {
	private static class InstanceHolder {
		public static Instance instance = new Instance();
	}
	public static Instance getInstance() {
		return InstanceHolder.instance ;　　// 这里将导致InstanceHolder类被初始化
	}
}
```

我们假设有 A、B 两个线程同时去初始化一个类，Class 初始状态为 `noIntitialization` ：

| 时间 |                            线程A                             |                            线程B                             |
| :--: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|  t1  |       A 尝试获取 Calss对象的初始化锁，假设 A 获取成功        | B 尝试获取 Class 对象的初始化锁，由于 A 成功获取到了， B 将一直等待获取初始化锁 |
|  t2  |    A 看到线程还未被初始化，于是设置 state = Intitializing    |                                                              |
|  t3  |                        A 释放初始化锁                        |                                                              |
|  t4  | A 执行类的静态初始化和初始化类中声明的静态字段（此处允许重排序，因为此时这里的初始化对其他线程不可见） |                       B 获取到初始化锁                       |
|  t5  |                                                              |              B 读取到 Class 状态为 Intializing               |
|  t6  |                                                              | B 释放初始化锁，继续在 condition（state = Intializing） 上等待 |
|  t7  |          A 初始化完成后，获取 Class 对象的初始化锁           |                                                              |
|  t8  |                   设置 state = Intialized                    |                                                              |
|  t9  |              唤醒在 condition 上等待的所有线程               |                                                              |
| t10  |              释放初始化锁，A 的类初始化处理完成              |                         获取初始化锁                         |
| t11  |                                                              |                  读取到 state = Intialized                   |
| t12  |                                                              |              释放初始化锁，B 的类初始化处理完成              |

此处的 condition 和 state 并不是 Java 语言硬性规定的， JVM 只要实现类似功能即可。

### 1.6.3 总结

字段延迟初始化降低了初始化类或创建实例的开销，但增加了访问被延迟初始化的字段的开销。

虽然基于类初始化的代码更加简洁，但是双重检查锁的方案除了可以对静态字段实现延迟初始化之外，还可以对实例字段进行延迟初始化。

在大多数时候，**正常的初始化要优于延迟初始化**。如果确实需要对实例字段使用线程安全的延迟初始化，请使用基于volatile的延迟初始化的方案；如果确实需要对静态字段使用线程安全的延迟初始化，请使用上面介绍的基于类初始化的方案。

# 2. Java 并发编程基础

- **什么是程序？**

程序可以理解存储器上存放的一组**静态的有序指令集合**。

- **什么是进程？**

操作系统在运行一个程序时，会为其启动一个进程，**动态**的执行指令。

- **什么是线程？**

操作系统的最小调度单元是线程，一个进程中可以创建多个线程，每个线程都有自己的计数器（PC）、堆栈和局部变量等属性，并且能够访问共享的内存变量。（此处暂不考虑协程）

- **使用多线程的理由？**

1. **多核心**，现代操作系统通常拥有多个核心，一个线程同一时间只能运行在一个处理器核心上，因此单线程无法充分发挥多核的性能优势。
2. **更快的响应时间**，对于一个工作流，如果中间有些部分数据一致性要求不高，那么可以将其中部分环节交给其他线程去做，例如生成订单快照，发送邮件等。
3. **更好的编程模型**， Java 为多线程提供了良好、考究且一致的编程模型，尽可能地使开发人员能够更加专注于问题的解决。

## 2.1 线程的状态

![Java线程的状态](https://raw.githubusercontent.com/Rianico/Image/master/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/Snipaste_2020-03-29_13-43-55.png)

Java 程序中线程的状态是不断切换的，状态变化如下：

![image](https://raw.githubusercontent.com/Rianico/Image/master/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/Snipaste_2020-03-29_13-45-36.png)

需要注意的是，虽然在等待进入 synchronized 方法/块 是 BLOCKED 状态，但在 java.concurrent 包中 Lock 接口的线程状态却是等待状态，因为 java.concurrent 包中 Lock 接口对于阻塞的实现均使用了 LockSupport 类中的相关方法。 

## 2.2 Daemon线程

Daemon 是一种支持型线程，主要用于程序中**后台调度及支持性工作**。这也就意味着，当 JVM 中不存在 非Daemon线程 的时候，JVM 便会退出。

Daemon 线程通过调用 `Thread.setDaemon(true)` 将线程设置为 Daemon线程。

```java
public class Daemon {
	public static void main(String[] args) {
		Thread thread = new Thread(new DaemonRunner(), "DaemonRunner");
		thread.setDaemon(true);
		thread.start();
	}
	static class DaemonRunner implements Runnable {
		@Override
		public void run() {
			try {
				SleepUtils.second(10);
			} finally {
				System.out.println("DaemonThread finally run.");
			}
		}
	}
}
```

运行该程序，可以看到没有任何输出， main 线程在启动了 DaemonRunner 线程后立刻退出，此时 JVM 中没有任何 非Daemon线程 ， JVM 直接退出，自然也就看不到 Daemon线程 的输出了。

> NOTE：从 Daemon线程 的特性可以知道，**不能依靠 Daemon线程 来确保清理或者关闭资源的逻辑**。

## 2.3 理解中断

中断可以理解为线程的一个标识位属性，它表示一个运行中的线程是否被其他线程进行了中断操作。

线程通过方法 `isInterrupted()` 来进行判断是否被中断，也可以调用静态方法`Thread.interrupted()`对当前线程的中断标识位进行复位。

> NOTE：如果一个线程已处于 `Terminated` 状态，即使该线程被中断过，再调用该线程的 `isInterrupted()` 时依旧会返回 false，这是因为许多声明抛出 `InterruptedException` 的方法（例如Thread.sleep(long millis)) 在抛出该异常之前，JVM 都会先将该线程的中断表示位清除，所以之后调用 `isInterrupted()` 都会返回 false 。

interrupt 并不能真正的中断线程，它仅仅是修改了线程的标识位属性，具体行为还需要线程自身来配合，当调用 interrupt时，有以下两种场景：

① 正常运行的任务，经常检查本线程的中断标志位，如果被设置了中断标志就自行停止线程。
② 在调用阻塞方法（例如处于sleep, wait, join 等状态）时正确处理 InterruptedException 异常。（例如，catch异常后就结束线程）

## 2.4 过期的suspend()、resume() 和 stop()

线程的暂停、恢复和停止有一套过时的 API： suspend()、resume() 和 stop()。

- suspend()：在调用后，线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样容易引发死锁问题。
- stop()：在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。

由于以上因素，这些方法不被建议使用，而暂停、恢复操作可以通过经典的 **等待/通知** 机制来代替。

## 2.5 安全地终止线程

除了通过中断来取消取消或者停止任务外，还可以利用一个 boolean 变量来控制是否需要取消/停止线程。

```java
public class Shutdown {
	public static void main(String[] args) throws Exception {
		Runner one = new Runner();
		Thread countThread = new Thread(one, "CountThread");
		countThread.start();
		// 睡眠1秒，main线程对CountThread进行中断，使CountThread能够感知中断而结束
		TimeUnit.SECONDS.sleep(1);
		countThread.interrupt();
		Runner two = new Runner();
		countThread = new Thread(two, "CountThread");
		countThread.start();
		// 睡眠1秒，main线程对Runner two进行取消，使CountThread能够感知on为false而结束
		TimeUnit.SECONDS.sleep(1);
		two.cancel();
	}
	private static class Runner implements Runnable {
		private long i;
		private volatile boolean on = true;
		@Override
		public void run() {
			while (on && !Thread.currentThread().isInterrupted()){
				i++;
			}
			System.out.println("Count i = " + i);
		}
		public void cancel() {
			on = false;
		}
	}
}
// output：
Count i = 543487324
Count i = 540898082
```

在上面的代码中，main 线程通过中断操作和 `cancel()` 方法均可使 `CountThread` 得以终止。

这种通过标识位或者中断操作的方式能够使线程在终止时，有机会去清理资源，而不是直接终止线程。

## 2.6 线程间通信

根据 volatile 和 synchronized 的内存语义，可以实现线程间的通讯。

volatile 用于修饰变量，告知程序在访问该变量的时候需要先到共享能存中获取，对其他做出的改变必须同步刷新到共享内存。

synchronized 可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性：

![image](https://raw.githubusercontent.com/Rianico/Image/master/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/Snipaste_2020-03-29_14-58-51.png)

从上图可以看出，任意线程对 Object（Object 由 synchronized 保护）的访问，首先要获得Object的监视器。如果获取失败，线程进入同步队列，线程状态变为BLOCKED。当访问 Object 的前驱（获得了锁的线程）释放了锁，则该释放操作唤醒阻塞在同步队列中的线程，使其重新尝试对监视器的获取。

每个对象都拥有自己的一个 `monitor`，**synchronized 本质上就是对 monitor 的获取，这个获取过程是排他的，同一时间只能有一个线程获取到由 synchronized 所保护的对象**。

### 2.6.1 等待/通知机制

一个线程 A 修改了一个对象的值，而另一个线程 B 感知到了变化，然后进行相应的操作。这种模式类似于 生产者-消费者 模式，在功能层面实现了解耦，在体系结构上具备了良好的伸缩性，如果用 Java 语言实现可能如下：

```java
while (value != desire) {
	Thread.sleep(1000);
}
doSomething()
```

这种模式下， 第二个线程 B 不断地去轮询这个值的变化，从而能够做出相应的操作，但是这种方式有以下两个问题：

1. 难以确保及时性。在睡眠时，基本不消耗处理器资源，但也无法保证及时性。
2. 难以降低开销。如果降低睡眠的时间，又会消耗更多的处理器资源。

Java 中的等待/通知机制可以很好的解决这两个问题。等待/通知的相关方法是任意Java对象都具备的，因为这些方法被定义在所有对象的超类 `java.lang.Object` 上：

![image](https://raw.githubusercontent.com/Rianico/Image/master/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/Snipaste_2020-04-04_11-31-03.png)

等待/通知机制，是指一个线程 A 调用了一个 Object 的 `wait()` 方法进入等待状态，而另一个线程 B 调用了对象 Object 的 `notify()` 或 `notifyAll()` 方法，线程 A 收到通知后从对象 Object 的 wait() 方法中返回，进而执行后续的操作。

上述两个线程通过对象 Object 来完成交互，`wait()` 、 `notify/notifyAll()` 就如同开关信号一样，用来完成等待方和通知方之间的交互工作。

```java
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.TimeUnit;

public class WaitNotify {

    static boolean flag = true;
    static byte[] lock = new byte[0];

    public static void main(String[] args) throws Exception {
        Thread waitThread = new Thread(new Wait(), "WaitThread");
        waitThread.start();
        TimeUnit.SECONDS.sleep(1);
        Thread notifyThread = new Thread(new Notify(), "NotifyThread");
        notifyThread.start();
    }

    static class Wait implements Runnable {
        public void run() {
            // 加锁，拥有lock的Monitor
            synchronized (lock) {
                // 当条件不满足时，继续wait，同时释放了lock的锁
                while (flag) {
                    try {
                        System.out.println(Thread.currentThread() + " flag is true. wait @ " + new SimpleDateFormat("HH:mm:ss").format(new Date()));
                        lock.wait();
                    } catch (InterruptedException e) {
                    }
                }
                // 条件满足时，完成工作
                System.out.println(Thread.currentThread() + " flag is false. running @ " + new SimpleDateFormat("HH:mm:ss").format(new Date()));
            }
        }
    }

    static class Notify implements Runnable {
        public void run() {
            // 加锁，拥有lock的Monitor
            synchronized (lock) {
                // 获取lock的锁，然后进行通知，通知时不会释放lock的锁，
                // 直到当前线程释放了lock后，WaitThread才能从wait方法中返回
                System.out.println(Thread.currentThread() + " hold lock. notify @ " + new SimpleDateFormat("HH:mm:ss").format(new Date()));
                lock.notifyAll();
                flag = false;
                try {
                    TimeUnit.SECONDS.sleep(5);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            // 再次加锁
            synchronized (lock) {
                System.out.println(Thread.currentThread() + " hold lock again. sleep @ " + new SimpleDateFormat("HH:mm:ss").format(new Date()));
                try {
                    TimeUnit.SECONDS.sleep(5);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

// output: 第三、四行顺序可能对调
Thread[WaitThread,5,main] flag is true. wait @ 11:43:01
Thread[NotifyThread,5,main] hold lock. notify @ 11:43:02
Thread[NotifyThread,5,main] hold lock again. sleep @ 11:43:07
Thread[WaitThread,5,main] flag is false. running @ 11:43:12
```

使用 等待/通知 时需要注意的几个细节：

1. 使用 `wait()`、`notify()` 和 `notifyAll()` 时需要**先对调用对象加锁**。
2. 调用wait()方法后，线程状态由RUNNING变为WAITING，并将当前线程放置到对象的等待队列。
3. `notify()` 或 `notifyAll()` 方法调用后，等待线程依旧不会从 `wait()` 返回，需要调用 `notify()` 或`notifAll()` 的线程释放锁之后，等待线程才有机会从 `wait()` 返回。

4. 从 `wait()` 方法返回的**前提是获得了调用对象的锁**。

从上面的步骤可以看出， 等待/通知 机制依赖于 `synchronized` 同步机制，其目的是**为了确保等待线程从 waiting 状态恢复后能看到前一个线程对变量做出的修改**，因此 condition 变量无需设置为 volatile 类型。

流程图如下：

![image](https://raw.githubusercontent.com/Rianico/Image/master/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/Snipaste_2020-04-04_11-49-33.png)



等待/通知 可以抽象为两步，分别是针对 等待方（消费者） 和 通知方（生产者）。

等待方：

```java
synchronized(对象) {
	while(条件不满足) {
		对象.wait();
	}
	对应的处理逻辑
}
```

通知方：

```java
synchronized(对象) {
	改变条件
	对象.notifyAll();
}
```

> NOTE：针对昂贵资源的获取（e.g. 数据库连接），都应该添加超时限制（`Object.wait(timeout`)，如果超时，则返回并告知客户端出现的问题。

### 2.6.2 管道输入/输出流

线程之间的通讯还可以使用管道，这里的管道和普通的文件输入/输出或者网络输入/输出不一样，它主要用于线程之间得数据传输，传输的媒介为内存。

管道输入/输出流主要包括了如下4种具体实现：`PipedOutputStream`、`PipedInputStream`、`PipedReader` 和 `PipedWriter`，前两种面向字节，而后两种面向字符。

```java
public class Piped {
	public static void main(String[] args) throws Exception {
        PipedWriter out = new PipedWriter();
        PipedReader in = new PipedReader();
        // 将输出流和输入流进行 connect ，否则在使用时会抛出IOException
        out.connect(in);
        Thread printThread = new Thread(new Print(in), "PrintThread");
        printThread.start();
        int receive = 0;
        try {
            while ((receive = System.in.read()) != -1) {
                out.write(receive);
            }
        } finally {
            out.close();
        }
    }

    static class Print implements Runnable {
        private PipedReader in;

        public Print(PipedReader in) {
            this.in = in;
        }

        public void run() {
            int receive = 0;
            try {
                while ((receive = in.read()) != -1) {
                    System.out.print((char) receive);
                }
            } catch (IOException ex) {

            }
        }
    }
}
```

### 2.6.3 Thread.join()的使用

一个线程A执行了 `thread.join()` 语句，那么其含义是：线程 A 等待 thread 线程终止之后才从 `thread.join()` 中返回。

以下代码从 main 线程出发，创建了 0~9 号线程，每个线程都得等到前一个线程执行完成：

```java
public class Join {
    public static void main(String[] args) throws Exception {
        Thread previous = Thread.currentThread();
        for (int i = 0; i < 10; i++) {
            // 每个线程拥有前一个线程的引用，需要等待前一个线程终止，才能从等待中返回
            Thread thread = new Thread(new Domino(previous), String.valueOf(i));
            thread.start();
            previous = thread;
        }
        TimeUnit.SECONDS.sleep(5);
        System.out.println(Thread.currentThread().getName() + " terminate.");
    }
    static class Domino implements Runnable {
        private Thread thread;
        public Domino(Thread thread) {
            this.thread = thread;
        }
        public void run() {
            try {
                thread.join();
            } catch (InterruptedException e) {
                
            }
            System.out.println(Thread.currentThread().getName() + " terminate.");
        }
    }
}

// output：
main terminate.
0 terminate.
1 terminate.
2 terminate.
3 terminate.
4 terminate.
5 terminate.
6 terminate.
7 terminate.
8 terminate.
9 terminate.
```

查看 `join()` 源码，核心部分如下：

```java
// 加锁当前线程对象
public final synchronized void join() throws InterruptedException {
    // 条件不满足，继续等待
    while (isAlive()) {
        wait(0);
    }
    // 条件符合，方法返回
}
```

可以看出，实际上逻辑结构与 等待/通知 范式一样，都是加锁、循环、处理逻辑三个步骤。

### 2.6.4 ThreadLocal

`ThreadLocal`，即线程变量，是一个以 `ThreadLocal` 对象为键、任意对象为值的存储结构。

这个结构被附带在线程上，每个线程都有一个 `ThreadLocalMap` 的数据结构对象，key 值为 `ThreadLocal`， 也就是说一个线程可以根据一个 `ThreadLocal` 对象查询到绑定在这个线程上的一个值。

```java
public class Profiler {
    // 第一次get()方法调用时会进行初始化（如果set方法没有调用），每个线程会调用一次
    private static final ThreadLocal < Long > TIME_THREADLOCAL = new ThreadLocal < Long > () {
        protected Long initialValue() {
            return System.currentTimeMillis();
        }
    };
    public static final void begin() {
        TIME_THREADLOCAL.set(System.currentTimeMillis());
    }
    public static final long end() {
        return System.currentTimeMillis() - TIME_THREADLOCAL.get();
    }
    public static void main(String[] args) throws Exception {
        Profiler.begin();
        TimeUnit.SECONDS.sleep(1);
        System.out.println("Cost: " + Profiler.end() + " mills");
    }
}

//output:
Cost: 1001 mills
```

Profiler 可以被复用在方法调用耗时统计的功能上，在方法的入口前执行 begin() 方法，在方法调用后执行 end() 方法。

好处是两个方法的调用**不用在一个方法或者类中**，比如在 AOP（面向方面编程）中，可以在方法调用前的切入点执行 begin() 方法，而在方法调用后的切入点执行 end() 方法，这样依旧可以获得方法的执行耗时。

### 2.6.5 线程池的实现

线程池是一种基于池化思想管理线程的工具，主要有以下几个好处：

1. **降低资源消耗**：线程是一种稀缺资源，如果无限制的创建和销毁，最终将会耗尽系统资源，通过池化技术重复利用已创建的线程可以降低线程创建和销毁的损耗。
2. **提高响应速度**：任务到达时，无需等待创建线程。
3. **提高线程的可管理性**：使用线程池可以进行统一的分配、调优和监控，同时可以抑制任务激增导致系统线程数暴涨，从而达到平缓降级的可控性。
4. **提供更多更强大的功能**：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。

首先定义一个连接池接口：

```java
public interface ThreadPool < Job extends Runnable > {
    // 执行一个Job，这个Job需要实现Runnable
    void execute(Job job);
    // 关闭线程池
    void shutdown();
    // 增加工作者线程
    void addWorkers(int num);
    // 减少工作者线程
    void removeWorker(int num);
    // 得到正在等待执行的任务数量
    int getJobSize();
}
```

一个线程池接口往往应该有以下几个功能：

1. `execute(Job)`：提交任务的方法。
2. `addWorkers/removeWorker` ：减少工作者线程的方法，这里的工作者线程用于执行任务逻辑。
3. `getJobSize()` ：获取等待中任务的数量。
4. `shutdow()`：停止工作者线程，通常可以采用标识位的方式。

```java
public class DefaultThreadPool < Job extends Runnable > implements ThreadPool < Job > {
    // 线程池最大限制数
    private static final int MAX_WORKER_NUMBERS = 10;
    // 线程池默认的数量
    private static final int DEFAULT_WORKER_NUMBERS = 5;
    // 线程池最小的数量
    private static final int MIN_WORKER_NUMBERS = 1;
    // 这是一个工作列表，将会向里面插入工作
    private final LinkedList < Job > jobs = new LinkedList < Job > ();
    // 工作者列表
    private final List < Worker > workers = Collections.synchronizedList(new ArrayList < Worker > ());
    // 工作者线程的数量
    private int workerNum = DEFAULT_WORKER_NUMBERS;
    // 线程编号生成
    private AtomicLong threadNum = new AtomicLong();
    public DefaultThreadPool() {
        initializeWokers(DEFAULT_WORKER_NUMBERS);
    }
    public DefaultThreadPool(int num) {
        workerNum = num > MAX_WORKER_NUMBERS MAX_WORKER_NUMBERS: num < MIN_WORKER_
        NUMBERS MIN_WORKER_NUMBERS: num;
        initializeWokers(workerNum);
    }
    public void execute(Job job) {
        if (job != null) {
            // 添加一个工作，然后进行通知
            synchronized(jobs) {
                jobs.addLast(job);
                jobs.notify();
            }
        }
    }
    public void shutdown() {
        for (Worker worker: workers) {
            worker.shutdown();
        }
    }
    public void addWorkers(int num) {
        synchronized(jobs) {
            // 限制新增的Worker数量不能超过最大值
            if (num + this.workerNum > MAX_WORKER_NUMBERS) {
                num = MAX_WORKER_NUMBERS - this.workerNum;
            }
            initializeWokers(num);
            this.workerNum += num;
        }
    }
    public void removeWorker(int num) {
        synchronized(jobs) {
            if (num >= this.workerNum) {
                throw new IllegalArgumentException("beyond workNum");
            }
            // 按照给定的数量停止Worker
            int count = 0;
            while (count < num) {
                Worker worker = workers.get(count)
                if (workers.remove(worker)) {
                    worker.shutdown();
                    count++;
                }
            }
            this.workerNum -= count;
        }
    }
    public int getJobSize() {
        return jobs.size();
    }
    // 初始化线程工作者
    private void initializeWokers(int num) {
        for (int i = 0; i < num; i++) {
            Worker worker = new Worker();
            workers.add(worker);
            Thread thread = new Thread(worker, "ThreadPool-Worker-" + threadNum.incrementAndGet());
            thread.start();
        }
    }
    // 工作者，负责消费任务
    class Worker implements Runnable {
        // 是否工作
        private volatile boolean running = true;
        public void run() {
            while (running) {
                Job job = null;
                synchronized(jobs) {
                    // 如果工作者列表是空的，那么就wait
                    while (jobs.isEmpty()) {
                        try {
                            jobs.wait();
                        } catch (InterruptedException ex) {
                            // 感知到外部对WorkerThread的中断操作，返回
                            Thread.currentThread().interrupt();
                            return;
                        }
                    }
                    // 取出一个Job
                    job = jobs.removeFirst();
                }
                if (job != null) {
                    try {
                        job.run();
                    } catch (Exception ex) {
                        // 忽略Job执行中的Exception
                    }
                }
            }
        }
        public void shutdown() {
            running = false;
        }
    }
}
```

这里有个细节，在通过 `execute(Job)` 方法提交任务后，调用的是 `notify()` 方法而不是 `notifyAll()` 方法，因为每个工作者线程的功能都是一样的，只要确保有一个被唤醒就行，因此调用 `notify()` 只唤醒一个线程能够减少开销。（避免将等待队列中的线程全部移动到阻塞队列中）。

可以看出，线程的本质，就是通过一个**线程安全的任务队列**，将客户端线程与工作线程连接起来，客户端提交任务到任务队列，工作线程不断地消费任务并执行对应逻辑。

![image](https://raw.githubusercontent.com/Rianico/Image/master/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/Snipaste_2020-04-05_13-39-57.png)



# 3. Java 中的锁

![image](https://raw.githubusercontent.com/Rianico/Image/master/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/Snipaste_2020-04-05_13-39-58.png)

## 3.1 Lock 接口

Lock 接口提供了与synchronized关键字类似的同步功能。对比 synchronized 隐式地获取锁， Lock 在使用时需要显式地获取和释放锁：

```java
Lock lock = new ReentrantLock();
lock.lock();
try {
    
} finally {
    lock.unlock();
}
```

这种方式带来了更好的扩展性，可以由我们自己控制释放的时机。

> NOTE：不要将获取锁的过程写在try块中，因为如果在获取锁（自定义锁的实现）时发生了异常，异常抛出的同时，也会导致锁无故释放。

Lock 接口提供的 synchronized 关键字所不具备的主要特性如下：

![image](https://raw.githubusercontent.com/Rianico/Image/master/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/Snipaste_2020-04-06_10-32-46.png)

Lock 提供的 API 如下：

![image](https://raw.githubusercontent.com/Rianico/Image/master/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/Snipaste_2020-04-06_10-33-34.png)

Lock接口的实现基本都是通过**聚合**了一个**同步器**（`AbstractQueuedSynchronizer`）的子类来完成线程访问控制的，常用的有 `ReentrantLock` 。

## 3.2 队列同步器

 `AbstractQueuedSynchronizer` （AQS， 队列同步器），是用来**构建锁或者其他同步组件的基础框架**，它使用了一个 int 成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。

同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态，在抽象方法的实现过程中免不了要对同步状态进行更改，这时就需要使用同步器提供的3个方法（`getState()`、`setState(int newState)` 和 `compareAndSetState(int expect,int update)`）来进行操作，因为它们能够保证状态的改变是安全的。

子类推荐被定义为自定义同步组件的静态内部类，同步器自身没有实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用，同步器既可以支持独占式地获取同步状态，也可以支持共享式地获
取同步状态，这样就可以方便实现不同类型的同步组件（`ReentrantLock`、`ReentrantReadWriteLock` 和 `CountDownLatch` 等）。

同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。

可以这样理解二者之间的关系：

- **锁是面向使用者**的，它定义了使用者与锁交互的接口（比如可以允许两个线程并行访问），隐藏了实现细节；

- **同步器面向的是锁的实现者**，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。

锁和同步器很好地隔离了使用者和实现者所需关注的领域。

AQS 通常需要重写以下方法：

![image](https://raw.githubusercontent.com/Rianico/Image/master/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/Snipaste_2020-04-06_11-07-26.png)

基本可以分为三大类：① 独占式获取和释放同步状态；② 共享式获取和释放同步状态；③ 查询同步队列中的等待线程情况。

独占式就是在同一时刻只能有一个线程获取到锁，而其他获取锁的线程只能处于同步队列中等待，只有获取锁的线程释放了锁，后继的线程才能够获取锁。

共享式就是同一时刻能够多个线程获取到同步状态。

重写 AQS 指定的方法时，需要使用 AQS 提供的以下三个方法来获取和修改同步状态：

- `getState()`：获取当前同步状态。
- `setState(int newState)`：设置当前同步状态。
- `compareAndSetState(int expect,int update)`：使用CAS设置当前状态，该方法能够保证状态设置的原子性。

AQS 提供的模板方法：

![image](https://raw.githubusercontent.com/Rianico/Image/master/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/Snipaste_2020-04-06_11-09-36.png)

通常都是定义一个静态内部类继承 AQS ，然后实现相应功能：

```java
class Mutex implements Lock {
    // 静态内部类，自定义同步器
    private static class Sync extends AbstractQueuedSynchronizer {
        // 是否处于占用状态
        protected boolean isHeldExclusively() {
            return getState() == 1;
        }
        // 当状态为0的时候获取锁
        public boolean tryAcquire(int acquires) {
            if (compareAndSetState(0, 1)) {
                setExclusiveOwnerThread(Thread.currentThread());
                return true;
            }
            return false;
        }
        // 释放锁，将状态设置为0
        protected boolean tryRelease(int releases) {
            if (getState() == 0) 
                throw new IllegalMonitorStateException();
            setExclusiveOwnerThread(null);
            setState(0);
            return true;
        }
        // 返回一个Condition，每个condition都包含了一个condition队列
        Condition newCondition() {
            return new ConditionObject();
        }
    }
    // 仅需要将操作代理到Sync上即可
    private final Sync sync = new Sync();
    public void lock() {
        sync.acquire(1);
    }
    public boolean tryLock() {
        return sync.tryAcquire(1);
    }
    public void unlock() {
        sync.release(1);
    }
    public Condition newCondition() {
        return sync.newCondition();
    }
    public boolean isLocked() {
        return sync.isHeldExclusively();
    }
    public boolean hasQueuedThreads() {
        return sync.hasQueuedThreads();
    }
    public void lockInterruptibly() throws InterruptedException {
        sync.acquireInterruptibly(1);
    }
    public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException {
        return sync.tryAcquireNanos(1, unit.toNanos(timeout));
    }
}
```

上述代码实现了独占式获取同步状态，使用者不需要与 AQS 交互，只需要调用 Mutex 提供的方法即可。

### 3.2.1 同步队列

同步器依赖内部的同步队列（一个 FIFO 双向队列）来完成同步状态的管理，当前线程获取同步状态失败时，同步

器会将当前线程以及等待状态等信息构造成为一个节点（Node）并将其加入同步队列，同时会阻塞当前线程，当

同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。

同步队列中的节点（Node）用来保存获取同步状态失败的线程引用、等待状态以及前驱和后继节点：

![image](https://raw.githubusercontent.com/Rianico/Image/master/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/Snipaste_2020-04-06_11-41-01.png)

节点是构成同步队列的基础，同步器拥有首节点（head）和尾节点（tail），没有成功获取同步状态的线程将会成为节点，通过 CAS 方式加入该队列的尾部：

![image](https://raw.githubusercontent.com/Rianico/Image/master/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/Snipaste_2020-04-06_11-43-16.png)



同步队列中，**首节点是获取同步状态成功的结点**。

首节点的线程在释放同步状态后，会唤醒等待中的后继节点，后继节点会在获取同步状态成功后将自己设置为新的首节点。

**设置首节点是由成功获取到同步状态的线程来完成的**，

**独占式**中由于只有一个线程能够获取到同步状态，因此设置首节点的方法并不需要 CAS 来保证。

### 3.2.2 独占式同步状态获取与释放

AQS 的 `acquire(int arg)` 可以获取同步状态，该方法对中断不敏感，也就是说当线程获取同步状态失败后进入同步队列，即使接收到中断信号，也不会从同步队列中移出：

```java
public final void acquire(int arg) {
    if (!tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
```

上述代码主要完成了同步状态获取、节点构造、加入同步队列以及在同步队列中自旋等待的相关工作，其主要逻辑是：

- 首先调用自定义同步器实现的 `tryAcquire(int arg)` 方法，该方法保证线程安全的获取同步状态;

  - 如果同步状态获取失败，则构造同步节点（独占式`Node.EXCLUSIVE`，同一时刻只能有一个线程成功获取同步状态）并通过 `addWaiter(Node node)` 方法将该节点加入到同步队列的尾部;

  - 最后调用 `acquireQueued(Node node,int arg)` 方法，使得该节点以“死循环”的方式获取同步状态。
- 如果获取不到则阻塞节点中的线程，而被阻塞线程的唤醒主要依靠前驱节点的出队或阻塞线程被中断来实现。

接下来看一下几个方法的实现：

```java
private Node addWaiter(Node mode) {
    Node node = new Node(Thread.currentThread(), mode);
    // 快速尝试在尾部添加
    Node pred = tail;
    if (pred != null) {
        node.prev = pred;
        if (compareAndSetTail(pred, node)) {
            pred.next = node;
            return node;
        }
    }
    enq(node);
    return node;
}
private Node enq(final Node node) {
    for (;;) {
        Node t = tail;
        if (t == null) { // Must initialize
            if (compareAndSetHead(new Node()))
                tail = head;
        } else {
            node.prev = t;
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}
```

由于同步队列可能会被多个获取同步状态失败的线程并发的添加节点，因此需要通过 CAS 方式保证入队的线程安全。如果首次入队操作失败，则会通过 `enq(final Node node)` 进行循环，直到成功添加尾结点才返回。

节点进入同步队列后，就**进入了一个自旋状态**，每个节点（或者说每个线程）都在自省地观察，当条件满足，获取到了同步状态，就可以从这个自旋过程中退出，否则依旧留在这个自旋过程中（并会阻塞节点的线程）：

```java
final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();
            if (p == head && tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return interrupted;
            }
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```

同步队列中，只有首节点才是当前获取同步状态成功的结点。

当首节点释放的时候，会唤醒其后继节点，因此节点在自旋状态中需要检测自己的前驱节点是否为首节点，而且也便于对过早通知的处理（**过早通知是指前驱节点不是头节点的线程由于中断而被唤醒**）。

独占式同步状态 `acquire(int arg)` 获取流程：

![image](https://raw.githubusercontent.com/Rianico/Image/master/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/Snipaste_2020-04-06_12-39-04.png)

![image](https://raw.githubusercontent.com/Rianico/Image/master/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/Snipaste_2020-04-06_12-52-32.png)

可以看到，每个节点之间并不直接通信，而是自旋地进行自我检查。

当同步状态获取成功后，当前线程从 `acquire(int arg)` 方法返回，代表着当前线程获取了锁。

当前线程获取锁并执行了相应任务后，就需要释放锁同步状态，使得后续节点能够继续获取同步状态，这里也是调用 AQS 的 `release(int arg)` 进行释放，唤醒其后继节点：

```java
public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null && h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}
```

独占式同步状态获取和释放过程总结：

- 获取同步状态时，同步器维护一个同步队列，获取状态失败的线程都会被加入到队列中并在队列中进行自旋；
- 移出队列（或停止自旋）的条件是前驱节点为头节点且成功获取了同步状态。在释放同步状态时，同步
  器调用 `tryRelease(int arg)` 方法释放同步状态，然后唤醒头节点的后继节点。

### 3.2.3 共享式同步状态获取与释放

共享式获取与独占式获取最主要的区别在于**同一时刻能否有多个线程同时获取到同步状态**。

共享锁通过调用同步器的 `acquireShared(int arg)` 方法可以共享式地获取同步状态：

```java
public final void acquireShared(int arg) {
    if (tryAcquireShared(arg) < 0)
        doAcquireShared(arg);
}
private void doAcquireShared(int arg) {
    final Node node = addWaiter(Node.SHARED);
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();
            if (p == head) {
                int r = tryAcquireShared(arg);
                if (r >= 0) {
                    setHeadAndPropagate(node, r);
                    p.next = null;
                    if (interrupted)
                        selfInterrupt();
                    failed = false;
                    return;
                }
            }
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```

在 `acquireShared(int arg)` 方法中，同步器调用 `tryAcquireShared(int arg)` 方法尝试获取同步状态，`tryAcquireShared(int arg)` 会返回当前获取了同步状态的线程数，当返回值大于等于 0 时，表示能够获取到同步状态。

因此，在共享式获取的自旋过程中，成功获取到同步状态并退出自旋的条件就是 `tryAcquireShared(int arg)` 方法返回值大于等于 0 。可以看到，在 `doAcquireShared(int arg)` 方法的自旋过程中，如果当前节点的前驱为头节点时，尝试获取同步状态，如果返回值大于等于0，表示该次获取同步状态成功并从自旋过程中退出。

共享锁释放锁的方法如下：

```java
public final boolean releaseShared(int arg) {
    if (tryReleaseShared(arg)) {
        doReleaseShared();
        return true;
    }
    return false;
}
```

由于共享锁会有多个线程同时获取到同步状态，因此释放的时候是通过 CAS 来安全释放的。

### 3.2.3 独占式超时获取同步状态

通过调用同步器的 `doAcquireNanos(int arg,long nanosTimeout)` 方法可以超时获取同步状态，即在指定的时间段内获取同步状态，如果获取到同步状态则返回true，否则，返回false。

超时获取同步状态过程可以被视作响应中断获取同步状态过程的“增强版”，`doAcquireNanos(int arg,long nanosTimeout)` 方法在支持响应中断的基础上，增加了超时获取的特性。

针对超时获取，会先计算出需要休眠的时间，精度为纳秒级别：`nanosTimeout-=now-lastTime`。 其中 `now` 为当前时间， `lastTime` 为上次唤醒的时间，如果 nanosTimeout 大于 0 则表示超时时间未到，继续计算并休眠，反之，表示已超时：

```java
private boolean doAcquireNanos(int arg, long nanosTimeout)
throws InterruptedException {
    long lastTime = System.nanoTime();
    final Node node = addWaiter(Node.EXCLUSIVE);
    boolean failed = true;
    try {
        for (;;) {
            final Node p = node.predecessor();
            if (p == head && tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return true;
            }
            if (nanosTimeout <= 0)
                return false;
            if (shouldParkAfterFailedAcquire(p, node) &&
                nanosTimeout > spinForTimeoutThreshold)
                LockSupport.parkNanos(this, nanosTimeout);
            long now = System.nanoTime();
            //计算时间，当前时间now减去睡眠之前的时间lastTime得到已经睡眠
            //的时间delta，然后被原有超时时间nanosTimeout减去，得到了
            //还应该睡眠的时间
            nanosTimeout -= now - lastTime;
            lastTime = now;
            if (Thread.interrupted())
                throw new InterruptedException();
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```

方法自旋的过程中，与独占式获取锁的过程类似，不同的是在获取锁失败后，不是继续循环，而是计算休眠时间并进入休眠状态。

> NOTE: 如果 `nanosTimeout` 小于等于 `spinForTimeoutThreshold`（1000纳秒）时，将不会使该线程进行超时等待，而是无条件地进入快速的自旋过程。这是因为非常短的超时时间，无法做到十分精确。

### 3.2.4 自定义同步组件——TwinsLock

接下来定义一个共享锁，同一时间最多只允许有两个线程获取同步状态，我们将其命名为 `TwinsLock` 。

思路：

1. 同一时间允许有两个线程获取同步状态，因此显然是共享式，因此要使用 AQS 提供的 `acquireShared(int args)` 方法这类和 Shared 相关的方法，因此 TwinsLock 必须重写 `tryAcquireShared(int args)` 方法和 `tryReleaseShared(int args)` 方法。
2. 定义资源数，由于同一时间允许最多两个线程同时获取同步状态，因此 status 最大为 2，有一个线程获取同步状态时 status - 1，释放时 status + 1，并且同一时间有多个线程可以获取/释放同步状态，因此要使用 CAS 方式保证线程安全。

```java
public class TwinsLock implements Lock {

    private static final class Sync extends AbstractQueuedSynchronizer {

        public Sync(int state) {
            assert (state > 0);
            setState(state);
        }

        @Override
        protected int tryAcquireShared(int arg) {
            for (; ; ) {
                int cur = getState();
                int newState = cur - arg;
                if (newState < 0 || compareAndSetState(cur, newState)) {
                    return newState;
                }
            }
        }

        @Override
        protected boolean tryReleaseShared(int arg) {
            for (; ; ) {
                int cur = getState();
                int newState = cur + arg;
                if (compareAndSetState(cur, newState)) {
                    return true;
                }
            }
        }
    }

    private Sync sync = new Sync(2);

    @Override
    public void lock() {
        sync.acquireShared(1);
    }

    @Override
    public void unlock() {
        sync.releaseShared(1);
    }
	// 其他接口方法省略...
}
```

测试方法：

```java
import org.junit.jupiter.api.Test;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;

class TwinsLockTest {

    @Test
    void test() throws InterruptedException {
        final Lock lock = new TwinsLock();
        class Worker extends Thread {
            public void run() {
                while (true) {
                    lock.lock();
                    try {
                        TimeUnit.SECONDS.sleep(1);
                        System.out.println(Thread.currentThread().getName());
                        TimeUnit.SECONDS.sleep(1);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    } finally {
                        lock.unlock();
                    }
                }
            }
        }
        // 启动10个线程
        for (int i = 0; i < 10; i++) {
            Worker w = new Worker();
            w.setDaemon(true);
            w.start();
        }
        // 每隔1秒换行
        for (int i = 0; i < 10; i++) {
            TimeUnit.SECONDS.sleep(1);
            System.out.println();
        }
    }

}
```

同一时间下允许最多两个线程获取同步状态，因此应该可以看到线程的名称两两成对地输出。

## 3.3 重入锁

在前面独占式获取锁 `Mutex` 的实现中，当一个线程调用 `lock()` 获取锁之后，再次调用 `lock()` 方法，则该线程会被自己所阻塞，这是因为实现的时候没有考虑到同个线程再次获取锁的场景，这时我们可以说 `Mutex` 是一个不支持重入的锁。

`synchronized` 支持隐式的重入，执行线程在获取了锁之后仍然能够连续多次地获得该锁，不会出现自己阻塞自己的情况。

`ReentrantLock` 无法像 `synchronized` 一样支持隐式重入，但是在调用 `lock()` 方法，已经获取到锁的线程，能够再次调用 `lock()` 方法获取锁而不被阻塞。这里会涉及到一个公平性问题，如果在绝对时间上，先对锁进行获取的请求一定先被满足，那么这个锁是公平的，反之，是不公平的。

公平的获取锁，也就是等待时间最长的线程最优先获取锁，也可以说**锁获取是顺序的**。ReentrantLock提供了一个构造函数，能够控制锁是否是公平的。

但是公平锁往往没有没有非公平锁的效率高，具体选择还是得根据具体场景来。



### 3.3.1 实现锁的重入

锁实现重入需要解决以下两个问题：

1. 线程再次获取锁。锁需要识别当前线程是否为当前占据锁线程，如果是，再次获取成功。
2. 所的最终释放。重复获取成功 n 次的锁，释放的时候也需要释放 n 次。这里可以通过 state 的计数来实现。

以 `ReentrantLock` 的**非公平锁** `nonfairTryAcquire` 方法为例：

```java
final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0) // overflow
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
```

该方法通过判断当前线程是否为获取锁的线程来决定获取操作是否成功，如果是获取锁的线程再次请求，则将同步状态值进行增加并返回true，表示获取同步状态成功。

接着是释放锁的方法：

```java
protected final boolean tryRelease(int releases) {
    int c = getState() - releases;
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) {
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}
```

如果该锁被获取了n次，那么前 n-1 次 `tryRelease(int releases)` 方法必须返回 false，而只有同步状态完全释放了，才能返回 true。可以看到，该方法将同步状态是否为 0 作为最终释放的条件，当同步状态为 0 时，将占有线程设置为 null，并返回 true，表示释放成功。

### 3.3.2 公平与非公平获取锁的区别

公平性与否是针对获取锁而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序，也就是FIFO。

查看 `ReentrantLock` 的公平锁 `tryAcquire` 方法：

```java
protected final boolean tryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        if (!hasQueuedPredecessors() &&
            compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0)
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
```

该方法与非公平锁唯一不同的是，多了个 `hasQueuedPredecessors()` 的判断，即加入了同步队列中当前节点是否有前驱节点的判断，如果方法返回 `true`，则表示前面有更先到达的线程在排队等待获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。

接下来对非公平锁以及公平锁做一个测试：

```java
class ReentrantLockTest {

    private static Lock fairLock = new ReentrantLock2(true);
    private static Lock unfairLock = new ReentrantLock2(false);
    private static int TIMES = 10;

    @Test
    public void fair() throws InterruptedException {
        System.out.println("Fair Lock:");
        testLock(fairLock);
        TimeUnit.SECONDS.sleep(3);
    }

    @Test
    public void unfair() throws InterruptedException {
        System.out.println("Unfair Lock:");
        testLock(unfairLock);
        TimeUnit.SECONDS.sleep(3);
    }

    private void testLock(Lock lock) throws InterruptedException {
        // 启动5个Job（略）
        for (int i = 0; i < TIMES; i++) {
            Thread thread = new Thread(new Job(lock), "" + i);
            thread.start();
        }
    }

    private static class Job extends Thread {
        private Lock lock;

        public Job(Lock lock) {
            this.lock = lock;
        }

        public void run() {
            lock.lock();
            // 连续2次打印当前的Thread和等待队列中的Thread（略）
            System.out.println("Lock by [" + Thread.currentThread().getName() + "], Wating by lock [" + ((ReentrantLock2) lock).getQueuedThreads2() + "]");
            System.out.println("Lock by [" + Thread.currentThread().getName() + "], Wating by lock [" + ((ReentrantLock2) lock).getQueuedThreads2() + "]");
            lock.unlock();
        }
    }

    private static class ReentrantLock2 extends ReentrantLock {
        public ReentrantLock2(boolean fair) {
            super(fair);
        }

        public List<String> getQueuedThreads2() {
            List<Thread> arrayList = new ArrayList<Thread>(super.getQueuedThreads());
            Collections.reverse(arrayList);
            return arrayList.stream().map(x -> x.getName()).collect(Collectors.toList());
        }
    }

}

// output:
Unfair Lock:
Lock by [0], Wating by lock [[]]
Lock by [0], Wating by lock [[1, 2, 3, 4, 6]]
Lock by [1], Wating by lock [[2, 3, 4, 6, 5]]
Lock by [1], Wating by lock [[2, 3, 4, 6, 5, 8]]
Lock by [9], Wating by lock [[2, 3, 4, 6, 5, 8, 7]]
Lock by [9], Wating by lock [[2, 3, 4, 6, 5, 8, 7]]
Lock by [2], Wating by lock [[3, 4, 6, 5, 8, 7]]
Lock by [2], Wating by lock [[3, 4, 6, 5, 8, 7]]
Lock by [3], Wating by lock [[4, 6, 5, 8, 7]]
Lock by [3], Wating by lock [[4, 6, 5, 8, 7]]
Lock by [4], Wating by lock [[6, 5, 8, 7]]
Lock by [4], Wating by lock [[6, 5, 8, 7]]
Lock by [6], Wating by lock [[5, 8, 7]]
Lock by [6], Wating by lock [[5, 8, 7]]
Lock by [5], Wating by lock [[8, 7]]
Lock by [5], Wating by lock [[8, 7]]
Lock by [8], Wating by lock [[7]]
Lock by [8], Wating by lock [[7]]
Lock by [7], Wating by lock [[]]
Lock by [7], Wating by lock [[]]


Fair Lock:
Lock by [0], Wating by lock [[]]
Lock by [0], Wating by lock [[1, 2, 3]]
Lock by [1], Wating by lock [[2, 3, 4]]
Lock by [1], Wating by lock [[2, 3, 4, 5]]
Lock by [2], Wating by lock [[3, 4, 5, 6]]
Lock by [2], Wating by lock [[3, 4, 5, 6, 7]]
Lock by [3], Wating by lock [[4, 5, 6, 7, 8]]
Lock by [3], Wating by lock [[4, 5, 6, 7, 8, 9]]
Lock by [4], Wating by lock [[5, 6, 7, 8, 9]]
Lock by [4], Wating by lock [[5, 6, 7, 8, 9]]
Lock by [5], Wating by lock [[6, 7, 8, 9]]
Lock by [5], Wating by lock [[6, 7, 8, 9]]
Lock by [6], Wating by lock [[7, 8, 9]]
Lock by [6], Wating by lock [[7, 8, 9]]
Lock by [7], Wating by lock [[8, 9]]
Lock by [7], Wating by lock [[8, 9]]
Lock by [8], Wating by lock [[9]]
Lock by [8], Wating by lock [[9]]
Lock by [9], Wating by lock [[]]
Lock by [9], Wating by lock [[]]
```

可以看出，公平锁下一次获取锁的线程，都是取自等待队列中的第一个线程，而非公平锁则不一定。

由于公平锁的性质，会导致多次上下文切换，所以效率上会比非公平锁低，且 `ReemtrantLock` 的默认实现也是非公平方式。

## 3.4 读写锁

`ReentrantReadWriteLock` 中，读写状态就是其同步器的状态，通过拆分同步状态 state 的高低位来维护**多个读线程和一个写线程**的状态：

![image](https://raw.githubusercontent.com/Rianico/Image/master/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/Snipaste_2020-04-12_12-40-43.png)

当前同步状态表示一个线程已经获取了写锁，且重进入了两次，同时也连续获取了两次读锁。

**读写锁是如何迅速确定读和写各自的状态呢？**

通过位运算，假设当前同步状态值为 `S` ，写状态等于 `S & 0x0000FFFF`（将高16位全部抹去），读状态等于`S>>>16`（无符号补 0 右移 16 位）。当写状态增加 1 时，等于 `S+1`，当读状态增加 1 时，等于 `S+(1<<16)`，也就是 `S + 0x00010000`。

推论：S 不等于 0 时，当写状态（`S & 0x0000FFFF`）等于 0 时，则读状态（`S>>>16`）大于0，即读锁已被获取。

查看 `ReentrantReadWriteLock` 的 `tryAcquire` 方法：

```java
protected final boolean tryAcquire(int acquires) {
    /*
     * Walkthrough:
     * 1. If read count nonzero or write count nonzero
     *    and owner is a different thread, fail.
     * 2. If count would saturate, fail. (This can only
     *    happen if count is already nonzero.)
     * 3. Otherwise, this thread is eligible for lock if
     *    it is either a reentrant acquire or
     *    queue policy allows it. If so, update state
     *    and set owner.
     */
    Thread current = Thread.currentThread();
    int c = getState();
    int w = exclusiveCount(c);
    if (c != 0) {
        // (Note: if c != 0 and w == 0 then shared count != 0)
        if (w == 0 || current != getExclusiveOwnerThread())
            return false;
        if (w + exclusiveCount(acquires) > MAX_COUNT)
            throw new Error("Maximum lock count exceeded");
        // Reentrant acquire
        setState(c + acquires);
        return true;
    }
    if (writerShouldBlock() ||
        !compareAndSetState(c, c + acquires))
        return false;
    setExclusiveOwnerThread(current);
    return true;
}
```

该方法用于写锁获取同步状态，除了重入条件之外，还判断了读锁是否存在。

如果存在读锁，则写锁不能被获取。这是因为**读写锁要保证写锁的操作对读锁可见**，并且写锁一旦被获取，则其他读写线程的后续访问均被阻塞。

写锁的释放与 `ReentrantLock` 的释放过程基本类似，每次释放均减少写状态，当写状态为 0 时表示写锁已被释放。

------

读锁是一个支持重入的共享锁，它能够被多个线程同时获取，在没有其他写线程访问（或者写状态为0）时，读锁总会被成功地获取，并且以线程安全的方式增加读状态。

如果当前线程已经获取了读锁，则增加读状态。如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态。

获取读锁的实现从 Java5 到 Java6 变得复杂许多，主要原因是新增了一些功能，例如 `getReadHoldCount()` 方法，作用是返回当前线程获取读锁的次数。读状态是所有线程获取读锁次数的总和，而每个线程各自获取读锁的次数只能选择保存在 `ThreadLocal` 中，由线程自身维护，这使获取读锁的实现变得复杂。

这里对 `ReentrantReadWriteLock` 的 `tryAcquireShared` 方法进行简化，保留关键部分：

```java
protected final int tryAcquireShared(int unused) {
    for (;;) {
        int c = getState();
        int nextc = c + (1 << 16);
        if (nextc < c)
            throw new Error("Maximum lock count exceeded");
        if (exclusiveCount(c) != 0 && owner != Thread.currentThread())
            return -1;
        if (compareAndSetState(c, nextc))
            return 1;
    }
}
```

在 `tryAcquireShared(int unused)` 方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程以 CAS 方式增加读状态，成功获取读锁。

------

读写锁中**允许写锁降级为读锁**，反之则不行。

如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种**分段完成的过程不能称之为锁降级**。

锁降级是当前指有写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程。

以一段锁降级的代码为例：

```java
public void processData() {
    readLock.lock();
    if (!update) {
        // 必须先释放读锁
        readLock.unlock();
        // 锁降级从写锁获取到开始
        writeLock.lock();
        try {
            if (!update) {
                // 准备数据的流程（略）
                update = true;
            }
            readLock.lock();
        } finally {
            writeLock.unlock();
        }
        // 锁降级完成，写锁降级为读锁
    }
    try {
        // 使用数据的流程（略）
    } finally {
        readLock.unlock();
    }
}
```

上述示例中，当数据发生变更后，`update` 变量（`Boolean` 且 `volatile` 修饰）被设置为 `false`，此时所有访问 `processData()` 方法的线程都能够感知到变化，但只有一个线程能够获取到写锁，其他线程会被阻塞在读锁和写锁的 `lock()` 方法上。当前线程获取写锁完成数据准备之后，再获取读锁，随后释放写锁，完成锁降级。

**锁降级中读锁的获取是否必要呢？**

答案是必要的。主要是为了**保证数据的可见性**，如果当前线程不获取读锁而是直接释放写锁，假设此刻另一个线程（记作线程 T ）获取了写锁并修改了数据，那么当前线程无法感知线程 T 的数据更新（因为是属于不同的锁对象）。如果当前线程获取读锁，即遵循锁降级的步骤，则线程 T 将会被阻塞，直到当前线程使用数据并释放读锁之后，线程 T 才能获取写锁进行数据更新。

**RentrantReadWriteLock** 不支持锁升级（把持读锁、获取写锁，最后释放读锁的过程）。目的也是保证数据可见性，如果读锁已被多个线程获取，其中任意线程成功获取了写锁并更新了数据，则其更新对其他获取到读锁的线程是不可见的。

## 3.5. LockSupport 工具

AQS 中当需要阻塞或唤醒一个线程的时候，都会使用 `LockSupport` 工具类来完成相应工作。`LockSupport` 定义了一组的公共静态方法，这些方法提供了最基本的线程阻塞和唤醒功能，而 `LockSupport` 也成为构建同步组件的基础工具。

`LockSupport` 定义的方法如下：

![image](https://raw.githubusercontent.com/Rianico/Image/master/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/Snipaste_2020-04-12_13-11-54.png)

在Java 6中，`LockSupport` 增加了 `park(Object blocker)`、`parkNanos(Object blocker,long nanos)` 和 `parkUntil(Object blocker,long deadline)` 3 个方法，用于实现阻塞当前线程的功能，其中参数 `blocker` 是用来标识当前线程在等待的对象（以下称为阻塞对象），该对象主要用于问题排查和系统监控。

`blocker` 与不带 `blocker` 在 dump 的时候区别如下：

![image](https://raw.githubusercontent.com/Rianico/Image/master/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/Snipaste_2020-04-12_13-15-37.png)

## 3.6 Condition接口

任意一个 `Java` 对象，都拥有一组监视器方法（定义在 `java.lang.Object` 上），主要包括 `wait()`、`wait(long timeout)`、`notify()` 以及 `notifyAll()` 方法，这些方法与 `synchronized` 同步关键字配合，可以实现 等待/通知 模式。

`Condition` 接口也提供了类似 `Object` 的监视器方法，与`Lock` 配合可以实现 等待/通知 模式，但是这两者在使用方式以及功能特性上还是有差别的：

![image](https://raw.githubusercontent.com/Rianico/Image/master/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/Snipaste_2020-04-12_13-18-05.png)

使用示例如下：

```java
public class ConditionTest {

    Lock lock = new ReentrantLock();
    Condition condition = lock.newCondition();

    public void conawait() {
        lock.lock();
        try {
            System.out.println("before await...");
            condition.await();
            System.out.printf("recovery from await");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public void singnal() {
        lock.lock();
        try {
            condition.signal();
        } finally {
            lock.unlock();
        }

    }

    public static void main(String[] args) throws InterruptedException {
        ConditionTest conditionTest = new ConditionTest();
        new Thread(conditionTest::conawait).start();
        TimeUnit.SECONDS.sleep(2);
        new Thread(conditionTest::singnal).start();

    }

}
```

要获取一个 `Condition` 对象首先要通过 `Lock` 的 `newCondition()` 方法，之后通过 `await` 释放锁进入等待状态，`signal` 唤醒。

下面是一个更加复杂的例子， 当队列为空时， `empty` 会阻塞获取操作，直到队列有新增元素；当队列已满的时候，`full` 则会阻塞插入操作：

```java
public class BoundedQueue < T > {
    private Object[] items;
    // 添加的下标，删除的下标和数组当前数量
    private int addIndex,
    removeIndex,
    count;
    private Lock lock = new ReentrantLock();
    private Condition empty = lock.newCondition();
    private Condition full = lock.newCondition();
    public BoundedQueue(int size) {
        items = new Object[size];
    }
    // 添加一个元素，如果数组满，则添加线程进入等待状态，直到有"空位"
    public void add(T t) throws InterruptedException {
        lock.lock();
        try {
            while (count == items.length)
                full.await();
            items[addIndex] = t;
            if (++addIndex == items.length)
                addIndex = 0;
            ++count;
            empty.signal();
        } finally {
            lock.unlock();
        }
    }
    // 由头部删除一个元素，如果数组空，则删除线程进入等待状态，直到有新添加元素
    @SuppressWarnings("unchecked")
    public T remove() throws InterruptedException {
        lock.lock();
        try {
            while (count == 0)
                empty.await();
            Object x = items[removeIndex];
            if (++removeIndex == items.length)
                removeIndex = 0;
            --count;
            full.signal();
            return (T) x;
        } finally {
            lock.unlock();
        }
    }
}
```

本质上这种方式跟借助 `synchronized` 关键字的 等待/通知 模式是一样的，并且使用循环也是为了防止过早通知。

`ConditionObject` 是同步器 AQS 的内部类，每个 `Condition` 对象都包含着一个队列（以下称为等待队列），该队列是 `Condition` 对象实现 等待/通知 功能的关键。

等待队列是一个 FIFO 的队列，在队列中的每个节点都包含了一个线程引用，该线程就是 `Condition` 对象上等待的线程，如果一个线程调用了 `Condition.await()` 方法，那么该线程将会释放锁、构造成节点加入等待队列并进入等待状态。

节点的定义复用了同步器中节点的定义，同步队列和等待队列中节点类型都是同步器的静态内部类`AbstractQueuedSynchronizer.Node`。

在 `Object` 的监视器模型上，一个对象拥有**一个同步队列和等待队列**，而并发包中的Lock（更确切地说是 AQS）拥有一个同步队列和多个等待队列：

![image](https://raw.githubusercontent.com/Rianico/Image/master/Netty/Snipaste_2020-04-19_19-00-18.png)

由于 `Condition` 是 AQS 的内部类，因此每个 `Condition` 实例都有所属 AQS 的引用。

`Condition` 中  `await` 的代码如下：

```java
public final void await () throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    // 当前线程加入等待队列
    Node node = addConditionWaiter();
    // 释放同步状态，也就是释放锁
    int savedState = fullyRelease(node);
    int interruptMode = 0;
    while (!isOnSyncQueue(node)) {
        LockSupport.park(this);
        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
            break;
    }
    if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
        interruptMode = REINTERRUPT;
    if (node.nextWaiter != null)
        unlinkCancelledWaiters();
    if (interruptMode != 0)
        reportInterruptAfterWait(interruptMode);
}
```

同步队列中的首节点（也就是当前获得锁的线程）会将当前当前线程构造成节点并加入等待队列中，然后释放同步状态，并唤醒同步队列中的后继节点。

![image](https://raw.githubusercontent.com/Rianico/Image/master/Netty/Snipaste_2020-04-19_19-07-41.png)

如果后继节点不是通过 `Condition.signal()` 被唤醒，而是受到中断信号，则会抛出 `InterruptedException`。

接下来看下 `Condition` 的 `signal` 方法：

```java
public final void signal() {
    if (!isHeldExclusively())
        throw new IllegalMonitorStateException();
    Node first = firstWaiter;
    if (first != null)
        doSignal(first);
}
```

可以看到先是检查了当前线程是否获得了锁，接着便将等待队列的首节点移动到同步队列并唤醒。

![image](https://raw.githubusercontent.com/Rianico/Image/master/Netty/Snipaste_2020-04-19_19-10-59.png)

之后节点便在同步队列中开始自旋。

# 4. Java 并发容器和框架

## 4.1 ConcurrentHashMap

由于 `HashMap` 在多线程环境下会产生环形链表，导致 CPU 占用 100%，因此需要一个能够在多线程环境下使用的数据结构： `ConcurrentHashMap`。

![image-20200425151141898](../../../../../../AppData/Roaming/Typora/typora-user-images/image-20200425151141898.png)

`ConcurrentHashMap` 主要是通过分段锁的思想，在保证 `HashMap` 线程安全的同时性能不至于太差：

![image-20200425151246448](../../../../../../AppData/Roaming/Typora/typora-user-images/image-20200425151246448.png)

ConcurrentHashMap初始化方法是通过 `initialCapacity`、`loadFactor` 和 `concurrencyLevel` 等几个参数来初始化 `segment` 数组、段偏移量 `segmentShift` 、段掩码 `segmentMask` 和每个 `segment` 里的 `HashEntry` 数组来实现的。

由于 Jdk7 和 Jdk8 具体实现差别较大，此处先不做记录，待后面再补充。

这里只需要先记住，`Segment` 数组在 `ConcurrentHashMap` 中充当了分段锁的角色。

## 4.2 ConcurrentLinkedQueue

查看 JDK8 下 `ConcurrentLinkedQueue` 的实现：

```java
    public boolean offer(E e) {
        checkNotNull(e);
        final Node<E> newNode = new Node<E>(e);

        for (Node<E> t = tail, p = t;;) {
            Node<E> q = p.next;
            if (q == null) {
                // p is last node
                if (p.casNext(null, newNode)) {
                    // Successful CAS is the linearization point
                    // for e to become an element of this queue,
                    // and for newNode to become "live".
                    if (p != t) // hop two nodes at a time
                        casTail(t, newNode);  // Failure is OK.
                    return true;
                }
                // Lost CAS race to another thread; re-read next
            }
            else if (p == q)
                // We have fallen off list.  If tail is unchanged, it
                // will also be off-list, in which case we need to
                // jump to head, from which all live nodes are always
                // reachable.  Else the new tail is a better bet.
                p = (t != (t = tail)) ? t : head;
            else
                // Check for tail updates after two hops.
                p = (p != t && t != (t = tail)) ? t : q;
        }
    }
```

上述代码主要做了两件事情：

① 通过 CAS 方式将新的节点入队，不成功则重试；

② 更新 tail 定位至尾结点。

需要注意的是，并不是每次入队，都会将 `tail` 更新到尾结点，如果 `tail` 的 `next` 为 null，则代表当前 `tail` 为尾结点，并且当 `tail` 和 尾结点的距离大于等于 2 时，才会尝试更新 `tail` 到尾结点位置。