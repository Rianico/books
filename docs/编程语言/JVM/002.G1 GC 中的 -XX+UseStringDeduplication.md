---
title: G1 GC 中的 -XX:+UseStringDeduplication
date: 2020-07-22 15:36:17
permalink: /pages/6ade8e/
categories: 
  - Program-Language
  - Java Virtual Machine
tags: 
  - 
---
# G1 GC 中的 -XX:+UseStringDeduplication

[UseStringDeduplication – pros and cons](https://jaxenter.com/duplicate-strings-158567.html)

这篇文章介绍了 G1 GC 中的一个参数 `-XX:+UseStringDeduplication` ，这个参数主要用于消除 JVM 中一些重复的字符串。

## 重复字符串怎么产生？

```vim
String string1 = new String("Hello World");
String string2 = new String("Hello World");
```

如果执行了上述代码，那么将会产生两个不同的字符串对象，然而他们的内容却是一样的，或者以客户查询银行流水为例，通常多条记录也会对应多个字符串，即使其中金额不同。

这个问题从 Java 诞生之初就存在了，社区也尝试了多种力求侵入性最小的方案来解决这个问题，最新的解决方案就是 `-XX:+UseStringDeduplication` 。

## -XX:+UseStringDeduplication 的使用注意事项

`-XX:+UseStringDeduplication` 看起来很好，但其使用也有一些优缺点：

1. 只能在 G1 GC 中使用；
2. 只对长生命周期的对象起作用（**只会对老年代进行回收**），如果对短生命周期立刻就会被回收的对象进行消除也没有意义，只会浪费系统资源，这个生命周期的阈值由 `-XX:StringDeduplicationAgeThreshold` 决定；
3. 对 GC 暂停时间会有影响，因为是借助 GC 消除重复字符串的，所以会占用 GC 的一些资源，所以可能会增加 GC 的暂停时间。但同时，如果回收率特别高的话，可以减少 GC 其他阶段的暂停时间，因此还需要自行做个衡量测试。可以通过 `-XX:+PrintStringDeduplicationStatistics` 这个参数来打印出重复字符串的消除情况；
4. `-XX:+UseStringDeduplication` **仅仅是替换相同内容的 Sting 对象底层的 char\[\] 数组**，而非消除 String 对象本身（一个 String 对象至少占用 24 bytes），相当于 `aString.value = anotherString.value` 。所以如果消除的重复字符串有绝大部分是短字符串，效果其实并不理想，这时候使用 `String.intern()` 或许会更有效；
5. 从 Java 8 update 20 这个版本开始才有这个特性。

## [DISAPPOINTING STORY ON MEMORY OPTIMIZATION](https://blog.gceasy.io/2018/07/17/disappointing-story-on-memory-optimization/)

这篇文章讲述了他们的一个 application 使用 `-XX:+UseStringDeduplication` 一次失败的经历。

文章中在使用了该参数后，发现对于应用实际运行并没有任何帮助，通过分析 GC 日志中的对象晋升速度，发现只有很少量的对象才会晋升到老年代，大部分对象在年轻代就被回收了，因此 `-XX:+UseStringDeduplication` 在这个场景下，并没有实际帮助。

也就是说，要使用这个参数，要看下老年代中是否存在大量长生命周期的字符串对象，通常在缓存较多的系统中使用效果较好。

分析重复的字符串内容以及 GC 晋升速度，可以通过以下两个网站查看：

[Heap Hero](https://heaphero.io/heap-index.jsp)：通过 `jmap -dump:live,format=b,file=/path/to/file PID` 并上传 dump 文件。

[GCeasy](https://gceasy.io/gc-index.jsp)：通过上传 GC 日志文件。

## 怎么查看 String 对象占用的内存大小？

可以通过 JDK 官方提供的 `jol` 来查看，在 Maven 中加入以下依赖：

```xml
    <dependency>
        <groupId>org.openjdk.jol</groupId>
        <artifactId>jol-core</artifactId>
        <version>0.9</version>
    </dependency>
```

并在代码中调用：

```java
public class StringTest {
    public static void main(String[] args) {
        String str = new String("");
        System.out.println(ClassLayout.parseClass(String.class).toPrintable());
        System.out.println(ClassLayout.parseInstance(str).toPrintable());
    }
}
// output:
java.lang.String object internals:
 OFFSET  SIZE     TYPE DESCRIPTION                               VALUE
      0    12          (object header)                           N/A
     12     4   char[] String.value                              N/A
     16     4      int String.hash                               N/A
     20     4          (loss due to the next object alignment)
Instance size: 24 bytes
Space losses: 0 bytes internal + 4 bytes external = 4 bytes total

java.lang.String object internals:
 OFFSET  SIZE     TYPE DESCRIPTION                               VALUE
      0     4          (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)
      4     4          (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)
      8     4          (object header)                           da 02 00 f8 (11011010 00000010 00000000 11111000) (-134216998)
     12     4   char[] String.value                              []
     16     4      int String.hash                               0
     20     4          (loss due to the next object alignment)
Instance size: 24 bytes
Space losses: 0 bytes internal + 4 bytes external = 4 bytes total


Process finished with exit code 0
```

需要注意的是，jol 在这里仅显示对象在浅引用下的内存布局。

接下来是对一个 String 对象至少占用 24 bytes 的分析：

在 64-bit 的系统并开启指针压缩的前提下，每个对象都会有个对象头（Object Header），通常占 8 bytes（markword） + 4 bytes（class pointer）= 12 bytes，4 byets 是对 char\[\] 数组的引用，4 byets 为 String 对象的 hash 值，还有 4 bytes 属于对齐填充（对象大小必须为 8 bytes 的倍数）。

