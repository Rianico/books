---
title: YGC 问题排查，又让我涨姿势了！
date: 2020-07-25 15:36:12
---

## YGC问题排查，又让我涨姿势了！

来自微信的一篇文章：[YGC问题排查，又让我涨姿势了！](https://mp.weixin.qq.com/s?__biz=MzAxNjM2MTk0Ng==&mid=2247491553&idx=2&sn=55d377eb711cdb0288d9cf28afa69e1d&chksm=9bf4af54ac83264273bf0e7961313b919f10bf671ba70b7bf8e157c65c05b9a5ea0a21eafd9f&mpshare=1&scene=1&srcid=0724RonOYge4S6M3ucwJdQ5D&sharer_sharetime=1595585703651&sharer_shareid=24a7761e1ff7c16d32495d378d4ca2de&key=a9ac97d80b28f50581fb140dfcd31ee77ce62069370b7e4a43f53233ba00e54b817d7d4c9cfda5ab29d281649b85e4cc4d10964a71defa6c3f3f7f81298dd80000a5749d819ad17c29ae7a89596361f6&ascene=1&uin=MTU0NzEwNTU4NA%3D%3D&devicetype=Windows+10+x64&version=62090529&lang=zh_CN&exportkey=AcJ3RvhOlb2MVUoodeE8mTU%3D&pass_ticket=MABdaGlgDhKVxYYoJdamGkNe%2F4jM1VuoFlc2Sa9cQVRSWjHGv0oVu7VbEMSvj6FP)。

通常来说，YGC 耗时过长是比较难排查的，但大部分情况下的原因都可以追溯到对象过多，而造成对象过多的原因有很多，如：

1. 内存泄漏（memory leak）；
2. 相同对象过多，且生命周期较长；
3. 其他。

这时候往往只能通过 dump 查看内存中的对象信息，并借助相关可视化工具进行分析。

其中第二点曾在工作中遇到：大量 Bean 对象经过 序列化-反序列化 后，原本相同的 String 对象变成了不同的 String 对象，且由于每个 Bean 对象的生命周期都很长，导致长时间存在大量内容相同但实例却不同的的 String 对象，YGC 的平均时长达到了 200ms 以上。



回顾下JVM 分配对象以及 YGC 的流程：

1. 新对象先尝试在栈上分配，若不行则在 TLAB 分配，如果还不行则判断对象是否满足大对象直接在老年代分配，若不满足则尝试在 Eden 区分配；
2. 如果 Eden 没有足够的空间，则触发 YGC；
3. YGC 会先遍历 GC Roots：虚拟机栈/本地方法栈、方法区中的静态对象、Synchronized 锁持有的对象、字符串常量池、跨代引用的对象（rem_set 记录）、系统加载类、和GC Root处于同一CardTable的对象，**得到第一批存活对象**。
4. YGC 对存活对象进行处理：
   - 若对象年龄满足要求，则进入老年代，若老年代空间不足，则会发生promotion failed，触发老年代的回收。
   - 否则进入 To Survivor 区域，如果 To Survivor 区域放不下，则放到老年代。
5. 此时第一批存货的对象存在于 To Survivor 以及 老年代，继续以其为根，递归遍历重复前一步。
6. 此时 Eden 以及 From Survivor 区剩下的对象均为可回收对象。

