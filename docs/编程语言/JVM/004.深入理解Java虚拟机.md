[toc]

## 第二章 自动内存管理

### 2.1 运行时数据区域

- **程序计数器**：一块很小的内存空间，用于指出下一条需要执行的指令，JVM 规范中，字节码解释器就是通过改变这个计数器来选取下一条需要执行的指令，是程序控制流的指示器。线程私有。
- **Java 虚拟机栈**：线程私有，生命周期与线程一致，用于描述 Java 方法执行的线程内存模型。
  - 执行方法调用时，JVM  会同步创建一个**栈帧（Stack Frame）**，存储了**局部变量表**，操作数栈、动态链接、方法出口等信息。
    - 局部变量表：存放了编译期可知的 8 种基本类型、对象引用、returnAddress 类型。
    - 局部变量表以**槽（Slot）**来表示存储空间，long、double 类型需要占用两个槽，至于一个槽对应多大内存空间由 JVM 具体实现决定。
    - 可以看出，局部变量表所需的内存空间在编译期间就可以确定了。
  - 每一个方法的调用直至结束，对应一个栈帧在 Java 虚拟机栈中入栈出栈的过程。
  - 栈深度超过允许的深度时将抛出 **StackOverflowError** 异常，无法申请足够的内存时则是 **OutOfMemoryError** 异常。
- **本地方法栈**：与 Java 虚拟机栈类似，为本地方法调用服务。
- **Java 堆**：属于共享内存，存在的唯一目的就是存放对象实例，几乎所有对象都在堆上分配（标量替换、栈上分配等一些优化技术除外）。
  - Java 会根据对象生命周期特色划分为新生代、老年代等，这种只是属于一种设计风格，并非 JVM 规范强制规定。
  - 分配内存时，可以在堆中划分出多块线程私有的 TLAB 来提高对象分配效率。
- **方法区**：线程共享，用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。
  - JVM 规范将其描述为堆的一个逻辑部分，别名**“非堆”（Non-Heap）**。
  - 方法区不等于 “永久代（Permanent Generation）”，只是 HotSpot 最先开始使用了永久代来实现方法区。
    - JDK 7 开始，**字符串常量池、静态变量等从方法区移出到堆中**。
    - JDK 8 开始取消了永久代，改为采用**本地内存（Native Memory）**实现，称为元**空间（Meta-space）**，并**将永久代剩余的内容（主要是 class 信息、运行时常量池）全部移到元空间中**。
  - **运行时常量池（Runtime Constant Pool）**是方法区的一部分：
    - Class 文件有一个**常量池表（Constant Pool Table，class 常量池）**，用于存放编译期生成的各种字面量与符号引用，**在类加载后会存放到方法区的运行时常量池中**；
    - Class 文件中的符号引用解析为直接引用后，也会存储在运行时常量池；
    - 具备动态性，允许在运行时往里（字符串常量池）添加新内容，如 String 类的 `intern()` 方法；
    - JDK 8 位于元空间中。
- **直接内存（Direct Memory）**：并非 JVM 运行时数据区的一部分，在 JVM 规范中也并未定义，但是随着 JDK 1.4 添加的 NIO 出现，采用了一种 基于通道（Channel）与缓冲区（Buffer）的 I/O 方式。JVM 通过操作堆里一个 `DirectByteBuffer` 来操作本地（堆外）内存，默认不对这块内存大小做限制，所以可能会超出本机物理内存大小，导致 OOM。

### 2.2 对象

#### 2.2.1 对象的新建

对象的创建（复制、序列化除外）通常对应一条 new 指令：

- 先到常量池寻找某个类的符号引用
  - 如果未加载，则执行加载、解析、初始化。
- 为对象分配内存，内存大小在加载完成便已经可以确定，不同的内存空间划分方式：
  - **指针碰撞（Bump The Pointer）**，只需要移动指针分配内存即可，要求 JVM 内存规整，内存规整取决于采用的 GC 算法是否带**空间压缩整理（Compact）**功能，如 Serial、ParNew 算法。
  - **空闲列表（Free List）**，维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，如 CMS 算法。
  - 除了划分空间外，还需要考虑分配对象时的线程安全，通常采用：① CAS 方式保证更新操作的原子性；② 使用 TLAB  解决，可以设置是否开启，默认开启。
- 内存分配完后，会将分配的内存空间（不包含对象头）初始化为零值，如果有使用 TLAB 也可以提前到 TLAB 阶段初始化。这一步可以保证程序能够访问到字段数据类型对应的零值
- 对对象进行一些必要的设置：对象属于哪个 class、如何定位 class 的元数据信息、对象哈希码（实际会到调用 `Object::HashCode()` 方法时才计算)、是否启用偏向锁等。

上述步骤后，从 JVM 角度来看，一个新的对象已经产生了，而从 Java 程序的角度来看，还需要执行 `<init>`  方法，按照程序定义的流程进行初始化，这样才算是一个真正可用的对象。

> CMS 为了在大多数场景下更快的分配对象，设计了一个叫作 Linear Allocation Buffer 的分配缓冲区，通过空闲列表拿到一大块分配缓冲区之后，在里面仍然可以使用指针碰撞方式来分配。

#### 2.2.2 对象的内存布局

Java 对象从内存布局上可以分为三块：**对象头**（Object Header）、**实例数据**（Instance Data）和**对齐填充**（Padding）。

对象头包含两类信息：

1. 存储对象自身的运行时信息，称为 **Mark Word**，存储了如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等。

![](https://raw.githubusercontent.com/Rianico/Image/master/ARTS_Tips/Snipaste_2020-11-01_15-47-48.png)

2. 类型指针，指向实例对象的类型元数据，JVM 通过这个指针来确定对象是属于哪个类的实例。

> 在 32 bit 和 64 bit 的 JVM 中，Mark Word 的大小分别为 32 bit 与 64 bit，类型指针同理，但类型指针可以通过开启指针压缩减小到 32 bit，但仅限 JVM 内存 小于 32 G 的场景。

实例数据存储了对象真正的有效信息，子类也会为父类字段分配内存，字段之间的排序也存在一定规则，受到 JVM 参数 `-XX：FieldsAllocationStyle` 影响，默认分配顺序为 longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers，OOPs），父类定义的字段会π在子类之前，如果开启了` +XX：CompactFields`（默认开启），那子类之中较窄的变量也允许插入父类变量的空 隙之中，以节省出一点点空间。

对齐填充，并非必然的，仅存在着占位作用，用于对象对齐（默认 8 字节）。

#### 2.2.3 对象的访问定位

Java 虚拟机规范规定了 reference 类型是用于指向对象的一个引用，但并未规定具体实现细节，常见的实现方式有两种：

1. 句柄访问，Java 堆中可能划分出一块内存用于存放句柄来作为句柄池，reference 存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息，这种方式需要做一次转发。

   ![](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/Snipaste_2021-01-10_15-39-52.png)
   
   2. 直接访问，reference 直接存储了对象的地址，这种方式下实例对象的内存布局需要考虑如何存放类型数据的相关信息，但可以减少一次转发。
   
      ![image-20210110193141447](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210110193141447.png)
   
   > HotSpot 采用了直接访问的方式。

### 2.3 OutOfMemoryError 异常

Java 堆溢出，可以通过 `-XX：+HeapDumpOnOutOfMemoryError` 指定 OOM 时 dump 当前的内存快照，便于后续分析。

虚拟机栈和本地方法栈较为特别，Java 虚拟机规范规定如下：

1. 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出 StackOverflowError 异常。
2. **如果虚拟机的栈内存允许动态扩展**，当扩展栈容量无法申请到足够的内存时，将抛出 OutOfMemoryError异常。

由于 HotSpot 不支持栈内存扩展，所以**只有在创建线程时无法申请到足够的内存才会抛出 OOM 异常**，否则在线程运行时是不会因为扩展而导致 OOM 的（第二点）。

因此 HotSpot 只会在栈容量无法容纳新的栈帧时才会抛出 StackOverflowError 异常（第一点）。

>  当在正常业务场景下遇到 StackOverflowError 异常，在无法增加内存资源，又无法减少需要创建的线程的时候，可以考虑通过减小栈容量（-Xss）以及堆最大内存，来换区更多可创建的线程。

方法区溢出，需要考虑 JDK 6、JDK 7、JDK 8 这三种不同的场景，由于方法区在这三个版本的 JDK 中都做过调整，因此不同 JDK 关于方法区溢出的现象是不一样的。

1. 在 JDK 6 中，如果通过 `String.intern()` 来一直添加字符串到字符串常量池中，那么最后可以见到 `PermGen space` 这样的永久代 OOM 的异常信息，这是由于这时候字符串常量池还在永久代中。
2. JDK 7 开始，字符串常量池放到了堆中，如果再按照前面的方法，最终是会报出堆 OOM 异常，如果要报出永久代异常，可以通过不断地生成类来填满运行时常量池。
3. JDK 8 开始，运行时常量池移到了元空间中，属于堆外内存，这部分内存默认不加限制（很大很大），因此通常需要我们增加 `-XX:MaxMetaspaceSize` 来防止一些破坏性操作，避免撑爆系统内存。
   - **-XX:MinMetaspaceFreeRatio**：最小空闲比，当 Metaspace 发生 GC 后，如果剩余空间小于该比例则进行扩容。
   - **-XX:MaxMetaspaceFreeRatio**:最大空闲比，当 Metaspace 发生 GC 后，如果剩余空间大于该比例则进行缩容。

直接内存溢出，通常是与 NIO 有关，如果看到 dump 出来的内存快照很小，那么就需要注意是否直接/间接使用了 `DirectMemory` 。

## 第三章 垃圾收集器与内存分配策略

### 3.1 可达性分析算法

JVM 采用可达性分析算法来判断哪些对象属于垃圾并回收，从 GC ROOTS 出发，遍历对象：

![image-20210208234622138](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210208234622138.png)

一个对象要被回收，至少需要经过两次标记：

- 第一次是经过可达性分析后发现没有与 GC ROOTS 连接，则进行标记。
- 之后将其放到一个 F-Queue 的队列里，并以一个低优先级的线程去执行队列里对象的 finalize 方法，但不一定会执行（只有首次才会执行，以及重写了 finalize 方法），也不一定会等待执行完成。

### 3.2 方法区的回收

方法区的回收包括废弃的常量以及废弃的类两部分，前者回收较为简单，扫描 GC ROOTS 即可，后者需要同时满足以下三个条件：

![image-20210118224622265](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210118224622265.png)

> NOTE：JVM 提供了 - `Xnoclassgc` 关闭方法区类的回收，也提供了 -verbose:class 以及 -XX:+TraceClass-Loading、-XX:+TraceClassUnLoading 来跟踪类的加/卸载情况。

在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载 器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。

### 3.3 分代收集理论

当前商业虚拟机的垃圾收集器，多数都是遵循**“分代收集”（Generational Collection）**的理论开发的：

1. 弱分代假说，绝大多数对象朝生夕死。
2. 强分代假说，熬过越多次垃圾收集的对象越难以消亡。
3. 跨代引用假说，跨代引用对于同代引用来说仅占极少数。

基于前两个假设，设计者一般会将 Java 堆划分为新生代、老年代两个区域。

还有一种现象就是跨代引用，为了避免扫描整个老年代，需要在新生代新建一个全局的数据结构 Remembered Set,这个数据结构将老年代划分为若干个内存块，并标记出包含了有跨代引用的内存块，在 GC 时会将这些内存块加入 GC ROOTS。

GC 可以按照回收区域进行划分：

- 部分收集（Partial GC）：只收集部分内存区域，根据收集区域的不同可以分为几类
  - **新生代收集（Minor GC/Young GC）**：指目标只是新生代的垃圾收集。
  - **老年代收集（Major GC/Old GC）**：指目标只是老年代的垃圾收集，目前只有 CMS 有单独收集老年代的行为。有时候 Major GC 又指整堆收集，需要根据具体上下文判断。
  - **混合收集（Mixed GC）**：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收 集器会有这种行为。
- 整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。

> 值得注意的是，分代收集理论也有其缺陷，最新出现（或在实验中）的几款垃圾收集器都展现出了 面向全区域收集设计的思想，或者可以支持全区域不分代的收集的工作模式。

### 3.4 回收算法

**标记-清除（Mark-Sweep）**算法是最早出现的 GC 算法，分为 “标记”、“清除” 两个阶段：

1. 首先标记出所有需要回收的对象，进行标记。
2. 对标记的对象进行回收。

![image-20210121231437611](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210121231437611.png)

> 标记-清理算法的缺点很明显，就是回收效率会由于大量可回收对象而降低，以及产生内存碎片。

**标记-复制**算法是为了解决标记-清除算法面对大量可回收对象时执行效率低的问题，其思想是划分出一块区域不分配对象，每次回收都只针对其他区域进行回收，并将存活对象拷贝到之前未分配对象的区域，这样一来也不会产生内存碎片，分配内存也只需要简单的移动堆指针即可。

![image-20210121232820249](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210121232820249.png)

HotSpot 的实现方式是采用 Eden + 2 个 Survivor 的方式实现的，默认比例为 8：1：1，也就是每次新生代中可用的容量为整个新生代容量的 90%，其中一个 Survivor 区域作为 GC 候拷贝存活对象的区域。

现实中，无法保证存活的对象一定小于 Survivor 区域的容量，当存活对象大于 Survivor 容量时，会采用 “分配担保” 的策略，这些对象会直接进入老年代。

> 标记-复制算法在对象存活率较高时需要进行较多的操作，从而降低效率，并且会浪费部分空间。

**标记-整理（Mark-Compact）**算法相对于标记-清除算法，标记过程仍然一样，后续步骤则是让存活对象向内存空间同一端移动，然后清除边界以外的内存：

![image-20210121233907323](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210121233907323.png)

>  标记-整理算法在老年代这种每次回收都有大量存活对象的区域，移动并更新所有引用的开销十分大，且需要暂停用户线程，导致 STW。

**标记-清除 会让分配对象更为复杂，而 标记-整理 会让回收对象更为复杂**。

JVM 的吞吐量实质是**赋值器**（Mutator，可以理解为使用垃圾收集的用户程序）与收集器的效率总和，由于大部分场景分配对象的频率会高于回收对象，因此使用 标记-整理 会使整体吞吐量更高，而若追求低延迟、短停顿则可以使用 标记-清除 算法。

> HotSpot 虚拟机里面关注吞吐量的 Parallel Scavenge 收集器是基于标记-整理算法的，而关注延迟的 CMS 收集器则是基于标记-清除算法的，这也从侧面印证这点。

还有一种回收方案是根据不同场景使用 标记-清除 以及 标记-整理，CMS 收集器大部分场景下使用 标记-清除 算法，当空间碎片过多时，再使用 标记-整理 算法。

> 最新的ZGC和Shenandoah收集器使用读屏障（Read Barrier）技术实现了整理过程与用户线程的并发执行。

### 3.5 算法实现细节

**根节点枚举**（从 GC ROOTS 集合查找引用链）在目前任意的垃圾收集器中都需要 STW，因此需要采取一些方案来高效实现这一过程。

目前主流的 JVM 都是使用**准确式垃圾收集**，一旦类加载动作完成，HotSpot 便会将对象内什么偏移量上是什么类型的数据计算出来，即使在 JIT 中，也会在**特定位置**记录下栈和寄存器里哪些位置是引用，HotSpot 采用 **OopMap** 这一数据结构存放这些信息，这样一来垃圾收集器就不需要扫描所有的 GC ROOTS。

---

由于导致 OopMap 内容变化的指令很多，为了减少成本，只会在特定位置生成 OopMap，这些位置称之为**安全点**。

程序必须执行到达安全点之后才能够暂停，安全点以 ”是否具有让程序长时间执行的特征“ 来进行选取，常见的有方法调用、循环跳转、异常跳转等**复用序列的指令**。

安全点需要有停顿线程（不包括 JNI 调用的线程）的能力，通常有两种方案：

- 抢先式中断，在 GC 发生时，系统把所有用户线程中断，如果发现用户线程未到达安全点，则恢复执行，过一会再中断直到到达安全点，这种方式几乎不使用。
- 主动式中断，不直接对线程中断，而是提供一个标志位给各个线程轮询，轮询标志的位置跟安全点是重合的，一旦用户线程发现标志为真，则在最近的安全点上主动中断挂起。轮询标志的位置还包括新建对象以及分配堆内存的地方，目的是为了检查是否即将发生 GC，避免内存不足。

主动式中断的轮询操作十分频繁，HotSpot 采用**内存保护陷阱**的方式，将其精简到只有一条 test 汇编指令（一次内存访问）的方式，将某个内存页置为不可读，那么线程执行到 test 时就会产生一个自陷异常信号，然后挂起线程。

---

**安全区域（Safe Region）**，可以看成是对安全点的延伸，用于应对线程在不执行（如线程处于 Sleep、Blocked 状态）的场景。

在安全区域对应的代码片段中，引用关系不会发生变化，因此在这个区域中任意地方开始 GC 都是安全的。

当线程进入了安全区域的时候，会标识自己进入了安全区域，此时 GC 不需要去管这些线程；在线程要离开安全区域的时候，则会检查虚拟机是否完成了根节点枚举，或者处于需要暂停线程的阶段。如果完成了，那么继续执行，否则等待直到收到可以离开安全区域的信号为止。

PS：哪些代码可以作为安全区域？

---

记忆集（Remembered Set）是为了解决跨代引用的问题，是一种**用于记录从非收集区域指向收集区域的指针集合的抽象数据结构**，伪代码如下：

```java
class RememberedSet {
  Object[] set[OBJECT_INTERGENERATIONAL_REFERENCE_SIZE];
}
```

这种记录全部跨代引用对象的空间占用以及维护成本十分高昂，因此可以采用更粗精度的方式来节省空间以及维护成本，常见的精度如下：

1. **字长精度**，每个记录精确到一个机器字长（就是处理器的寻址位数，如常见的32位或64位，这个精度决定了机器访问物理内存地址的指针长度），该字包含跨代指针。
2. **对象精度**，每个记录精确到一个对象，该对象里有字段含有跨代指针。
3. **卡精度**，每个记录精确到一块内存区域，该区域内有对象含有跨代指针。

第三种精度的方式称为**卡表（Card Table）**，是记忆集的一种具体实现，它定义了记忆集的记录精度、与堆内存的映射关系等。

HotSpot 使用字节数组来实现卡表标记逻辑：

```c
CARD_TABLE [this address >> 9] = 0;
```

该字节数组的每一个元素都对应了内存区域一块特定大小的内存块，这个内存块称为**“卡页”（Card Page）**。卡页大小通常是 2 的 N 次幂字节数，HotSpot 则是 512 字节。

一个卡页往往包含多个对象，只要有其中一个对象存在跨代引用，那么该卡页便会被标记为**脏页**（将数组元素的值标记为 1），之后 GC 时，只需要扫描卡表，便可以得出哪些内存块需要加入 GC ROOTS。

> 使用 byte 数组而不是 bit 数组，是因为现代计算机硬件都是按照最小字节寻址（内存页）的，使用 bit 的话需要额外消耗几条 shift + mask 指令。

---

HotSpot 使用**写屏障（Write Barrier）**是来维护卡表，在经过 JIT 后，代码只是纯粹的机器指令流了，因此需要采取机器码层面的手段，把卡表的维护操作放到每一个复制操作之中。

> 此处的 “写屏障”，以及后面在低延迟收集器中会提到的“读屏障”与解决并发乱序执行问题中的“内存屏 障”需要区分开来。

写屏障有点类似于 AOP 切面，在应用对象赋值的时候会产生一个环形（Around）通知，执行额外的动作；在赋值前的部分的写屏障叫作**写前屏障（Pre-Write Barrier）**，在赋值 后的则叫作**写后屏障（Post-Write Barrier）**。

HotSpot 的 G1 收集器出现之前，其余的收集器使用的都是写后屏障：

```c
void oop_field_store(oop* field, oop new_value) { 
  // 引用字段赋值操作
  *field = new_value;
  // 写后屏障，在这里完成卡表状态更新
  post_write_barrier(field, new_value); 
}
```

> 使用了写后屏障后，无论赋值的对象是不是跨代引用，就会产生额外的开销，但比起 Minor GC 扫描整个老年代的代价相比仍然低得多。

卡表在**高并发场景**还面临着伪共享问题，假设处理器一个缓存行大小为 64 字节，一个卡表元素占用一个字节，那么一个缓存行的卡表就对应着 32KB 的内存，一旦这块内存的对象被某个线程更新，卡表的某个元素也跟着更新，那么就会导致该缓存行其他不需要更新的卡表元素失效，从而导致性能降低。

JDK7 之后，HotSpot 提供了 `-XX:+UseCondCardMark` 来决定是否开启卡表更新的判断（默认关闭），当开启卡表更新判断时，会先对卡表是否为脏进行一次判断，一旦为脏之后，便不再对该卡表元素进行更新，从而减少伪共享发生的次数：

```c
if (CARD_TABLE [this address >> 9] != 0) 
  CARD_TABLE [this address >> 9] = 0;
```

通常在高并发场景下才开启该参数。

---

**可达性分析**中，GC ROOTS 相对整个 Java 堆中的对象数量来说算是极少数，加上 OopMap 等优化技巧，使得 GC ROOTS 的数量相对可控，并不会随着堆内存的增大而增大，但在从 GC ROOTS 继续往下遍历对象，这时遍历的耗时就会随着内存（对象数量）的增加而增大。

Q：**可达性分析为何需要在一个可以保障一致性的快照上进行对象图的遍历？**

这里借助三色标记法来解释：

- 白色：表示对象尚未被垃圾收集器访问过。
- 黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色对象是安全存活的。
- 灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。

GC ROOTS 在刚开始的时候就属于黑色的，当用户线程与收集器并发工作的时候，会产生两种后果：

1. 扫描器将某个对象标记为黑色后，用户线程断开了其引用关系，此时应该回收的对象则会漏掉（可容忍）。
2. 扫描器在灰色节点处即将遍历剩余的引用时，用户线程断开了灰色与白色对象的引用，并将白色对象链接到了已经扫描过的黑色对象，此时不应该回收的对象会被标记为白色导致错误的回收（不可容忍）。

当且仅当满足以下两个条件的时候，会产生错误的回收：

1. 赋值器插入了一条或多条从黑色对象到白色对象的新引用；
2. 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。

当前的解决方案分别有**增量更新（Incremental Update）**和**原始快照（Snapshot At The Beginning， SATB）**两种，分别破坏第一个和第二个条件。

- 增量更新：当黑色对象插入了到白色对象的新引用时，将其记录下来，在扫描完成后，将这些黑色节点作为 GC ROOTS 再一次进行扫描。
- 原始快照：当灰色对象删除指向白色对象的引用时，将其记录下来，在扫描完成后，将当时记录的关系中的灰色对象作为 GC ROOTS，再一次进行扫描，可以理解为无论引用关系删除与否，后面的二次扫描都会按照当时记录的快照进行标记。

> 以上无论是对引用关系记录的插入还是删除，虚拟机的记录操作都是通过写屏障实现的。CMS 是基于增量更新来做并发标记的，G1、Shenandoah 则是用原始快照来实现。

### 3.6 垃圾收集器

![image-20210124215321964](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210124215321964.png)

#### 3.6.1 Serial 收集器(新生代)

![image-20210124215613770](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210124215613770.png)

Serial 收集器是一个单线程工作的新生代收集器，同时还强调在进行 GC 时，必须停掉其他线程，只能有它自己一个线程运行。

Serial 收集器在小内存、单核处理器等场景，新生代内存很少超过一两百兆，GC 的停顿时间可以控制在十几、几十毫秒，其实现简单高效，内存占用少，没有线程交互的开销。在客户端模式下的虚拟机来说是一个很好的选择。

#### 3.6.2 ParNew 收集器（新生代）

![image-20210124220111760](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210124220111760.png)

ParNew 收集器实质上是 Serial 收集器的多线程并行版本，除了使用多线程进行 GC 外，其余行为与 Serial 基本一致。

ParNew 与 Serial 都是基于 HotSpot 提供的垃圾收集分代框架实现的，因此两者都能与同样是基于该框架实现的 CMS 老年代收集器配合工作。

ParNew 默认开启的收集线程数与处理器核心数量相同，为了避免小号过多的 CPU 资源，可以通过 `-XX：ParallelGCThreads` 限制 GC 的线程数。

> ParNew收集器在单核心处理器的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程 交互的开销，该收集器在通过超线程（Hyper-Threading）技术实现的伪双核处理器环境中都不能百分之百保证超越Serial收集器。

#### 3.6.3 Parallel Scavenge 收集器（新生代）

Parallel Scavenge 使用了 标记-复制 算法以及多线程，并未遵循 HotSpot 的分代框架，与 CMS 等关注延迟的收集器不同，Parallel Scavenge 更加关注吞吐量：
$$
吞吐量=\frac{运行用户代码时间}{运行用户代码时间+运行垃圾收集时间}
$$
Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量：

- `-XX：MaxGCPauseMillis`：控制最大暂停时间，降低该值是以减少新生代大小以及牺牲吞吐量为代价的。
- `-XX：GCTimeRatio`：设置吞吐量大小，默认 99，表示只允许最大 1%（1/（1+99））的 GC 时间。

Parallel Scavenge 提供了 `-XX：+UseAdaptiveSizePolicy` 参数，开启后会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。

#### 3.6.4 Serial Old 收集器（老年代）

![image-20210125212449672](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210125212449672.png)

Serial Old是Serial收集器的老年代版本，是一个单线程收集器，使用 标记-整理 算法。

- 客户端模式下
  - 老年代默认收集器
- 服务端模式下
  - JDK5 及之前的版本中与 Parallel Scavenge 搭配使用。
  - 作为 CMS 收集器在 Concurrent Mode Failure 后的后备预案。

> NOTE: Parallel Scavenge 收集器架构中本身有 PS MarkSweep 收集器来进行老年代收集,实现几乎与 Serial Old 一样。

#### 3.6.5 Parallel Old 收集器

![image-20210125212739019](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210125212739019.png)

Parallel Old 是 Parallel Scavenge 收集器的老年代版本，支持多线程并发收集，使用 标记-整理 算法实现，在 JDK6 出现，可以与 Parallel Scavenge 配合使用。

> NOTE:在 Parallel Old 出现之前，Parallel Scavenge 只能与 Serial Old 配合使用，吞吐量不一定比 ParNew + CMS 高，地位较为尴尬。

#### 3.6.6 CMS 收集器

![image-20210125214351113](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210125214351113.png)

CMS 属于 HotSpot 对低延迟垃圾收集器的一次尝试，使用了 标记-清除 算法，分为四个阶段：

1. **初始标记（CMS initial mark）**，简单的标记一下 GC ROOTS 直接关联的对象，需要 STW
2. **并发标记（CMS concurrent mark）**
3. **重新标记（CMS remark）**，使用增量更新修正并发标记过程中变动的引用关系，需要 STW
4. **并发清除（CMS concurrent sweep）**

其中除了初始标记、重新标记需要 STW 外，其余两个过程都可以与用户线程一起进行。

需要进行重新标记的原因是由于并发标记的过程中，可能出现对象引用关系的改变（参照 “三色标记法”）。

CMS 存在 3 个缺点：

1. 对处理器资源敏感，默认启动线程数为 （处理器核心数 + 3）/4 ，在处理器核心较少的时候，占用的资源比例是很高的。
2. 回收线程能够与用户线程一起运行会出现一些场景：
   - 无法处理 “浮动垃圾”（Floating Garbage），由于是在标记过程后出现的垃圾，只能留到下一次垃圾回收再处理。
   - CMS 不能等到老年代快被填满了再进行收集，需要预留部分空间给用户线程使用，通过 `-XX：CMSInitiatingOccupancyFraction` 可以设置触发 CMS 的比例，JDK6 时阈值默认为 92%，，收集期间，可能会出现留给用户线程空间不够导致 Concurrent Mode Failure，从而又触发一次后备预案的 Serial Old 的老年代收集。
3. 由于是基于 标记-清除 算法，因此也会出现内存碎片，可能导致不得不 Full GC 的情况。
   - `-XX:+UseCMSCompactAtFullCollection`，默认开启，指定 CMS 在不得不进行 Full GC 时进行内存碎片合并。
   - `-XX:CMSFullGCsBeforeCompaction`，指定 CMS 经过指定次数不整理碎片的 Full GC 后，下一次 Full GC 前会进行碎片整理，默认值为 0，表示每次都会进行碎片整理。

#### 3.6.7 Garbage First收集器

![image-20210128224407967](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210128224407967.png)

G1 收集器开创了**收集器面向局部收集**的设计思路、**基于 Region 的内存布局**、**追求能够应付应用的内存分配速率（Allocation Rate）**而非一次将整个 Java 堆清理的几个里程碑。

G1 的运作过程也可分为四个步骤（不考虑写后屏障维护记忆集的前提下）：

1. **初始标记（Initial Marking）**：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS 指针的值，让下一阶段用户线程并发运行时，能正确地在可用的 Region 中分配新对象。需要 STW，但耗时很短，而且是借用进行 Minor GC 的时候同步完成的，实际上并无额外的停顿。
2. **并发标记（Concurrent Marking）**：与用户线程一同运行，从 GC ROOTS 出发，遍历并标记需要回收的对象，扫描完成后还要重新处理**全局快照（SATB）**记录下的在并发时有引用变动的对象。
3. **最终标记（Final Marking）**：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后少量的 SATB 记录。
4. **筛选回收（Live Data Counting and Evacuation）**：负责更新 Region 的统计数据，对各个 Region 的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划（CSet），可以自由选择任意多个 Region 构成回收集，然后把决定回收的那一部分 Region 的存活对象复制到空的 Region 中，再清理掉整个旧 Region 的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。

上述过程会涉及到一些问题，需要逐个理清。

G1 基于 Region 划分内存后，可以**面向堆内存任何部分来组成回收集（Collection Set，简称 CSet）**进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的 **Mixed GC** 模式。

G1 基于 Region 划分内存后，每一个 Region 都可以根据需要扮演新生代的 Eden、Survivor 空间，或者老年代空间，收集器能够针对不同角色的 Region 采取不同的回收策略，同时还有 **Humongous** 区域用于存放大对象（对象大小超过 Region 的一半），G1 大多数行为都将其当做老年代来看待。

![image-20210128225922432](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210128225922432.png)

G1 会跟踪各个 Region 里面情况，从而可以得知回收可获得的空间以及回收所需的时间，之后在后台维护一个优先级列表，根据用户设定的允许收集暂停的时间（-XX:MaxGCPauseMillis，默认 200）来决定回收的 Region，这也是 G1 让回收时间变得可控的方式。

> NOTE：为了获得更加可靠的暂停预测模型， G1 使用了 **衰减均值（Decaying Average）** 来作为预测模型，比起整体的平均状态，衰减平均值会更容易受到最新数据的影响，从而能能够更好地代表最近的状态。

G1 对于跨 Region 引用，则是每个 Region 维护一个自己的 RSET，记录下别的 Region 指向自己的指针，并标记这些指针分别在哪些卡页的范围内。这种卡表结构是双向的（记录了我指向谁以及谁指向我），结构更为复杂，占用内存更高，G1 至少要耗费相当于 Java 堆 10% ~ 20% 的额外内存。

> NOTE:做 Minor GC 的时候，只需要扫描新生代的 RSET 即可知道 old -> young 的跨 Region 引用，减少了需要扫描的 Region。Mix GC 时，old -> old 也只需要扫描部分 old Region。

并发标记过程，G1 采用**原始快照（SATB）**来解决对象引用关系变化的过程，这个需要借助**写前屏障**来跟踪引用关系变化情况，同时 SATB 精度较低，造成的浮动垃圾较多。

> NOTE: 比起增量更新，原始快照再次标记扫描的对象更少，能够减少并发标记和重新标记阶段的消耗，避免 CSM 在最终标记阶段停顿时间过长的缺点，但在用户程序运行过程中确实会产生跟踪引用变化的额外负担。CMS 的写屏障实现是直接的同步操作，G1 则是将写前、写后屏障的事件丢到队列中异步处理。

G1 为每一个 Region 设计了两个名为 **TAMS（Top at Mark Start）** 的指针，把 Region 中的一部分空间划分出来用于并发回收过程中的新对象分配，并发标记时新分配的对象地址都必须要在这两个指针位置以上，在这个地址以上的对象是隐式标记过的，即默认存活，不纳入回收范围。

#### 3.6.8 Shenandoah 收集器

Shenandoah 收集器与 G1 收集器类似，但有主要三个不同的地方：

1. 支持并发回收时与用户线程一同进行。
2. （暂时）无分代。
3. 摒弃了 G1 的记忆集实现，改为使用 **“连接矩阵（Connection Matrix）”** 的**全局数据结构**来记录跨 Region 的引用关系。

连接矩阵可以理解为一张二维表格，如果 Region M 指向了 Region N，那么就会在该矩阵的 M 行 N 列打上一个标记：

![image-20210130184624682](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210130184624682.png)

这样一来可以减少记忆集的维护开销（**去掉了写后屏障**），二来可以避免伪共享发生的概率。

Shenandoah 可以细分为九个阶段

1. 初始标记：十分短暂的 STW，标记 GC ROOTS 直接关联的对象。
2. **并发标记**：与用户线程一起工作，标记出全部可达对象。
3. 最终标记：十分短暂的 STW，使用 SATB 解决对象引用关系变化问题，同时统计回收价值得出 CSet。
4. 并发清理：清理一个存活对象都没有的 Region，这类 Region 称为 Immediate Garbage Region。
5. **并发回收（核心差异）**：复制存活对象到其他 Region，通过**读屏障**和 **“Brooks Pointers”** 的转发指针来解决与用户线程一同工作遇到的问题。
6. 初始引用更新：十分短暂的 STW，未做具体的处理，只是建立一个线程集合点，确保所有并发回收阶段中进行的收集器线程都已完成分配给它们的对象移动任务。
7. **并发引用更新**：真正的引用更新操作，按照物理内存地址线性地搜索出**引用类型**，把旧值改成新值。
8. 最终引用更新：最后一次短暂的 STW，时间与 GC ROOTS 有关，修正 GC ROOTS 中的引用。
9. 并发清理：经过并发清理与引用更新后，回收 Immediate Garbage Region。

并发回收阶段，回收线程与用户线程一同进行，需要解决几个问题，首当其冲就是复制存活对象到其他 Region 时，要如何保证用户线程能够正确找到移动后的对象。

通常都是做一个转发来解决这个问题，传统的解决方案实在原有内存上设置一个**内存保护陷阱（Memory Protection Trap）**，用户线程一旦访问到该内存就会产生**自陷中断**，从而进入预设好的异常，再按照设置好的代码逻辑转发到复制好的对象上，但这种方法会**产生频繁的用户态——内核之间的切换**。

Brooks 提出的方案则是摒弃内存保护陷阱，在对象布局的最前面统一添加一个新的引用字段，平时指向自身，一旦复制到了新的 Region 中，引用则改为指向新的复制对象（类似句柄，但句柄实在一块统一的内存空间上）。

> NOTE：这个转发尽管被优化为了一行汇编指令，但由于对象定位使用频率很高，执行成本并不低。

![image-20210130193122309](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210130193122309.png)



**用户线程对对象的修改，很有可能发生在 GC 线程复制对象、修改指针之间**，因此要考虑一个并发问题，同一时间用户线程对转发指针的访问、GC 线程只有一个能成功，另一个必须等待，实际上，Shenandoah 也是借助 CAS 来保证并发时对象的访问正确性。

为了实现 Brooks Pointer，Shenandoah在读、写屏障中都加入了额外的转发处理，尤其是使用读屏障的代价，这是比写屏障更大的。数量庞大的读屏障会成为性能瓶颈的关键点之一，因此 Shenandoah 计划后续（JDK 13）将内存屏障模型改进为**引用访问屏障（Load Reference Barrier）**，只拦截对象中数据类型为引用类型的读写操作，而不管原始数据类型等其他非引用自断的读写。

Shenandoah 收集器存在的几个问题：

1. 写屏障、读屏障会产生一定的开销，尤其是读屏障的使用频率远远大于写屏障。
2. 浮动垃圾较多，且在引用更新完成之前，Region 无法释放。

https://ionutbalosin.com/2019/12/jvm-garbage-collectors-benchmarks-report-19-12/

https://developers.redhat.com/blog/2019/06/28/shenandoah-gc-in-jdk-13-part-2-eliminating-the-forward-pointer-word/

#### 3.6.9 ZGC 收集器

ZGC 作为一款低延迟收集器，实现思路与 Shenandoah 有较大差异，主要体现在其使用了**染色指针**、读屏障以及**内存多重映射**等技术来实现标记-整理算法，并且以**低延迟**为首要目标。

ZGC 也是一款基于 Region 的收集器：

- 小型 Region：容量固定为2MB，用于放置小于 256KB 的小对象。
- 中型Region（Medium Region）：容量固定为 32MB，用于放置大于等于 256KB 但小于 4MB 的对象。
- 大型Region（Large Region）：容量不固定，可以动态变化，但必须为 2MB 的整数倍，用于放置 4MB 或以上的大对象，可能小于中型 Region。大型 Region 在 ZGC 中不会被**重分配**。

ZGC 使用**染色指针技术（Colored Pointer）**实现了并发回收阶段与用户线程一同工作，通过在指针（而非对象）的高 4 位上存储一些额外信息，从而无需访问对象即可获得对象的一些信息，此时可达性分析更像是遍历 “引用图” 而非对象图。

> NOTE：受限于现代工艺、性能和成本等条件制约，当前 AMD64 架构只支持到 52位（4PB）的地址总线和 48位（256TB）的虚拟地址空间， Linux 64 位系统最高只支持到 47位（128TB）的进程虚拟机地址空间和 46位（64TB）的物理地址空间。ZGC 占用了高 4 位，因此最多只能管理 4TB 的内存空间，同时不支持 32 位平台，不支持指针压缩。

通过这些标志位，虚拟机可以直接从指针中看到其引用对象的三色标记状态、是否进入了重分配集（即被移动过）、是否只能通过finalize()方法才能被访问到：

![image-20210131155330760](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210131155330760.png)

染色指针的优势：

- 染色指针使得一旦某个 Region 的存活对象被移走之后，就能够立刻释放和重用，理论上只要还有一个空闲的 Region，就能够完成收集。
- 染色指针可以大幅减少 GC 过程中屏障的使用数量，因为信息直接维护在指针中，当前 ZGC 只使用了读屏障实现用户线程对移动后对象的正确读取（写屏障之所以未用到是因为还未支持分代，跨 Region 引用也是通过扫描所有 Region 而非维护记忆集）。
- 染色指针可以作为一种**可扩展**的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后可以利用指针剩余的位数，进一步提高性能。

使用染色指针存在的一个问题是，操作系统并不会特殊对待染色指针，而是将其当做一个普通的引用指针来对待，因此需要 ZGC 对其做一定的转换，这里涉及到了虚拟内存映射技术。

不同层次的虚拟内存到物理内存的转换关系可以在硬件层面、操作系统层面或者软件进程层面实 现，如何完成地址转换，是一对一、多对一还是一对多的映射，也可以根据实际需要来设计。

Linux x86_64 平台上的 ZGC 使用了**多重映射（Multi-Mapping）**将多个不同的虚拟内存地址映射到同一个物理内存地址上，这是一种多对一映射,因此 ZGC 实际看到的虚拟内存会比堆内存大得多。

ZGC 会把染色指针中的标志位看作是地址的分段符，那只要将这些不同的地址段都映射到同一个物理内存空间，经过多重映射转换后，就可以使用染色指针正常进行寻址了：

![image-20210131161444939](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210131161444939.png)

ZGC 的运行过程可以分为四个大阶段：

![image-20210131161609479](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210131161609479.png)

1. 初始标记：同 G1、Shenandoah。
2. **并发标记（Concurrent Mark）**：同 G1、Shenandoah，只不过标记是在指针上进行，最后也有短暂的最终标记。
3. **并发预备重分配（Concurrent Prepare for Relocate）**：根据特定的查询条件统计得出要清理的 Region，组成**重分配集（Relocation Set）**，与 G1 不同的是并没有所谓的优先级队列，并非针对某个 Region,而是扫描全部 Region，决定出哪些存活对象需要移动到其他 Region。
4. **并发重分配（Concurrent Relocate）**：核心阶段，这个过程要把重分配集中的存活对象复制到新的 Region 上，并为重分配集中的每个 Region 维护一个**转发表（Forward Table）**，记录从旧对象到新对象的转向关系。若此期间用户线程**首次**访问了位于重分配集中的对象，就会被读屏障所截获，然后**根据 Region 的转发表将访问转发到新复制的对象上，并更新该引用（实现 “自愈”）**。之后如果存活对象都复制完成了，那么该 Region 便可以立即释放，但转发表还得保留，应对后面用户线程的访问。
5. 并发重映射（Concurrent Remap）：类似于 Shenadoah 的并发引用更新阶段，修正整个堆中指向重分配集中旧对象的所有引用，但鉴于染色指针的 “自愈” 特性，这个阶段优先级并不高，实际上 ZGC 而是将其合并到下一次 GC 中的并发标记阶段去完成的，一旦所有指针都修正之后，转发表便可以释放了。

ZGC 使用存在的几个问题：

1. ZGC 若要利用剩余的指针位数，需要操作系统支持，并且 JVM 作为一个普通的系统进程，修改操作系统的指针访问方式是否合适仍需权衡。
2. ZGC 没有实现分代以及记忆集，在并发标记阶段，若果新生成的对象很多，这部分对象只能留到下一次 GC 时再处理，即 ZGC 所能承受的对象分配速率不会很高，只能通过增大内存来缓解该现象。

#### 3.6.10 Epsilon 收集器

JDK11 出现的一款无收集行为的收集器，其实是顺应了微服务化、无服务化方向发展的趋势，由于 Java 占用内存较大，在容器中启动时间长，JIT 优化缓慢等，对于短时间、小规模的服务有诸多不适，因此出现了 提前便已、面向应用的类数据共享等技术。

Epsilon 也是有着类似的目标，如果应用只需要运行数分钟甚至数秒，只要 JVM 有足够内存，在堆耗尽之前就会推出，那么运行负载小，没有任何回收行为的 Epsilon 便很合适。

#### 3.6.11 总结

从最新的两款 GC 收集器来看，都是实现了并发回收阶段与用户线程同时进行的技术，同时都将 STW 阶段变得与堆内存大小无关。

- 写后屏障：Serial、CMS、Parallel
- 写前屏障 + 写后屏障：G1
- 读屏障 + 写前屏障：Shenandoah
- 读屏障：ZGC

关于 GC 收集器的选择，需要根据具体场景权衡：

1. 如果能够掌控软硬件型号，有特别注重延迟，那么选择 ZGC。
2. 如果对处于实验性质的收集器稳定性有顾虑，或者必须使用 win 系统，那么可以考虑选择 Shenandoah 收集器。
3. 如果属于遗留系统，基础设置较为落后，对于 4GB ~ 6GB 的内存，那么可以考虑 CMS 以及 Parallel（支持 NUMA-WARE）。
4. 如果内存大于 6GB，那么可以考虑 G1 收集器。

### 3.7 JVM 以及 GC 日志

JDK9 之前，JVM 以及 GC 收集器的日志是一系列人为的规则，并没有统一的规范， JDK9 开始，HotSpot 将所有的日志功能都归到了 `-Xlog` 参数上：

```bash
-Xlog[:[selector][:[output][:[decorators][:output-options]]]]
```

最关键的是 `selector`，由标签（tag）和日志级别（Level）组成，标签可以理解为摸个功能模块的名字，包括 `gc` 也是其中一个模块，HotSpot 支持的模块如下：

```bash
add，age，alloc，annotation，aot，arguments，attach，barrier，biasedlocking，blocks，bot，breakpoint，bytecode
```

修饰器 decorators 用于指定额外输出的内容

- time：当前日期和时间。
- uptime：虚拟机启动到现在经过的时间，以秒为单位。
- timemillis：当前时间的毫秒数，相当于System.currentTimeMillis()的输出。
- uptimemillis：虚拟机启动到现在经过的毫秒数。
- timenanos：当前时间的纳秒数，相当于System.nanoTime()的输出。
- uptimenanos：虚拟机启动到现在经过的纳秒数。
- pid：进程ID。
- tid：线程ID。
- level：日志级别。·tags：日志输出的标签集。

默认输出 uptime、level、tags 三个。

查看GC基本信息，在 JDK9 之前使用 `-XX:+PrintGC`，JDK9后使用 `-Xlog:gc`：

```bash
bash-3.2$ java -Xlog:gc GCTest [0.222s][info][gc] Using G1
[2.825s][info][gc] GC(0) Pause Young (G1 Evacuation Pause) 26M->5M(256M) 355.623ms [3.096s][info][gc] GC(1) Pause Young (G1 Evacuation Pause) 14M->7M(256M) 50.030ms [3.385s][info][gc] GC(2) Pause Young (G1 Evacuation Pause) 17M->10M(256M) 40.576ms
```

### 3.8 内存分配与回收策略

在经典的分代理论中，新对象通常是在堆上的 Eden 区分配的，少数情况（例如对象大小超过一定阈值）也可能直接分配在老年代，分配的规则不是固定的，取决于 JVM 自身的实现，Java 虚拟机规范也未对这块做出详细规定。

新对象总是优先分配在 Eden 区，如果后续分配对象时，Eden 区没有足够的内存了，而 Minor GC 又回收不了多少内存，则会触发担保分配，直接分配在 Old 区：

```java
private static final int _1MB = 1024 * 1024; 
/**
 * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 */
public static void testAllocation() {
	byte[] allocation1, allocation2, allocation3, allocation4;
	allocation1 = new byte[2 * _1MB];
	allocation2 = new byte[2 * _1MB];
	allocation3 = new byte[2 * _1MB];
	allocation4 = new byte[4 * _1MB];  // 出现一次Minor GC 
	}
```

> [GC [DefNew: 6651K->148K(9216K), 0.0070106 secs] 6651K->6292K(19456K), 0.0070426 secs] [Times: user=0.00 secs]
>
> Heap
> 	def new generation   total 9216K, used 4326K [0x029d0000, 0x033d0000, 0x033d0000)
>
> ​		eden space 8192K,  51% used [0x029d0000, 0x02de4828, 0x031d0000)
>
> ​		from space 1024K, 14% used [0x032d0000, 0x032f5370, 0x033d0000) 
>
> ​		to space 1024K, 0% used [0x031d0000, 0x031d0000, 0x032d0000)
> ​	tenured generation   total 10240K, used 6144K [0x033d0000, 0x03dd0000, 0x03dd0000)
>
> ​		the space 10240K,  60% used [0x033d0000, 0x039d0030, 0x039d0200, 0x03dd0000)
> ​	compacting perm gen  total 12288K, used 2114K [0x03dd0000, 0x049d0000, 0x07dd0000)
> ​		the space 12288K,  17% used [0x03dd0000, 0x03fe0998, 0x03fe0a00, 0x049d0000)
> No shared spaces configured.

大对象可以设定一个阈值 `-XX:PretenureSizeThreshold`，超过该阈值时直接分配在 Old 区，表面在 Eden、Survivor 来回拷贝，产生大量开销，

> NOTE: -XX:PretenureSizeThreshold 只对 Serial 以及 ParNew 两款新生代收集器有效。

```java
private static final int _1MB = 1024 * 1024; 
/**
 * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 * -XX:PretenureSizeThreshold=3145728
 */
public static void testPretenureSizeThreshold() { 
	byte[] allocation;
	allocation = new byte[4 * _1MB];  //直接分配在老年代中 
  }
```

> Heap
> 	def new generation   total 9216K, used 671K [0x029d0000, 0x033d0000, 0x033d0000) 
>
> ​		eden space 8192K,   8% used [0x029d0000, 0x02a77e98, 0x031d0000)
> ​		from space 1024K, 0% used [0x031d0000, 0x031d0000, 0x032d0000) 
>
> ​		to space 1024K, 0% used [0x032d0000, 0x032d0000, 0x033d0000)
> ​	tenured generation   total 10240K, used 4096K [0x033d0000, 0x03dd0000, 0x03dd0000)
> ​		the space 10240K,  40% used [0x033d0000, 0x037d0010, 0x037d0200, 0x03dd0000)
> ​	compacting perm gen  total 12288K, used 2107K [0x03dd0000, 0x049d0000, 0x07dd0000)
> ​		the space 12288K,  17% used [0x03dd0000, 0x03fdefd0, 0x03fdf000, 0x049d0000)
> No shared spaces configured.

长期存活的对象会进入老年代，JVM 为每个对象设置了一个计数器（存在于对象头），如果一个对象经过一次 Minor GC 后仍存活，计数器 + 1，当达到最大阈值 15 时，就会晋升到老年代。

晋升年龄可以通过 `-XX:MaxTenuringThreshold=1` 来指定，但为了适应不同程序的内存状况，HotSpot 实际上会动态修改该值，**如果 Survivor 中相同年龄的所有对象大小大于 Survivor 中的一半**，则年龄大于或等于该年龄的对象就可以直接进入老年代。

JDK 6 Update 24 之前的**空间分配担保**，在发生 Minor GC 之前，JVM 必须检查老年代**最大可用的连续空间**是否大于新生代所有对象总空间：

- 如果这次条件成立，那么可以放心的进行 Minor GC。
- 否则，检查是否允许担保失败 `-XX:HandlePromotionFailure`
  - 如果不允许，则直接进行 Full GC
  - 如果允许，则检查**老年代剩余最大可用的连续空间是否大于历次晋升的平均大小**，再决定是否尝试进行一次有风险的 Minor GC。

JDK 6 Update 24 之后则是直接检查老年代剩余最大可用的连续空间是否大于新生代对象总大小或者历次晋升的平均大小，是则进行 Minor GC，否则直接 Full GC。

## 第四章 虚拟机性能监控、故障处理工具

给一个系统定位问题的时候，知识、经验是关键基础，数据是依据，工具是运用知识处理数据的手段。

大多数工具，都需要 JVM 自身开启 RMI、JMX，以及最新的 JMC 需要 JVM 开启 JFR 配合工作。

### 4.1 基础故障处理工具

**jps**：虚拟机进程状况工具，可以列出正在运行的 Java 进程，并显示一些相关的描述信息，语法格式为 `jps [ options ] [ hostid ]`，其中的 option 如下：

- -q：只输出 LVMID，省略主类名称。
- -m：输出 JVM 启动时传递给主类 main()　函数的参数。
- -l：输出主类的全名，如果是 Jar 包则输出 Jar 路径。
- -v：输出 JVM 启动时的 JVM 参数。

**jstat**：用于监视 JVM 运行状态信息的工具，可以显示本地或者远程虚拟机（需远程开启 RMI）的类加载、内存、GC、JIT 等运行时数据，语法格式为 `jstat [ option vmid [interval[s|ms] [count]] ]`，其中的 option 如下：

- -class：监视类加载、卸载数量，总空间以及类装载所耗费的时间。
- -gc：监视 Java 堆各个分代区域的容量、已用空间、GC 时间等统计信息。
- -gccapacity：类似于 -gc，但主要关注 Java 各个分代区域使用到的最大、最小内存空间。
- -gcutil：类似于 -gc，但主要关注 Java 各个分代区域已用内存空间的百分比。
- -gccause：与 -gcutil 类似，但会额外输出导致上一次 GC 的原因。
- -gcnew：监视新生代 GC 情况。
- -gcnewcapacity：类似于 -gcnew，但主要关注新生代使用到的最大、最小内存空间。
- -gcold：监视老年代 GC 情况。
- -gcoldcapacity：类似于 -gcold，但主要关注老年代使用到的最大、最小内存空间。
- -compile：输出即时编译过的方法、耗时等信息。
- -printcompilation：输出已经被即时编译的方法。

jstat 监控的信息主要可以分为三类：**类加载、GC、运行期编译状态**。

> NOTE：如果是本地进程，LVMID 与 VMID 是一致的，如果是远程进程，则 VMID 的格式是 `[protocol:][//]lvmid[@hostname[:port]/servername]`。

**jinfo**：可以实时查看和调整 JVM 的各项参数，使用 `jps -v` 可以查看 JVM 启动时指定的参数，但如果想看一些隐式指定的参数，就得借助 jinfo 了，语法格式为 `jinfo [ option ] pid`。jinfo 也可以使用 `-flag (+|-)name` 或者 `-flag name=value` 来修改部分运行期可以修改的参数。

> NOTE： jinfo 可以使用 `-sysprops` 打印出 JVM 的 `System.getProperties()` 内容。

**jmap**：可以用于查看堆内存布局详细信息，也可以用于生成堆转储快照，同时也可以查询 finalize 执行队列，语法格式为 `jmap [ option ] vmid`，option 的选项如下：

- -dump：生成 Java 对转出快照，格式为 `-dump:[live,]format=b,file=<filename>`,live 表示是否只 dump 出存活对象。
- -finalizerinfo：显示在 F-Queue 中等待 Finalizer 线程执行 finalize 方法的对象。
- -heap：显示 Java 堆详细信息。
- -histo：显示堆中对象信息统计，包括类、实例数量、合计容量。
- -permstat（过时）：以 ClassLoader 为口径统计永久代内存状态，jdk8 取消永久代后改为 `-clstats`。

**jstack**：用于生成 JVM 当前时刻的线程快照，语法格式为 `jstack [ option ] vmid`，option 如下：

- -F：当前请求不响应时，强制输出线程堆栈。
- -l：显示关于锁的附加信息。
- -m：如果调用到本地方法的话，显示 C/C++ 堆栈。

> NOTE：JDK5 开始 java.lang.Thread 新增了一个 `getAllStackTraces()` 方法用于获取 JVM 中所有线程的 StackTraceElement 对象，可以用这个方法做个简单的管理页面。

### 4.2 可视化故障处理工具

#### 4.2.1 JHSDB

JHSDB、JCMD 有着后发优势，能够做的比之前的老工具更好：

![image-20210206154626125](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210206154626125.png)

```java
/**
* staticObj、instanceObj、localObj存放在哪里？ */
public class JHSDB_TestCase {
	static class Test {
		static ObjectHolder staticObj = new ObjectHolder(); 
		ObjectHolder instanceObj = new ObjectHolder();
		void foo() {
			ObjectHolder localObj = new ObjectHolder(); 
			System.out.println("done");    // 这里设一个断点
		} 
	}
		private static class ObjectHolder {} 
		public static void main(String[] args) {
			Test test = new JHSDB_TestCase.Test(); 
			test.foo();
		}
}
```

JHSDB 开启图形化界面：`jhsdb hsdb --pid <pid>`:

![image-20210206204843326](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210206204843326.png)

- `Tools->Heap Parameters`：可以看到不同 GC 收集器下内存布局的信息。
- `Windows->Console`：根据前一个信息，扫描某段内存中的实例 `canoops 0x00007f32c7800000 0x00007f32c7b50000 JHSDB_TestCase$ObjectHolder`。
- `Tools->Inspector`：填入扫描到的某个对象的虚拟内存地址，可以看到存放的对象。

#### 4.2.2 JConsole： Java监视与管理控制台

`JConsole` 是一款基于 JMX（Java Management Extensions）的可视化监视、管理工具，通过 JMX 的 MBEAN（Managed Bean）对系统进行信息收集以及参数动态调整。

启动 JConsole 后会自动搜索所有的 Java 进程，通过下拉框选择进程即可。

JConsole 可以监控内存、线程等信息：

![image-20210206210726194](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210206210726194.png)

#### 4.2.3 VisualVM：多合-故障处理工具

VisualVM 是一个多合一工具，通常插件方式实现，且对程序影响小，还可以分析程序性能（这部分对程序性能有影响）。

> JDK5 之后，VisualVM 的 Profiler 功能会因为类共享而导致被监视的应用程序崩溃，所以进行 Profiling 前，最好在被监视程序中使用 `-Xshare:off` 参数来关闭类共享优化。

**BTrace** 是一个很强大的运行时工具，借助 HotSpot 虚拟机的 Instrument 功能，在不中断程序的前提下，动态加入原本并不存在的调试代码。

以下面的代码为例：

```java
public class BTraceTest {
	public int add(int a, int b) { return a + b; }
	public static void main(String[] args) throws IOException { 
		BTraceTest test = new BTraceTest();
		BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); 		  for (int i = 0; i < 10; i++) {
			reader.readLine();
			int a = (int) Math.round(Math.random() * 1000); 
			int b = (int) Math.round(Math.random() * 1000);
			System.out.println(test.add(a, b));
		}
	}
}
```

安装插件后，切换到该插件标签页：

![image-20210206212728561](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210206212728561.png)

之后输入以下调试代码：

```java
/* BTrace Script Template */
import com.sun.btrace.annotations.*;
import static com.sun.btrace.BTraceUtils.*;
@BTrace
public class TracingScript {
	@OnMethod(
	clazz="org.fenixsoft.monitoring.BTraceTest", method="add",
	location=@Location(Kind.RETURN) 
	)
	public static void func(@Self org.fenixsoft.monitoring.BTraceTest instance,int a, int b,@Return int result) {
		println("调用堆栈:");
		jstack();
		println(strcat("方法参数A:",str(a)));
		println(strcat("方法参数B:",str(b)));
		println(strcat("方法结果:",str(result))); 
	}
}
```

之后点击 Start 按钮片刻后，等待编译完成即可看到输出信息：

![image-20210206213016459](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210206213016459.png)

> NOTE：阿里巴巴的 Arthas 也通过 Instrument 实现了与 BTrace 类似的功能。

#### 4.2.4 Java Mission Control：可持续在线的监控工具

JMC 可以和 JFR（Java Flight Recorder）结合使用。

JFR 是一套内建在 HotSpot 里面的监控和基于事件的信息搜集框架，对生产环境中吞吐量的影响一般不会高于 1%。JFR 的开始、停止都可以动态修改，且不需要重启应用。

JMC 与 JVM 是基于 JMX 协议通信的，可以作为 JMX 的控制台，展示 MBean 的信息，也可以展示 JFR 的数据。

被监控的 JVM 进程需要开启并指定一些 JMX 以及 JFR 的配置：

```bash
-Dcom.sun.management.jmxremote=true
-Djava.rmi.server.hostname=192.168.31.4
-Dcom.sun.management.jmxremote.port=9999
-Dcom.sun.management.jmxremote.ssl=false
-Dcom.sun.management.jmxremote.authenticate=false
-XX:+UnlockCommercialFeatures -XX:+FlightRecorder
```

JFR 对比 MBean，收集到的数据质量更高，以 GC 为例，MBean 只可以收集到一个 GC 的结果，而 JFR 还可以看到内存中这段时间分配了哪些对象、哪些在TLAB中（或外部）分配、分配速率 和压力大小如何、分配归属的线程、收集时对象分代晋升的情况等，这些就是属于 “过程” 类的信息。

JFR的基本工作逻辑是开启一系列事件的录制动作，当某个事件发生时，这个事件的所有上下文数据将会以循环日志的形式被保存至内存或者指定的某个文件当中，循环日志相当于数据流被保留在一个环形缓存中。

> NOTE：环形缓冲区（Ring Buffer）通过在一个连续内存的数组上添加读、写指针，实现空间循环使用的高性能数据结构。

## 第五章 调优案例分析与实战

大内存硬件的程序部署策略：

- 在可以使用较新软硬件的时候，使用增量式 GC 是很值得优先考虑的方案。
- 如果无法升级到较新的 JDK，则需要确保 Full GC 的频率非常低，否则一次停顿，就会导致应用假死。
  - 如果无法实现 Full GC 频率很低，则考虑拆分为多个小堆应用 + 负载均衡转发器的架构。

**集群间同步导致的 OOM**：

- 需要考虑集群间同步信息时，一旦网络情况不足以满足交互需求，则会导致数据在内存中不断堆积，导致 OOM。
- 应用与**非集中式缓存**（如 JBossCache）交互的时候，一旦有大量写操作，就会导致缓存之间需要同步交互的次数非常频繁。

**堆外内存溢出**：

- 堆外缓存在 OOM 的时候，会发现 dump 出的文件内容并没有多少。
- 对外内存只有在应用 Full GC 时才有机会回收。

小内存以及 32 位应用除了 Java 堆以及方法区之外，其他区域的内存占用往往也不小，主要是**受到操作系统的 32 位进程最大内存的限制**：

- 直接内存，可通过 -XX:MaxDirectMemorySize 限制大小，内存不够时抛出 OOM。
- 线程堆栈，可通过 -Xss 调整大小，栈深度超过最大深度时抛出 StackOverflowError，栈容量动态扩展内存不够时则抛出 OOM。
- Socket 缓冲区，每个 Socket 链接都有 Receive 和 Send 两个缓冲区，分别占大约 37KB 和 25KB 内存，连接多时这块内存占用也比较可观。
- JNI 代码，本地使用的内存不算在堆中，而是占用 JVM 的本地方法栈以及本地内存。
- JVM、GC 收集器的工作也需要小号一定数量的内存。

> NOTE：由于系统制约， Windows 平台下单个 32 位 JVM 进程最多只能分配到 2GB 内存，并且堆内内存跟堆外内存会共享这部分内存。

**外部命令调用**： Java 的 `Runtime.getRuntime().exec()` 调用外部脚本，会先复制一个和当前 JVM 拥有一样环境的进程，再用这个新的进程去执行外部命令，非常消耗资源。

**长时间不进入安全点**：JVM 为了减少安全点对性能带来的负担，对于计数循环会有一项优化措施，就是当循环的索引为 int 类型的时候，会认为该循环执行的时间并不太长，也就不会在循环里生成安全点。可以通过 