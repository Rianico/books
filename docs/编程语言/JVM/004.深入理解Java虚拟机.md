---
title: 深入理解 Java 虚拟机
date: 2020-02-19
---

## 深入理解 Java 虚拟机

[toc]

## 第二章 自动内存管理

### 2.1 运行时数据区域

- **程序计数器**：一块很小的内存空间，用于指出下一条需要执行的指令。JVM 规范中，字节码解释器就是通过改变这个计数器来选取下一条需要执行的指令，是程序控制流的指示器，线程私有。
- **Java 虚拟机栈**：线程私有，生命周期与线程一致，用于描述 Java 方法执行的线程内存模型。
  - 执行方法调用时，JVM  会同步创建一个**栈帧（Stack Frame）**，存储了**局部变量表**，**操作数栈**、动态链接、方法出口等信息。
    - 局部变量表：存放了编译期可知的 8 种基本类型、对象引用、returnAddress 类型。
    - 局部变量表以**槽（Slot）**来表示存储空间，long、double 类型需要占用两个槽，至于一个槽对应多大内存空间由 JVM 具体实现决定。
    - 以 slot 为粒度，可以在编译期就确定局部变量表所需内存大小。
  - 每一个方法的调用直至结束，对应一个栈帧在 Java 虚拟机栈中入栈出栈的过程。
  - 栈深度超过允许的深度时将抛出 **StackOverflowError** 异常，无法申请足够的内存时则是 **OutOfMemoryError** 异常。
- **本地方法栈**：与 Java 虚拟机栈类似，为本地方法调用服务。
- **Java 堆**：属于共享内存，存在的唯一目的就是存放对象实例，几乎所有对象都在堆上分配（标量替换、栈上分配等一些优化技术除外）。
  - Java 会根据对象生命周期特色划分为新生代、老年代等，这种只是属于一种设计风格，并非 JVM 规范强制规定。
  - 分配内存时，可以在堆中划分出多块线程私有的 TLAB 来提高对象分配效率。
- **方法区**：线程共享，用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。
  - JVM 规范将其描述为堆的一个**逻辑部分**，别名**“非堆”（Non-Heap）**。
  - 方法区不等于 “永久代（Permanent Generation）”，只是 HotSpot 最先开始使用了永久代来实现方法区。
    - JDK 7 开始，**字符串常量池、静态变量等从方法区移出到堆中**。
    - JDK 8 开始取消了永久代，改为采用**本地内存（Native Memory）**实现，称为元**空间（Meta-space）**，并**将永久代剩余的内容（主要是 class 信息、运行时常量池）全部移到元空间中**。
  - **运行时常量池（Runtime Constant Pool）**是方法区的一部分：
    - Class 文件有一个**常量池表（Constant Pool Table，class 常量池）**，用于存放编译期生成的各种字面量与符号引用，**在类加载后会存放到方法区的运行时常量池中**；
    - Class 文件中的符号引用解析为直接引用后，也会存储在运行时常量池；
    - 具备动态性，允许在运行时往里（字符串常量池）添加新内容，如 String 类的 `intern()` 方法；
    - JDK 8 位于元空间中。
- **直接内存（Direct Memory）**：并非 JVM 运行时数据区的一部分，在 JVM 规范中也并未定义，但是随着 JDK 1.4 添加的 NIO 出现，采用了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式。JVM 通过操作堆里一个 `DirectByteBuffer` 来操作本地（堆外）内存，默认不对这块内存大小做限制，所以可能会超出本机物理内存大小，导致 OOM。

### 2.2 对象

#### 2.2.1 对象的新建

对象的创建（复制、序列化除外）通常对应一条 new 指令：

- 先到常量池寻找某个类的符号引用
  - 如果未加载，则执行加载、解析、初始化。
- 为对象分配内存，内存大小在加载完成便已经可以确定，不同的内存空间划分方式：
  - **指针碰撞（Bump The Pointer）**，只需要移动指针分配内存即可，要求 JVM 内存规整，内存规整取决于采用的 GC 算法是否带**空间压缩整理（Compact）**功能，如 Serial、ParNew 算法。
  - **空闲列表（Free List）**，维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，如 CMS 算法。
  - 除了划分空间外，还需要考虑分配对象时的线程安全，通常采用：① CAS 方式保证更新操作的原子性；② 使用 TLAB  解决，默认开启。
- 内存分配完后，会将分配的内存空间（不包含对象头）初始化为零值，如果有使用 TLAB 也可以提前到 TLAB 阶段初始化。这一步可以保证程序能够访问到字段数据类型对应的零值
- 对对象进行一些必要的设置：对象属于哪个 class、如何定位 class 的元数据信息、对象哈希码（实际会到调用 `Object::HashCode()` 方法时才计算)、是否启用偏向锁等。

上述步骤后，从 JVM 角度来看，一个新的对象已经产生了，而从 Java 程序的角度来看，还需要执行 `<init>`  方法，按照程序定义的流程进行初始化，这样才算是一个真正可用的对象。

> CMS 为了在大多数场景下更快的分配对象，设计了一个叫作 Linear Allocation Buffer 的分配缓冲区，通过空闲列表拿到一大块分配缓冲区之后，在里面仍然可以使用指针碰撞方式来分配。

#### 2.2.2 对象的内存布局

Java 对象从内存布局上可以分为三块：**对象头**（Object Header）、**实例数据**（Instance Data）和**对齐填充**（Padding）。

对象头包含两类信息：

1. 存储对象自身的运行时信息 **Mark Word**，存储了如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等。

![image-20210513221714960](https://gitee.com/zhxuankun/Image/raw/master/Avator/image-20210513221714960.png)

2. **类型指针**，指向实例对象的类型元数据，JVM 通过这个指针来确定对象是属于哪个类的实例。

> NOTE：64bit JVM 下，类型指针可以通过开启指针压缩减小到 32 bit，但仅限 JVM 内存 小于 32 G 的场景。

实例数据存储了对象真正的有效信息，子类也会为父类字段分配内存，字段之间的排序也存在一定规则，受到 JVM 参数 `-XX：FieldsAllocationStyle` 影响，默认分配顺序为 longs/doubles、ints/floats、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers，OOPs），父类定义的字段会排在子类之前，如果开启了 ` +XX：CompactFields`（默认开启），那子类之中较窄的变量也允许插入父类变量的空 隙之中，以节省出一点点空间。

对齐填充，并非必选，仅存在着占位作用，用于对象对齐（默认 8 字节）。

#### 2.2.3 对象的访问定位

Java 虚拟机规范规定了 reference 类型是用于指向对象的一个引用，但并未规定具体实现细节，常见的实现方式有两种：

1. 句柄访问，Java 堆中可能划分出一块内存用于存放句柄来作为句柄池，reference 存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息，这种方式需要做一次转发。

   ![](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/Snipaste_2021-01-10_15-39-52.png)
   
   2. 直接访问，reference 直接存储了对象的地址，这种方式下实例对象的内存布局需要考虑如何存放类型数据的相关信息，但可以减少一次转发。
   
      ![image-20210110193141447](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210110193141447.png)
   
   > HotSpot 采用了直接访问的方式。

### 2.3 OutOfMemoryError 异常

Java 堆溢出，可以通过 `-XX：+HeapDumpOnOutOfMemoryError` 指定 OOM 时 dump 当前的内存快照，便于后续分析。

虚拟机栈和本地方法栈较为特别，Java 虚拟机规范规定如下：

1. 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出 StackOverflowError 异常。
2. **如果虚拟机的栈内存允许动态扩展**，当扩展栈容量无法申请到足够的内存时，将抛出 OutOfMemoryError异常。

由于 HotSpot 不支持栈内存扩展，所以**只有在创建线程时无法申请到足够的内存才会抛出 OOM 异常**，否则在线程运行时是不会因为扩展而导致 OOM 的（第二点）。

因此 HotSpot 只会在栈容量无法容纳新的栈帧时才会抛出 StackOverflowError 异常（第一点）。

>  当在正常业务场景下遇到 StackOverflowError 异常，在无法增加内存资源，又无法减少需要创建的线程的时候，可以考虑通过减小栈容量（-Xss）以及堆最大内存，来换区更多可创建的线程。

方法区溢出，需要考虑 JDK 6、JDK 7、JDK 8 这三种不同的场景，由于方法区在这三个版本的 JDK 中都做过调整，因此不同 JDK 关于方法区溢出的现象是不一样的。

1. 在 JDK 6 中，如果通过 `String.intern()` 来一直添加字符串到字符串常量池中，那么最后可以见到 `PermGen space` 这样的永久代 OOM 的异常信息，这是由于这时候字符串常量池还在永久代中。
2. JDK 7 开始，字符串常量池放到了堆中，如果再按照前面的方法，最终是会报出堆 OOM 异常，如果要报出永久代异常，可以通过不断地生成类来填满运行时常量池。
3. JDK 8 开始，运行时常量池移到了元空间中，属于堆外内存，这部分内存默认不加限制（很大很大），因此通常需要我们增加 `-XX:MaxMetaspaceSize` 来防止一些破坏性操作，避免撑爆系统内存。
   - **-XX:MinMetaspaceFreeRatio**：最小空闲比，当 Metaspace 发生 GC 后，如果剩余空间小于该比例则进行扩容。
   - **-XX:MaxMetaspaceFreeRatio**:最大空闲比，当 Metaspace 发生 GC 后，如果剩余空间大于该比例则进行缩容。

直接内存溢出，通常是与 NIO 有关，如果看到 dump 出来的内存快照很小，那么就需要注意是否直接/间接使用了 `DirectMemory` 。

## 第三章 垃圾收集器与内存分配策略

### 3.1 可达性分析算法

JVM 采用可达性分析算法来判断哪些对象属于垃圾并回收，从 GC ROOTS 出发，遍历对象：

![image-20210208234622138](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210208234622138.png)

一个对象要被回收，至少需要经过两次标记：

1. 第一次是经过可达性分析后发现没有与 GC ROOTS 连接，则进行标记。
2. 之后将其放到一个 F-Queue 的队列里，并以一个低优先级的线程去执行队列里对象的 finalize 方法，但不一定会执行（只有首次且重写了 finalize 方法才会执行），也不一定会等待其执行完成。

### 3.2 方法区的回收

方法区的回收包括废弃的常量以及废弃的类两部分，前者回收较为简单，扫描 GC ROOTS 即可，后者需要同时满足以下三个条件：

![image-20210118224622265](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210118224622265.png)

> NOTE：JVM 提供了 - `Xnoclassgc` 关闭方法区类的回收，也提供了 -verbose:class 以及 -XX:+TraceClass-Loading、-XX:+TraceClassUnLoading 来跟踪类的加/卸载情况。

在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。

### 3.3 分代收集理论

当前商业虚拟机的垃圾收集器，多数都是遵循**“分代收集”（Generational Collection）**的理论开发的：

1. 弱分代假说，绝大多数对象朝生夕死。
2. 强分代假说，熬过越多次垃圾收集的对象越难以消亡。
3. 跨代引用假说，跨代引用对于同代引用来说仅占极少数。

基于前两个假设，设计者一般会将 Java 堆划分为新生代、老年代两个区域。

还有一种现象就是跨代引用，为了避免扫描整个老年代，需要在新生代新建一个全局的数据结构 Remembered Set,这个数据结构将老年代划分为若干个内存块，并标记出包含了有跨代引用的内存块，在 GC 时会将这些内存块加入 GC ROOTS。

GC 可以按照回收区域进行划分：

- 部分收集（Partial GC）：只收集部分内存区域，根据收集区域的不同可以分为几类
  - **新生代收集（Minor GC/Young GC）**：指目标只是新生代的垃圾收集。
  - **老年代收集（Major GC/Old GC）**：指目标只是老年代的垃圾收集，目前只有 CMS 有单独收集老年代的行为。有时候 Major GC 又指整堆收集，需要根据具体上下文判断。
  - **混合收集（Mixed GC）**：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有 G1 收集器会有这种行为。
- 整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。

> 值得注意的是，分代收集理论也有其缺陷，最新出现（或在实验中）的几款垃圾收集器都展现出了面向全区域收集设计的思想，或者可以支持全区域不分代的收集的工作模式。

### 3.4 回收算法

**标记-清除（Mark-Sweep）**算法是最早出现的 GC 算法，分为 “标记”、“清除” 两个阶段：

1. 首先标记出所有需要回收的对象，进行标记。
2. 对标记的对象进行回收。

![image-20210121231437611](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210121231437611.png)

> 标记-清理算法的缺点很明显，就是回收效率会由于大量可回收对象而降低，以及产生内存碎片。

**标记-复制**算法是为了解决标记-清除算法面对大量可回收对象时执行效率低的问题，其思想是划分出一块区域不分配对象，每次回收都只针对其他区域进行回收，并将存活对象拷贝到之前未分配对象的区域，这样一来也不会产生内存碎片，分配内存也只需要简单的移动堆指针即可。

![image-20210121232820249](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210121232820249.png)

HotSpot 的实现方式是采用 Eden + 2 个 Survivor 的方式实现的，默认比例为 8：1：1，也就是每次新生代中可用的容量为整个新生代容量的 90%，其中一个 Survivor 区域作为 GC 候拷贝存活对象的区域。

现实中，无法保证存活的对象一定小于 Survivor 区域的容量，当存活对象大于 Survivor 容量时，会采用 “分配担保” 的策略，这些对象会直接进入老年代。

> 标记-复制算法在对象存活率较高时需要进行较多的操作，从而降低效率，并且会浪费部分空间。

**标记-整理（Mark-Compact）**算法相对于标记-清除算法，标记过程仍然一样，后续步骤则是让存活对象向内存空间同一端移动，然后清除边界以外的内存：

![image-20210121233907323](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210121233907323.png)

>  标记-整理算法在老年代这种每次回收都有大量存活对象的区域，移动并更新所有引用的开销十分大，且需要暂停用户线程，导致 STW。

**标记-清除 会让分配对象更为复杂，而 标记-整理 会让回收对象更为复杂**。

JVM 的吞吐量实质是**赋值器**（Mutator，可以理解为使用垃圾收集的用户程序）与收集器的效率总和，由于大部分场景分配对象的频率会高于回收对象，因此使用 标记-整理 会使整体吞吐量更高，而若追求低延迟、短停顿则可以使用 标记-清除 算法。

> HotSpot 虚拟机里面关注吞吐量的 Parallel Scavenge 收集器是基于标记-整理算法的，而关注延迟的 CMS 收集器则是基于标记-清除算法的，这也从侧面印证这点。

还有一种回收方案是根据不同场景使用 标记-清除 以及 标记-整理，CMS 收集器大部分场景下使用 标记-清除 算法，当空间碎片过多时，再使用 标记-整理 算法。

> 最新的 ZGC 和 Shenandoah 收集器使用读屏障（Read Barrier）技术实现了整理过程与用户线程的并发执行。

### 3.5 算法实现细节

**根节点枚举**（从 GC ROOTS 集合查找引用链）在目前任意的垃圾收集器中都需要 STW，因此需要采取一些方案来高效实现这一过程。

目前主流的 JVM 都是使用**准确式垃圾收集**，一旦类加载动作完成，HotSpot 便会将对象内什么偏移量上是什么类型的数据解析出来，即使在 JIT 中，也会在**特定位置**记录下栈和寄存器里哪些位置是**引用**。

HotSpot 采用 **OopMap** 存放这些信息，记录了栈上本地变量到堆上对象的引用关系，这样一来垃圾收集器就不需要扫描所有的对象了。

> NOTE：准确试垃圾收集依赖于 JVM 准确式内存管理，可以通过对象的类型指针等得知其数据类型。

**安全点**适用于记录 OopMap 内信息的地方，目的是为了减少 OopMap 频繁变化导致的成本。

STW 前需要等待程序到达安全点，安全点以 ”是否具有让程序长时间执行的特征“ 来进行选取，常见的有方法调用、循环跳转、异常跳转等**复用序列的指令**。

安全点需要有停顿线程（不包括 JNI 调用的线程）的能力，通常有两种方案：

- 抢先式中断，在 GC 发生时，系统把所有用户线程中断，如果发现用户线程未到达安全点，则恢复执行，过一会再中断直到到达安全点，这种方式几乎不使用。
- **主动式中断**，不直接对线程中断，而是提供一个标志位给各个线程轮询，轮询标志的位置跟安全点是重合的，一旦用户线程发现标志为真，则在最近的安全点上主动中断挂起。轮询标志的位置还包括新建对象等需要堆内存进行分配的地方，目的是为了检查是否即将发生 GC，避免没有足够的内存分配对象。

主动式中断的轮询操作十分频繁，HotSpot 采用**内存保护陷阱**的方式，将其精简到只有一条 test 汇编指令（一次内存访问）的方式，将某个内存页置为不可读，那么线程执行到 test 时就会产生一个自陷异常信号，然后挂起线程。

---

**安全区域（Safe Region）**，可以看成是对安全点的延伸，用于应对线程在不执行（如线程处于 Sleep、Blocked 状态）时无法响应 JVM 中断请求的场景。

在安全区域对应的代码片段中，引用关系不会发生变化，因此在这个区域中任意地方开始 GC 都是安全的。

当线程进入了安全区域的时候，会标识自己进入了安全区域，此时 GC 不需要去管这些线程；在线程要离开安全区域的时候，则会检查虚拟机是否完成了根节点枚举，或者处于需要暂停线程的阶段。如果完成了，那么继续执行，否则等待直到收到可以离开安全区域的信号为止。

---

**记忆集（Remembered Set）**是为了解决跨代引用的问题，是一种**用于记录跨区域引用关系的抽象数据结构**，伪代码如下：

```java
class RememberedSet {
  Object[] set[OBJECT_INTERGENERATIONAL_REFERENCE_SIZE];
}
```

这种记录全部跨代引用对象的空间占用以及维护成本十分高昂，因此可以采用更粗精度的方式来节省空间以及维护成本，常见的精度如下：

1. **字长精度**，每个记录精确到一个机器字长（就是处理器的寻址位数，如常见的32位或64位，这个精度决定了机器访问物理内存地址的指针长度），该字包含跨代指针。
2. **对象精度**，每个记录精确到一个对象，该对象里有字段含有跨代指针。
3. **卡精度**，每个记录精确到一块内存区域，该区域内有对象含有跨代指针。

第三种精度的方式称为**卡表（Card Table）**，是记忆集的一种具体实现，它定义了记忆集的记录精度、与堆内存的映射关系等。

HotSpot 使用字节数组来实现卡表标记逻辑：

```c
CARD_TABLE [this address >> 9] = 0;
```

该字节数组的每一个元素都对应了内存区域一块特定大小的内存块，这个内存块称为**“卡页”（Card Page）**。卡页大小通常是 2 的 N 次幂字节数，HotSpot 则是 512 字节。

一个卡页往往包含多个对象，只要有其中一个对象存在跨代引用，那么该卡页便会被标记为**脏页**（将数组元素的值标记为 1），之后 GC 时，只需要扫描卡表，便可以得出哪些内存块需要加入 GC ROOTS。

> NOTE：使用 byte 数组而不是 bit 数组，是因为现代计算机硬件都是按照最小字节寻址（内存页）的，使用 bit 的话需要额外消耗几条 shift + mask 指令。

---

HotSpot 使用**写屏障（Write Barrier）**是来维护卡表，在经过 JIT 后，代码只是纯粹的机器指令流了，因此需要采取机器码层面的手段，把卡表的维护操作放到每一个复制操作之中。

> NOTE：此处的 “写屏障”，以及后面在低延迟收集器中会提到的 “读屏障” 与解决并发乱序执行问题中的 “内存屏障” 需要区分开来。

写屏障有点类似于 AOP 切面，在应用对象赋值的时候会产生一个环形（Around）通知，执行额外的动作；在赋值前的部分的写屏障叫作**写前屏障（Pre-Write Barrier）**，在赋值后的则叫作**写后屏障（Post-Write Barrier）**。

HotSpot 的 G1 收集器出现之前，其余的收集器使用的都是写后屏障：

```c
void oop_field_store(oop* field, oop new_value) { 
  // 引用字段赋值操作
  *field = new_value;
  // 写后屏障，在这里完成卡表状态更新
  post_write_barrier(field, new_value); 
}
```

> NOTE：使用了写后屏障后，无论赋值的对象是不是跨代引用，都会产生额外的开销，但比起 Minor GC 扫描整个老年代的代价相比仍然低得多。

卡表在**高并发场景**还面临着伪共享问题，假设处理器一个缓存行大小为 64 字节，一个卡表元素占用一个字节，那么一个缓存行的卡表就对应着 32KB 的内存，一旦这块内存的对象被某个线程更新，卡表的某个元素也跟着更新，那么就会导致该缓存行其他不需要更新的卡表元素失效，从而导致性能降低。

JDK7 之后，HotSpot 提供了 `-XX:+UseCondCardMark` 来决定是否开启卡表更新的判断（默认关闭），当开启卡表更新判断时，会先对卡表是否为脏进行一次判断，一旦为脏之后，便不再对该卡表元素进行更新，从而减少伪共享发生的次数：

```c
if (CARD_TABLE [this address >> 9] != 0) 
  CARD_TABLE [this address >> 9] = 0;
```

通常在高并发场景下才开启该参数。

---

**可达性分析**中，GC ROOTS 相对整个 Java 堆中的对象数量来说算是极少数，加上 OopMap 等优化技巧，使得 GC ROOTS 的数量相对可控，并不会随着堆内存的增大而增大，但在从 GC ROOTS 继续往下遍历对象，这时遍历的耗时就会随着内存（对象数量）的增加而增大。

Q：**可达性分析为何需要在一个可以保障一致性的快照上进行对象图的遍历？**

这里借助三色标记法来解释：

- 白色：表示对象尚未被垃圾收集器访问过。
- 黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色对象是安全存活的。
- 灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。

GC ROOTS 在刚开始的时候就属于黑色的，当用户线程与收集器并发工作的时候，会产生两种后果：

1. 扫描器将某个对象标记为黑色后，用户线程断开了其引用关系，此时应该回收的对象则会漏掉（可容忍）。
2. 扫描器在灰色节点处即将遍历剩余的引用时，用户线程断开了灰色与白色对象的引用，并将白色对象链接到了已经扫描过的黑色对象，此时不应该回收的对象会被标记为白色导致错误的回收（不可容忍）。

当且仅当满足以下两个条件的时候，会产生错误的回收：

1. 赋值器插入了一条或多条从黑色对象到白色对象的新引用；
2. 赋值器删除了**全部从灰色对象到该白色对象的直接或间接引用**。

当前的解决方案分别有**增量更新（Incremental Update）**和**原始快照（Snapshot At The Beginning， SATB）**两种，分别破坏第一个和第二个条件。

- 增量更新：当黑色对象插入了到白色对象的新引用时，将其记录下来，在扫描完成后，将这些黑色节点作为 GC ROOTS 再一次进行扫描。
- 原始快照：当灰色对象删除指向白色对象的引用时，将其记录下来，在扫描完成后，将当时记录的关系中的灰色对象作为 GC ROOTS，按照当时的快照再一次进行扫描。可以理解为无论引用关系删除与否，后面的二次扫描都会按照当时记录的快照进行标记。

> NOTE：以上无论是对引用关系记录的插入还是删除，虚拟机的记录操作都是通过写屏障实现的。CMS 是基于增量更新来做并发标记的，G1、Shenandoah 则是用原始快照来实现。

### 3.6 垃圾收集器

![image-20210124215321964](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210124215321964.png)

#### 3.6.1 Serial 收集器(新生代)

![image-20210124215613770](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210124215613770.png)

Serial 收集器是一个单线程工作的新生代收集器，同时还强调在进行 GC 时，必须停掉其他线程，只能有它自己一个线程运行。

Serial 收集器在小内存、单核处理器等场景，新生代内存很少超过一两百兆，GC 的停顿时间可以控制在十几、几十毫秒，其实现简单高效，内存占用少，没有线程交互的开销。在客户端模式下的虚拟机来说是一个很好的选择。

#### 3.6.2 ParNew 收集器（新生代）

![image-20210124220111760](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210124220111760.png)

ParNew 收集器实质上是 Serial 收集器的多线程并行版本，除了使用多线程进行 GC 外，其余行为与 Serial 基本一致。

ParNew 与 Serial 都是基于 HotSpot 提供的垃圾收集分代框架实现的，因此两者都能与同样是基于该框架实现的 CMS 老年代收集器配合工作。

ParNew 默认开启的收集线程数与处理器核心数量相同，为了避免消耗过多的 CPU 资源，可以通过 `-XX：ParallelGCThreads` 限制 GC 的线程数。

> NOTE：ParNew 收集器在单核心处理器的环境中绝对不会有比 Serial 收集器更好的效果，甚至由于存在线程切换的开销，该收集器在通过超线程（Hyper-Threading）技术实现的伪双核处理器环境中都不能百分之百保证超越 Serial 收集器。

#### 3.6.3 Parallel Scavenge 收集器（新生代）

Parallel Scavenge 使用了 标记-复制 算法以及多线程，并未遵循 HotSpot 的分代框架，与 CMS 等关注延迟的收集器不同，Parallel Scavenge 更加关注吞吐量：
$$
吞吐量=\frac{运行用户代码时间}{运行用户代码时间+运行垃圾收集时间}
$$
Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量：

- `-XX：MaxGCPauseMillis`：控制最大暂停时间，降低该值是以减少新生代大小以及牺牲吞吐量为代价的。
- `-XX：GCTimeRatio`：设置吞吐量大小，默认 99，表示只允许最大 1%（1/（1+99））的 GC 时间。

Parallel Scavenge 提供了 `-XX：+UseAdaptiveSizePolicy` 参数，开启后会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。

#### 3.6.4 Serial Old 收集器（老年代）

![image-20210125212449672](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210125212449672.png)

Serial Old是Serial收集器的老年代版本，是一个单线程收集器，使用 标记-整理 算法。

- 客户端模式下
  - 老年代默认收集器
- 服务端模式下
  - JDK5 及之前的版本中与 Parallel Scavenge 搭配使用。
  - 作为 CMS 收集器在 Concurrent Mode Failure 后的后备预案。

> NOTE: Parallel Scavenge 收集器架构中本身有 PS MarkSweep 收集器来进行老年代收集,实现几乎与 Serial Old 一样。

#### 3.6.5 Parallel Old 收集器

![image-20210125212739019](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210125212739019.png)

Parallel Old 是 Parallel Scavenge 收集器的老年代版本，支持多线程并发收集，使用 标记-整理 算法实现，在 JDK6 出现，可以与 Parallel Scavenge 配合使用。

> NOTE:在 Parallel Old 出现之前，Parallel Scavenge 只能与 Serial Old 配合使用，吞吐量不一定比 ParNew + CMS 高，地位较为尴尬。

#### 3.6.6 CMS 收集器

![image-20210125214351113](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210125214351113.png)

CMS 属于 HotSpot 对低延迟垃圾收集器的一次尝试，使用了 标记-清除 算法，分为四个阶段：

1. **初始标记（CMS initial mark）**，简单的标记一下 GC ROOTS 直接关联的对象，需要 STW
2. **并发标记（CMS concurrent mark）**
3. **重新标记（CMS remark）**，使用增量更新修正并发标记过程中变动的引用关系，需要 STW
4. **并发清除（CMS concurrent sweep）**

其中除了初始标记、重新标记需要 STW 外，其余两个过程都可以与用户线程一起进行。

需要进行重新标记的原因是由于并发标记的过程中，可能出现对象引用关系的改变（参照 “三色标记法”）。

CMS 存在 3 个缺点：

1. 对处理器资源敏感，默认启动线程数为 （处理器核心数 + 3）/4 ，在处理器核心较少的时候，占用的资源比例是很高的。
2. 回收线程能够与用户线程一起运行会出现一些问题：
   - 无法处理 “浮动垃圾”（Floating Garbage），由于是在标记过程后出现的垃圾，只能留到下一次垃圾回收再处理。
   - 并发标记阶段用户线程线程还在工作，因此需要预留部分空间给用户线程使用，通过 `-XX：CMSInitiatingOccupancyFraction` 设置触发 CMS 的比例，JDK6 时阈值默认为 92%。收集期间，可能会出现留给用户线程空间不够导致 Concurrent Mode Failure，从而又触发一次后备预案的 Serial Old 的老年代收集。
3. 由于是基于 标记-清除 算法，因此也会出现内存碎片，可能导致不得不 Full GC 的情况。
   - `-XX:+UseCMSCompactAtFullCollection`，默认开启，指定 CMS 在不得不进行 Full GC 时进行内存碎片合并。
   - `-XX:CMSFullGCsBeforeCompaction`，指定 CMS 经过指定次数不整理碎片的 Full GC 后，下一次 Full GC 前会进行碎片整理，默认值为 0，表示每次都会进行碎片整理。

#### 3.6.7 Garbage First收集器

![image-20210128224407967](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210128224407967.png)

G1 收集器开创了**收集器面向局部收集**的设计思路、**基于 Region 的内存布局**、**追求能够应付应用的内存分配速率（Allocation Rate）**而非一次将整个 Java 堆清理的里程碑设计。

G1 的运作过程也可分为四个步骤（不考虑写后屏障维护记忆集的前提下）：

1. **初始标记（Initial Marking）**：仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改 TAMS 指针的值，让下一阶段用户线程并发运行时，能正确地在可用的 Region 中分配新对象。需要 STW，但耗时很短，而且是借用进行 Minor GC 的时候同步完成的，实际上并无额外的停顿。
2. **并发标记（Concurrent Marking）**：与用户线程一同运行，从 GC ROOTS 出发，遍历并标记需要回收的对象。
3. **最终标记（Final Marking）**：STW，对用户线程做另一个短暂的暂停，用于处理并发阶段结束后**全局快照（SATB）**记录下的在并发标记时引用有变动的对象。 
4. **筛选回收（Live Data Counting and Evacuation）**：负责更新 Region 的统计数据，对各个 Region 的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个 Region 构成回收集（CSet），然后把决定回收的那一部分 Region 的存活对象复制到空的 Region 中，再清理掉整个旧 Region 的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。

上述过程会涉及到一些问题，需要逐个理清。

G1 基于 Region 划分内存后，可以**面向堆内存任何部分来组成回收集（Collection Set，简称 CSet）**进行回收，衡量标准则基于回收成本（受指定暂停时间影响及**衰减j均值**算法），得到一个优先级列表，这就是G1收集器的 **Mixed GC** 模式。

> NOTE：**衰减均值（Decaying Average）** 作为预测模型，比起整体的平均状态，衰减平均值会更容易受到最新数据的影响，从而能能够更好地代表最近的状态。

G1 基于 Region 划分内存后，每一个 Region 都可以根据需要扮演新生代的 Eden、Survivor 空间，或者老年代空间，收集器能够针对不同角色的 Region 采取不同的回收策略，同时还有 **Humongous** 区域用于存放大对象（对象大小超过 Region 的一半），G1 大多数行为都将其当做老年代来看待。

![image-20210128225922432](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210128225922432.png)

G1 对于跨 Region 引用，则是每个 Region 维护一个自己的 RSET，记录下别的 Region 指向自己的指针，并标记这些指针分别在哪些卡页的范围内。这种卡表结构是双向的（记录了我指向谁以及谁指向我），结构更为复杂，占用内存更高，G1 至少要耗费相当于 Java 堆 10% ~ 20% 的额外内存，但借助这种格式可以有效地得知需要扫描的 Region。

并发标记过程，G1 采用**原始快照（SATB）**来解决对象引用关系变化的过程，这个需要借助**写前屏障**来跟踪引用关系变化情况，同时 SATB 精度较低，造成的浮动垃圾较多。

> NOTE: 比起增量更新，原始快照再次标记扫描的对象更少，能够减少并发标记和重新标记阶段的消耗，避免 CSM 在最终标记阶段停顿时间过长的缺点，但在用户程序运行过程中确实会产生跟踪引用变化的额外负担。CMS 的写屏障实现是直接的同步操作，G1 则是将写前、写后屏障的事件丢到队列中异步处理。

G1 为每一个 Region 设计了两个名为 **TAMS（Top at Mark Start）** 的指针，把 Region 中的一部分空间划分出来用于并发回收过程中的新对象分配，并发标记时新分配的对象地址都必须要在这两个指针位置以上，在这个地址以上的对象是隐式标记过的，即默认存活，不纳入回收范围。

**Q：什么时候触发 Mixed GC ？**

A：当 old + humongous 占用堆的比例超过 `-XX:InitiatingHeapOccupancyPercent` （默认 45%）时，就会触发初始标记（伴随着一次 YGC），这时如果收集到的 CSet 可回收的比例大于 `-XX:G1HeapWastePercent`（默认 10%），则会触发 Mixed GC。

**Q：什么类型的 Region 会被选入 CSet？**

A：当该 Region 存活对象的比例低于 `-XX:G1MixedGCLiveThresholdPercent`（默认 65%），则会被选入 CSet。

#### 3.6.8 Shenandoah 收集器

Shenandoah 收集器与 G1 收集器类似，但有主要三个不同的地方：

1. 支持并发回收时与用户线程一同进行。
2. （暂时）无分代。
3. 摒弃了 G1 的记忆集实现，改为使用 **“连接矩阵（Connection Matrix）”** 的**全局数据结构**来记录跨 Region 的引用关系。

连接矩阵可以理解为一张二维表格，如果 Region M 指向了 Region N，那么就会在该矩阵的 M 行 N 列打上一个标记：

![image-20210130184624682](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210130184624682.png)

这样一来可以减少记忆集的维护开销（**去掉了写后屏障**），二来可以避免伪共享发生的概率。

Shenandoah 可以细分为九个阶段

1. 初始标记：十分短暂的 STW，标记 GC ROOTS 直接关联的对象。
2. **并发标记**：与用户线程一起工作，标记出全部可达对象。
3. 最终标记：十分短暂的 STW，使用 SATB 解决对象引用关系变化问题，同时统计回收价值得出 CSet。
4. 并发清理：清理一个存活对象都没有的 Region，这类 Region 称为 Immediate Garbage Region。
5. **并发回收（核心差异）**：复制存活对象到其他 Region，通过**读屏障**和 **“Brooks Pointers”** 的转发指针来解决与用户线程一同工作遇到的问题。
6. 初始引用更新：十分短暂的 STW，未做具体的处理，只是建立一个线程集合点，确保所有并发回收阶段中进行的收集器线程都已完成分配给它们的对象移动任务。
7. **并发引用更新**：真正的引用更新操作，按照物理内存地址线性地搜索出**引用类型**，把旧值改成新值。
8. 最终引用更新：最后一次短暂的 STW，时间与 GC ROOTS 有关，修正 GC ROOTS 中的引用。
9. 并发清理：经过并发清理与引用更新后，回收 Immediate Garbage Region。

并发回收阶段，回收线程与用户线程一同进行，需要解决几个问题，首当其冲就是复制存活对象到其他 Region 时，要如何保证用户线程能够正确找到移动后的对象。

通常都是做一个转发来解决这个问题，传统的解决方案实在原有内存上设置一个**内存保护陷阱（Memory Protection Trap）**，用户线程一旦访问到该内存就会产生**自陷中断**，从而进入预设好的异常，再按照设置好的代码逻辑转发到复制好的对象上，但这种方法会**产生频繁的用户态——内核之间的切换**。

Brooks 提出的方案则是摒弃内存保护陷阱，在对象布局的最前面统一添加一个新的引用字段，平时指向自身，一旦复制到了新的 Region 中，引用则改为指向新的复制对象（类似句柄，但句柄实在一块统一的内存空间上）。

> NOTE：这个转发尽管被优化为了一行汇编指令，但由于对象定位使用频率很高，执行成本并不低。

![image-20210130193122309](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210130193122309.png)



**用户线程对对象的修改，很有可能发生在 GC 线程复制对象、修改指针之间**，因此要考虑一个并发问题，同一时间用户线程对转发指针的访问、GC 线程只有一个能成功，另一个必须等待，实际上，Shenandoah 也是借助 CAS 来保证并发时对象的访问正确性。

为了实现 Brooks Pointer，Shenandoah在读、写屏障中都加入了额外的转发处理，尤其是使用读屏障的代价，这是比写屏障更大的。数量庞大的读屏障会成为性能瓶颈的关键点之一，因此 Shenandoah 计划后续（JDK 13）将内存屏障模型改进为**引用访问屏障（Load Reference Barrier）**，只拦截对象中数据类型为引用类型的读写操作，而不管原始数据类型等其他非引用自断的读写。

Shenandoah 收集器存在的几个问题：

1. 写屏障、读屏障会产生一定的开销，尤其是读屏障的使用频率远远大于写屏障。
2. 浮动垃圾较多，且在引用更新完成之前，Region 无法释放。

https://ionutbalosin.com/2019/12/jvm-garbage-collectors-benchmarks-report-19-12/

https://developers.redhat.com/blog/2019/06/28/shenandoah-gc-in-jdk-13-part-2-eliminating-the-forward-pointer-word/

#### 3.6.9 ZGC 收集器

ZGC 作为一款低延迟收集器，实现思路与 Shenandoah 有较大差异，主要体现在其使用了**染色指针**、读屏障以及**内存多重映射**等技术来实现标记-整理算法，并且以**低延迟**为首要目标。

ZGC 也是一款基于 Region 的收集器：

- 小型 Region：容量固定为2MB，用于放置小于 256KB 的小对象。
- 中型Region（Medium Region）：容量固定为 32MB，用于放置大于等于 256KB 但小于 4MB 的对象。
- 大型Region（Large Region）：容量不固定，可以动态变化，但必须为 2MB 的整数倍，用于放置 4MB 或以上的大对象，可能小于中型 Region。大型 Region 在 ZGC 中不会被**重分配**。

ZGC 使用**染色指针技术（Colored Pointer）**实现了并发回收阶段与用户线程一同工作，通过在指针（而非对象）的高 4 位上存储一些额外信息，从而无需访问对象即可获得对象的一些信息，此时可达性分析更像是遍历 “引用图” 而非对象图。

> NOTE：受限于现代工艺、性能和成本等条件制约，当前 AMD64 架构只支持到 52位（4PB）的地址总线和 48位（256TB）的虚拟地址空间， Linux 64 位系统最高只支持到 47位（128TB）的进程虚拟机地址空间和 46位（64TB）的物理地址空间。ZGC 占用了高 4 位，因此最多只能管理 4TB 的内存空间，同时不支持 32 位平台，不支持指针压缩。

通过这些标志位，虚拟机可以直接从指针中看到其引用对象的三色标记状态、是否进入了重分配集（即被移动过）、是否只能通过finalize()方法才能被访问到：

![image-20210131155330760](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210131155330760.png)

染色指针的优势：

- 染色指针使得一旦某个 Region 的存活对象被移走之后，就能够立刻释放和重用，理论上只要还有一个空闲的 Region，就能够完成收集。
- 染色指针可以大幅减少 GC 过程中屏障的使用数量，因为信息直接维护在指针中，当前 ZGC 只使用了读屏障实现用户线程对移动后对象的正确读取（写屏障之所以未用到是因为还未支持分代，跨 Region 引用也是通过扫描所有 Region 而非维护记忆集）。
- 染色指针可以作为一种**可扩展**的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后可以利用指针剩余的位数，进一步提高性能。

使用染色指针存在的一个问题是，操作系统并不会特殊对待染色指针，而是将其当做一个普通的引用指针来对待，因此需要 ZGC 对其做一定的转换，这里涉及到了虚拟内存映射技术。

不同层次的虚拟内存到物理内存的转换关系可以在硬件层面、操作系统层面或者软件进程层面实 现，如何完成地址转换，是一对一、多对一还是一对多的映射，也可以根据实际需要来设计。

Linux x86_64 平台上的 ZGC 使用了**多重映射（Multi-Mapping）**将多个不同的虚拟内存地址映射到同一个物理内存地址上，这是一种多对一映射,因此 ZGC 实际看到的虚拟内存会比堆内存大得多。

ZGC 会把染色指针中的标志位看作是地址的分段符，那只要将这些不同的地址段都映射到同一个物理内存空间，经过多重映射转换后，就可以使用染色指针正常进行寻址了：

![image-20210131161444939](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210131161444939.png)

ZGC 的运行过程可以分为四个大阶段：

![image-20210131161609479](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210131161609479.png)

1. 初始标记：同 G1、Shenandoah。
2. **并发标记（Concurrent Mark）**：同 G1、Shenandoah，只不过标记是在指针上进行，最后也有短暂的最终标记。
3. **并发预备重分配（Concurrent Prepare for Relocate）**：根据特定的查询条件统计得出要清理的 Region，组成**重分配集（Relocation Set）**，与 G1 不同的是并没有所谓的优先级队列，并非针对某个 Region,而是扫描全部 Region，决定出哪些存活对象需要移动到其他 Region。
4. **并发重分配（Concurrent Relocate）**：核心阶段，这个过程要把重分配集中的存活对象复制到新的 Region 上，并为重分配集中的每个 Region 维护一个**转发表（Forward Table）**，记录从旧对象到新对象的转向关系。若此期间用户线程**首次**访问了位于重分配集中的对象，就会被读屏障所截获，然后**根据 Region 的转发表将访问转发到新复制的对象上，并更新该引用（实现 “自愈”）**。之后如果存活对象都复制完成了，那么该 Region 便可以立即释放，但转发表还得保留，应对后面用户线程的访问。
5. 并发重映射（Concurrent Remap）：类似于 Shenadoah 的并发引用更新阶段，修正整个堆中指向重分配集中旧对象的所有引用，但鉴于染色指针的 “自愈” 特性，这个阶段优先级并不高，实际上 ZGC 而是将其合并到下一次 GC 中的并发标记阶段去完成的，一旦所有指针都修正之后，转发表便可以释放了。

ZGC 使用存在的几个问题：

1. ZGC 若要利用剩余的指针位数，需要操作系统支持，并且 JVM 作为一个普通的系统进程，修改操作系统的指针访问方式是否合适仍需权衡。
2. ZGC 没有实现分代以及记忆集，在并发标记阶段，若果新生成的对象很多，这部分对象只能留到下一次 GC 时再处理，即 ZGC 所能承受的对象分配速率不会很高，只能通过增大内存来缓解该现象。

#### 3.6.10 Epsilon 收集器

JDK11 出现的一款无收集行为的收集器，其实是顺应了微服务化、无服务化方向发展的趋势，由于 Java 占用内存较大，在容器中启动时间长，JIT 优化缓慢等，对于短时间、小规模的服务有诸多不适，因此出现了 提前便已、面向应用的类数据共享等技术。

Epsilon 也是有着类似的目标，如果应用只需要运行数分钟甚至数秒，只要 JVM 有足够内存，在堆耗尽之前就会推出，那么运行负载小，没有任何回收行为的 Epsilon 便很合适。

#### 3.6.11 总结

从最新的两款 GC 收集器来看，都是实现了并发回收阶段与用户线程同时进行的技术，同时都将 STW 阶段变得与堆内存大小无关。

- 写后屏障：Serial、CMS、Parallel
- 写前屏障 + 写后屏障：G1
- 读屏障 + 写前屏障：Shenandoah
- 读屏障：ZGC

关于 GC 收集器的选择，需要根据具体场景权衡：

1. 如果能够掌控软硬件型号，有特别注重延迟，那么选择 ZGC。
2. 如果对处于实验性质的收集器稳定性有顾虑，或者必须使用 win 系统，那么可以考虑选择 Shenandoah 收集器。
3. 如果属于遗留系统，基础设置较为落后，对于 4GB ~ 6GB 的内存，那么可以考虑 CMS 以及 Parallel。
4. 如果内存大于 6GB，那么可以考虑 G1 收集器。

GC 类型总共可以分为两大类：

- Partial GC：只针对局部回收：
  - 只针对年轻代
  - 只针对老年代，当前只有 CMS 有这个行为，定期扫描堆用量并触发
  - 针对多个 Region 进行回收
- Full GC：针对整个堆内存进行回收

> NOTE：JVM 发展多年，Major GC 已经与 Full GC、Old GC 语义开始有点混淆了，讨论时需要提前分清。通常都会将其当作 Full GC 来对待。

### 3.7 JVM 以及 GC 日志

JDK9 之前，JVM 以及 GC 收集器的日志是一系列人为的规则，并没有统一的规范， JDK9 开始，HotSpot 将所有的日志功能都归到了 `-Xlog` 参数上：

```bash
-Xlog[:[selector][:[output][:[decorators][:output-options]]]]
```

最关键的是 `selector`，由标签（tag）和日志级别（Level）组成，标签可以理解为摸个功能模块的名字，包括 `gc` 也是其中一个模块，HotSpot 支持的模块如下：

```bash
add，age，alloc，annotation，aot，arguments，attach，barrier，biasedlocking，blocks，bot，breakpoint，bytecode
```

修饰器 decorators 用于指定额外输出的内容

- time：当前日期和时间。
- uptime：虚拟机启动到现在经过的时间，以秒为单位。
- timemillis：当前时间的毫秒数，相当于System.currentTimeMillis()的输出。
- uptimemillis：虚拟机启动到现在经过的毫秒数。
- timenanos：当前时间的纳秒数，相当于System.nanoTime()的输出。
- uptimenanos：虚拟机启动到现在经过的纳秒数。
- pid：进程ID。
- tid：线程ID。
- level：日志级别。·tags：日志输出的标签集。

默认输出 uptime、level、tags 三个。

查看GC基本信息，在 JDK9 之前使用 `-XX:+PrintGC`，JDK9后使用 `-Xlog:gc`：

```bash
bash-3.2$ java -Xlog:gc.demon.log GCTest 
[0.222s][info][gc] Using G1
[2.825s][info][gc] GC(0) Pause Young (G1 Evacuation Pause) 26M->5M(256M) 355.623ms [3.096s][info][gc] GC(1) Pause Young (G1 Evacuation Pause) 14M->7M(256M) 50.030ms [3.385s][info][gc] GC(2) Pause Young (G1 Evacuation Pause) 17M->10M(256M) 40.576ms
```

### 3.8 内存分配与回收策略

在经典的分代理论中，新对象通常是在堆上的 Eden 区分配的，少数情况（例如对象大小超过一定阈值）也可能直接分配在老年代，分配的规则不是固定的，取决于 JVM 自身的实现，Java 虚拟机规范也未对这块做出详细规定。

新对象总是优先分配在 Eden 区，如果后续分配对象时，Eden 区没有足够的内存了，而 Minor GC 又回收不了多少内存，则会触发担保分配，直接分配在 Old 区：

```java
private static final int _1MB = 1024 * 1024; 
/**
 * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 */
public static void testAllocation() {
	byte[] allocation1, allocation2, allocation3, allocation4;
	allocation1 = new byte[2 * _1MB];
	allocation2 = new byte[2 * _1MB];
	allocation3 = new byte[2 * _1MB];
	allocation4 = new byte[4 * _1MB];  // 出现一次Minor GC 
	}
```

> [GC [DefNew: 6651K->148K(9216K), 0.0070106 secs] 6651K->6292K(19456K), 0.0070426 secs] [Times: user=0.00 secs]
>
> Heap
> 	def new generation   total 9216K, used 4326K [0x029d0000, 0x033d0000, 0x033d0000)
>
> ​		eden space 8192K,  51% used [0x029d0000, 0x02de4828, 0x031d0000)
>
> ​		from space 1024K, 14% used [0x032d0000, 0x032f5370, 0x033d0000) 
>
> ​		to space 1024K, 0% used [0x031d0000, 0x031d0000, 0x032d0000)
> ​	tenured generation   total 10240K, used 6144K [0x033d0000, 0x03dd0000, 0x03dd0000)
>
> ​		the space 10240K,  60% used [0x033d0000, 0x039d0030, 0x039d0200, 0x03dd0000)
> ​	compacting perm gen  total 12288K, used 2114K [0x03dd0000, 0x049d0000, 0x07dd0000)
> ​		the space 12288K,  17% used [0x03dd0000, 0x03fe0998, 0x03fe0a00, 0x049d0000)
> No shared spaces configured.

大对象可以设定一个阈值 `-XX:PretenureSizeThreshold`，超过该阈值时直接分配在 Old 区，表面在 Eden、Survivor 来回拷贝，产生大量开销，

> NOTE: -XX:PretenureSizeThreshold 只对 Serial 以及 ParNew 两款新生代收集器有效。

```java
private static final int _1MB = 1024 * 1024; 
/**
 * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 * -XX:PretenureSizeThreshold=3145728
 */
public static void testPretenureSizeThreshold() { 
	byte[] allocation;
	allocation = new byte[4 * _1MB];  //直接分配在老年代中 
  }
```

> Heap
> 	def new generation   total 9216K, used 671K [0x029d0000, 0x033d0000, 0x033d0000) 
>
> ​		eden space 8192K,   8% used [0x029d0000, 0x02a77e98, 0x031d0000)
> ​		from space 1024K, 0% used [0x031d0000, 0x031d0000, 0x032d0000) 
>
> ​		to space 1024K, 0% used [0x032d0000, 0x032d0000, 0x033d0000)
> ​	tenured generation   total 10240K, used 4096K [0x033d0000, 0x03dd0000, 0x03dd0000)
> ​		the space 10240K,  40% used [0x033d0000, 0x037d0010, 0x037d0200, 0x03dd0000)
> ​	compacting perm gen  total 12288K, used 2107K [0x03dd0000, 0x049d0000, 0x07dd0000)
> ​		the space 12288K,  17% used [0x03dd0000, 0x03fdefd0, 0x03fdf000, 0x049d0000)
> No shared spaces configured.

长期存活的对象会进入老年代，JVM 为每个对象设置了一个计数器（存在于对象头），如果一个对象经过一次 Minor GC 后仍存活，计数器 + 1，当达到最大阈值 15 时，就会晋升到老年代。

晋升年龄可以通过 `-XX:MaxTenuringThreshold=1` 来指定，但为了适应不同程序的内存状况，HotSpot 实际上会动态修改该值，**如果 Survivor 中相同年龄的所有对象大小大于 Survivor 中的一半**，则年龄大于或等于该年龄的对象就可以直接进入老年代。

JDK 6 Update 24 之前的**空间分配担保**，在发生 Minor GC 之前，JVM 必须检查老年代**最大可用的连续空间**是否大于新生代所有对象总空间：

- 如果这次条件成立，那么可以放心的进行 Minor GC。
- 否则，检查是否允许担保失败 `-XX:HandlePromotionFailure`
  - 如果不允许，则直接进行 Full GC
  - 如果允许，则检查**老年代剩余最大可用的连续空间是否大于历次晋升的平均大小**，再决定是否尝试进行一次有风险的 Minor GC。

JDK 6 Update 24 之后则是直接检查老年代剩余最大可用的连续空间是否大于新生代对象总大小或者历次晋升的平均大小，是则进行 Minor GC，否则直接 Full GC。

## 第四章 虚拟机性能监控、故障处理工具

给一个系统定位问题的时候，知识、经验是关键基础，数据是依据，工具是运用知识处理数据的手段。

大多数工具，都需要 JVM 自身开启 RMI、JMX，以及最新的 JMC 需要 JVM 开启 JFR 配合工作。

### 4.1 基础故障处理工具

**jps**：虚拟机进程状况工具，可以列出正在运行的 Java 进程，并显示一些相关的描述信息，语法格式为 `jps [ options ] [ hostid ]`，其中的 option 如下：

- -q：只输出 LVMID，省略主类名称。
- -m：输出 JVM 启动时传递给主类 main()　函数的参数。
- -l：输出主类的全名，如果是 Jar 包则输出 Jar 路径。
- -v：输出 JVM 启动时的 JVM 参数。

**jstat**：用于监视 JVM 运行状态信息的工具，可以显示本地或者远程虚拟机（需远程开启 RMI）的类加载、内存、GC、JIT 等运行时数据，语法格式为 `jstat [ option vmid [interval[s|ms] [count]] ]`，其中的 option 如下：

- -class：监视类加载、卸载数量，总空间以及类装载所耗费的时间。
- -gc：监视 Java 堆各个分代区域的容量、已用空间、GC 时间等统计信息。
- -gccapacity：类似于 -gc，但主要关注 Java 各个分代区域使用到的最大、最小内存空间。
- -gcutil：类似于 -gc，但主要关注 Java 各个分代区域已用内存空间的百分比。
- -gccause：与 -gcutil 类似，但会额外输出导致上一次 GC 的原因。
- -gcnew：监视新生代 GC 情况。
- -gcnewcapacity：类似于 -gcnew，但主要关注新生代使用到的最大、最小内存空间。
- -gcold：监视老年代 GC 情况。
- -gcoldcapacity：类似于 -gcold，但主要关注老年代使用到的最大、最小内存空间。
- -compile：输出即时编译过的方法、耗时等信息。
- -printcompilation：输出已经被即时编译的方法。

jstat 监控的信息主要可以分为三类：**类加载、GC、运行期编译状态**。

> NOTE：如果是本地进程，LVMID 与 VMID 是一致的，如果是远程进程，则 VMID 的格式是 `[protocol:][//]lvmid[@hostname[:port]/servername]`。

**jinfo**：可以实时查看和调整 JVM 的各项参数，使用 `jps -v` 可以查看 JVM 启动时指定的参数，但如果想看一些隐式指定的参数，就得借助 jinfo 了，语法格式为 `jinfo [ option ] pid`。jinfo 也可以使用 `-flag (+|-)name` 或者 `-flag name=value` 来修改部分运行期可以修改的参数。

> NOTE： jinfo 可以使用 `-sysprops` 打印出 JVM 的 `System.getProperties()` 内容。

**jmap**：可以用于查看堆内存布局详细信息，也可以用于生成堆转储快照，同时也可以查询 finalize 执行队列，语法格式为 `jmap [ option ] vmid`，option 的选项如下：

- -dump：生成 Java 对转出快照，格式为 `-dump:[live,]format=b,file=<filename>`,live 表示是否只 dump 出存活对象。
- -finalizerinfo：显示在 F-Queue 中等待 Finalizer 线程执行 finalize 方法的对象。
- -heap：显示 Java 堆详细信息。
- -histo：显示堆中对象信息统计，包括类、实例数量、合计容量。
- -permstat（过时）：以 ClassLoader 为口径统计永久代内存状态，jdk8 取消永久代后改为 `-clstats`。

**jstack**：用于生成 JVM 当前时刻的线程快照，语法格式为 `jstack [ option ] vmid`，option 如下：

- -F：当前请求不响应时，强制输出线程堆栈。
- -l：显示关于锁的附加信息。
- -m：如果调用到本地方法的话，显示 C/C++ 堆栈。

> NOTE：JDK5 开始 java.lang.Thread 新增了一个 `getAllStackTraces()` 方法用于获取 JVM 中所有线程的 StackTraceElement 对象，可以用这个方法做个简单的管理页面。

### 4.2 可视化故障处理工具

#### 4.2.1 JHSDB

JHSDB、JCMD 有着后发优势，能够做的比之前的老工具更好：

![image-20210206154626125](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210206154626125.png)

```java
/**
* staticObj、instanceObj、localObj存放在哪里？ */
public class JHSDB_TestCase {
	static class Test {
		static ObjectHolder staticObj = new ObjectHolder(); 
		ObjectHolder instanceObj = new ObjectHolder();
		void foo() {
			ObjectHolder localObj = new ObjectHolder(); 
			System.out.println("done");    // 这里设一个断点
		} 
	}
		private static class ObjectHolder {} 
		public static void main(String[] args) {
			Test test = new JHSDB_TestCase.Test(); 
			test.foo();
		}
}
```

JHSDB 开启图形化界面：`jhsdb hsdb --pid <pid>`:

![image-20210206204843326](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210206204843326.png)

- `Tools->Heap Parameters`：可以看到不同 GC 收集器下内存布局的信息。
- `Windows->Console`：根据前一个信息，扫描某段内存中的实例 `canoops 0x00007f32c7800000 0x00007f32c7b50000 JHSDB_TestCase$ObjectHolder`。
- `Tools->Inspector`：填入扫描到的某个对象的虚拟内存地址，可以看到存放的对象。

#### 4.2.2 JConsole： Java监视与管理控制台

`JConsole` 是一款基于 JMX（Java Management Extensions）的可视化监视、管理工具，通过 JMX 的 MBEAN（Managed Bean）对系统进行信息收集以及参数动态调整。

启动 JConsole 后会自动搜索所有的 Java 进程，通过下拉框选择进程即可。

JConsole 可以监控内存、线程等信息：

![image-20210206210726194](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210206210726194.png)

#### 4.2.3 VisualVM：多合-故障处理工具

VisualVM 是一个多合一工具，通常插件方式实现，且对程序影响小，还可以分析程序性能（这部分对程序性能有影响）。

> JDK5 之后，VisualVM 的 Profiler 功能会因为类共享而导致被监视的应用程序崩溃，所以进行 Profiling 前，最好在被监视程序中使用 `-Xshare:off` 参数来关闭类共享优化。

**BTrace** 是一个很强大的运行时工具，借助 HotSpot 虚拟机的 Instrument 功能，在不中断程序的前提下，动态加入原本并不存在的调试代码。

以下面的代码为例：

```java
public class BTraceTest {
	public int add(int a, int b) { return a + b; }
	public static void main(String[] args) throws IOException { 
		BTraceTest test = new BTraceTest();
		BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); 		  for (int i = 0; i < 10; i++) {
			reader.readLine();
			int a = (int) Math.round(Math.random() * 1000); 
			int b = (int) Math.round(Math.random() * 1000);
			System.out.println(test.add(a, b));
		}
	}
}
```

安装插件后，切换到该插件标签页：

![image-20210206212728561](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210206212728561.png)

之后输入以下调试代码：

```java
/* BTrace Script Template */
import com.sun.btrace.annotations.*;
import static com.sun.btrace.BTraceUtils.*;
@BTrace
public class TracingScript {
	@OnMethod(
	clazz="org.fenixsoft.monitoring.BTraceTest", method="add",
	location=@Location(Kind.RETURN) 
	)
	public static void func(@Self org.fenixsoft.monitoring.BTraceTest instance,int a, int b,@Return int result) {
		println("调用堆栈:");
		jstack();
		println(strcat("方法参数A:",str(a)));
		println(strcat("方法参数B:",str(b)));
		println(strcat("方法结果:",str(result))); 
	}
}
```

之后点击 Start 按钮片刻后，等待编译完成即可看到输出信息：

![image-20210206213016459](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210206213016459.png)

> NOTE：阿里巴巴的 Arthas 也通过 Instrument 实现了与 BTrace 类似的功能。

#### 4.2.4 Java Mission Control：可持续在线的监控工具

JMC 可以和 JFR（Java Flight Recorder）结合使用。

JFR 是一套内建在 HotSpot 里面的监控和基于事件的信息搜集框架，对生产环境中吞吐量的影响一般不会高于 1%。JFR 的开始、停止都可以动态修改，且不需要重启应用。

JMC 与 JVM 是基于 JMX 协议通信的，可以作为 JMX 的控制台，展示 MBean 的信息，也可以展示 JFR 的数据。

被监控的 JVM 进程需要开启并指定一些 JMX 以及 JFR 的配置：

```bash
-Dcom.sun.management.jmxremote=true
-Djava.rmi.server.hostname=192.168.31.4
-Dcom.sun.management.jmxremote.port=9999
-Dcom.sun.management.jmxremote.ssl=false
-Dcom.sun.management.jmxremote.authenticate=false
-XX:+UnlockCommercialFeatures -XX:+FlightRecorder
```

JFR 对比 MBean，收集到的数据质量更高，以 GC 为例，MBean 只可以收集到一个 GC 的结果，而 JFR 还可以看到内存中这段时间分配了哪些对象、哪些在TLAB中（或外部）分配、分配速率 和压力大小如何、分配归属的线程、收集时对象分代晋升的情况等，这些就是属于 “过程” 类的信息。

JFR的基本工作逻辑是开启一系列事件的录制动作，当某个事件发生时，这个事件的所有上下文数据将会以循环日志的形式被保存至内存或者指定的某个文件当中，循环日志相当于数据流被保留在一个环形缓存中。

> NOTE：环形缓冲区（Ring Buffer）通过在一个连续内存的数组上添加读、写指针，实现空间循环使用的高性能数据结构。

## 第五章 调优案例分析与实战

大内存硬件的程序部署策略：

- 在可以使用较新软硬件的时候，使用增量式 GC 是很值得优先考虑的方案。
- 如果无法升级到较新的 JDK，则需要确保 Full GC 的频率非常低，否则一次停顿，就会导致应用假死。
  - 如果无法实现 Full GC 频率很低，则考虑拆分为多个小堆应用 + 负载均衡转发器的架构。

**集群间同步导致的 OOM**：

- 需要考虑集群间同步信息时，一旦网络情况不足以满足交互需求，则会导致数据在内存中不断堆积，导致 OOM。
- 应用与**非集中式缓存**（如 JBossCache）交互的时候，一旦有大量写操作，就会导致缓存之间需要同步交互的次数非常频繁。

**堆外内存溢出**：

- 堆外缓存在 OOM 的时候，会发现 dump 出的文件内容并没有多少。
- 对外内存只有在应用 Full GC 时才有机会回收。

小内存以及 32 位应用除了 Java 堆以及方法区之外，其他区域的内存占用往往也不小，主要是**受到操作系统的 32 位进程最大内存的限制**：

- 直接内存，可通过 -XX:MaxDirectMemorySize 限制大小，内存不够时抛出 OOM。
- 线程堆栈，可通过 -Xss 调整大小，栈深度超过最大深度时抛出 StackOverflowError，栈容量动态扩展内存不够时则抛出 OOM。
- Socket 缓冲区，每个 Socket 链接都有 Receive 和 Send 两个缓冲区，分别占大约 37KB 和 25KB 内存，连接多时这块内存占用也比较可观。
- JNI 代码，本地使用的内存不算在堆中，而是占用 JVM 的本地方法栈以及本地内存。
- JVM、GC 收集器的工作也需要小号一定数量的内存。

> NOTE：由于系统制约， Windows 平台下单个 32 位 JVM 进程最多只能分配到 2GB 内存，并且堆内内存跟堆外内存会共享这部分内存。

**外部命令调用**： Java 的 `Runtime.getRuntime().exec()` 调用外部脚本，会先复制一个和当前 JVM 拥有一样环境的进程，再用这个新的进程去执行外部命令，非常消耗资源。

**长时间不进入安全点**：JVM 为了减少安全点对性能带来的负担，对于计数循环会有一项优化措施，就是当循环的索引为 int 类型的时候，会认为该循环执行的时间并不太长，也就不会在循环里生成安全点。可以通过 

已优化 IDEA 为例，开启 IDEA，可以借助 visualvm 来查看 IDEA 启动过程中的各项指标，可以观察到主要耗费的几大块时间如下：

- 类加载时间
  - 绝大部分情况下，我们可以认为 IDEA 生成的字节码是可靠的，因此可以关闭字节码验证：`-Xverify:none`
- 代码编译时间
  - 这部分主要是 JIT 优化耗费的一些时间，对启动时间并无太大影响。
- GC 时间
  - 可以观察 IDEA 稳定后堆的占用内存，提前设置 -Xms 为对应大小，避免扩容带来的延迟。
  - 提前设置方法区大小。
  - 选择合适的 GC 收集器，如果内存较小，可以考虑 CMS，再往上则是 G1 收集器。

## 第六章 类文件结构

**字节码（Byte Code）**是构成平台无关性的基石，Class 文件则是一种存储格式，存储了字节码。

任何一个 Class 文件都对应着唯一的一个类或接口的定义信息，但一个类或者接口的定义信息不一定需要一磁盘文件的形式存在（如动态生成）。

**Class 文件**是一组以 8 个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件之中。

**Class 文件格式**采用类似 C 语言结构体的伪结构来存储数据，只有两种数据类型：

- 无符号数，属于基本的数据类型，以 u1、u2、u4、u8来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数，
- 表，由多个无符号数或者其他表作为数据项构成的**复合数据类型**，所有表的命名统一以 “_info” 结尾。

Class 文件本质可以看作是一张表：

![image-20210221151700943](https://gitee.com/zhxuankun/Image/raw/master/Avator/image-20210221151700943.png)

当需要描述某一类型数据的不定多个数据时，经常会使用一个前置的计数器 + 若干个连续的数据项。

### 6.1 Class 文件格式

#### 6.1.1 魔数

**魔数**，Class 文件固定为 `0xCAFEBABE`，其他格式的文件如 png 等通常开头也会有自己的魔数。

#### 6.1.2 版本号

**版本号**，跟在魔数后面的 4 个字节，前两个字节为字版本号，后两个字节为主版本号。

> NOTE：《Java虚拟机规范》 规定，JVM 可以执行小于当前规定版本号的 Class 文件，但必须拒绝执行超过其版本号的 Class 文件。

#### 6.1.3 常量池

**常量池**，是 Class 文件结构中与其他项目关联最多的数据，通常也是占用 Class 文件空间最大的数据项目之一。

由于常量池里常量的数目是不固定的，因此会先有一个 u2 类型的常量计数器，指定有多少个常量，并且这个计数器是从 1 开始的，保留 0 是为了应对需要表达外部不指向常量池任何常量的特殊场景。

常量池中主要存放两大类常量：**字面量（Literal）**和**符号引用（Symbolic References）**。

字面量

更接近于 Java 语言层面的常量概念，如文本字符串、被声明为final的常量值等。

符号引用属于编译原理方面的概念，主要包括下面几类常量：

- 被模块导出或者开放的包（Package） 
- 类和接口的全限定名（Fully Qualified Name） 
- 字段的名称和描述符（Descriptor） 
- 方法的名称和描述符 
- 方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic） 
- 动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）

Java 代码进行编译的时候，不像 C 与 C++ 那样有连接的步骤，而是直到 JVM 加载 Class 文件的时候进行动态链接，对 Class 文件中的信息在运行期进行转化，解析、翻译到具体的内存地址中。

常量池中的每一项都是表，表结构的起始第一位是一个 u1 类型的标志位，代表当前常量属于那种类型：

![image-20210221153853307](https://gitee.com/zhxuankun/Image/raw/master/Avator/image-20210221153853307.png)

每个类型都有其对应的结构：

![image-20210221161501479](https://gitee.com/zhxuankun/Image/raw/master/Avator/image-20210221161501479.png)

![image-20210221161527979](https://gitee.com/zhxuankun/Image/raw/master/Avator/image-20210221161527979.png)

![image-20210221161538688](https://gitee.com/zhxuankun/Image/raw/master/Avator/image-20210221161538688.png)

通常我们执行 `javap -verbose` 即可自动计算出 Class 常量池各个常量的类型。

#### 6.1.4 访问标志

**访问标志（access_flags）**，u2 类型，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口；是否定义为 public 类型；是否定义为 abstract 类型；如果是类的话，是否被声明为 final 等等。

![image-20210221162058863](https://gitee.com/zhxuankun/Image/raw/master/Avator/image-20210221162058863.png)

访问标志是由各个标志值做 `|` 操作计算得出的。

#### 6.1.5 类索引、父类索引与接口索引集合

**类索引（this_class）**和**父类索引（super_class）**都是一个 u2 类型的数据，而**接口索引集合 （interfaces）是一组 u2 类型的数据的集合**（可以声明多个接口），Class 文件借助这三个索引来确定该类型的继承关系。

类的索引最后都会指向 CONSTANT_Class_info。

#### 6.1.6 字段表集合

**字段表（field_info）**用于描述接口或者类中声明的变量，包括类变量、实例变量，但不包括方法中定义的局部变量。

字段表的结构如下：

![image-20210221183922671](https://gitee.com/zhxuankun/Image/raw/master/Avator/image-20210221183922671.png)

其中 access_flags 的类型如下：

![image-20210221184340981](https://gitee.com/zhxuankun/Image/raw/master/Avator/image-20210221184340981.png)

name_index 代表对字段的简单名称的引用。

descriptor_index 代表对字段和方法的描述符。

这里涉及几个概念：

- 全限定名称：表示类的全名，例如：`java/lang/Thread;`.

- 简单名称：没有类型和参数修饰的方法名或者字段名称，如上面线程类中的方法 `sleep`。

- 描述符：

  - 描述方法时，按照先参数列表、后返回值的顺序描述，参数放置在一组 `()` 内。

  - 基本数据类型以及无法返回值的 void 类型都用一个大写字母表示，如 `()I`
  - 对象类型则用字符 L + 对象的全限定名表示，如 `()Ljava/lang/Integer`
  - 数组类型，则在原有类型基础上，增加一个前缀 `[`

![image-20210221184855300](https://gitee.com/zhxuankun/Image/raw/master/Avator/image-20210221184855300.png)

字段表集合内不会出现父类或者父类接口继承的字段，但可能出现原本 Java 代码中不存在的字段，例如内部类为了保持对外部类的访问，编译器会添加一个指向外部实例的字段。

#### 6.1.7 方法表集合

方法表集与字段表集合结构类似：

![image-20210221190045008](https://gitee.com/zhxuankun/Image/raw/master/Avator/image-20210221190045008.png)

access_flag 如下：

![image-20210221190101159](https://gitee.com/zhxuankun/Image/raw/master/Avator/image-20210221190101159.png)

方法里面的代码，则存储在方法表属性集合（attributes）中一个名为 “Code” 的属性里。

与字段表类似，如果没有重写父类的方法，则不会出现父类的方法不会出现在子类方法表中，但也可能出现编译器自行添加的方法（如 `<clinit>`、`<init>`)。

> NOTE：《Java虚拟机规范》以及《Java语言规范》分别定义了字节码层面以及 Java 语言层面的特征签名，Java 的特征签名只包含方法名、参数顺序、参数类型，这也是为什么 Java 无法依靠返回值进行重载的原因。

#### 6.1.8 属性表集合

Class文件、字段表、方法表都可以携带自己的属性表集合，以描述某些场景专有的信息，且限制比 Class 文件稍微宽松一些。

只要不与《Java虚拟机规范》已有属性名冲突，任何人实现的编译器都可以向属性表中写入自定义属性信息，JVM 运行的时候会自动忽略掉不认识的属性。

《Java虚拟机规范》最初只预定义了9项所有Java虚拟机实现都应当能识别的属性，在最新的《Java虚拟机规范》的 Java SE 12 版本中增加到了 29 种。

![image-20210221191222285](https://gitee.com/zhxuankun/Image/raw/master/Avator/image-20210221191222285.png)

![image-20210221191238318](https://gitee.com/zhxuankun/Image/raw/master/Avator/image-20210221191238318.png)

属性表中的每一个属性都需要一个 u2 类型的索引指向 CONSTANT_Utf8_info 来表示自己的名称，接着通过一个 u4 的长度属性说明属性值所占的位数：

![image-20210221191432539](https://gitee.com/zhxuankun/Image/raw/master/Avator/image-20210221191432539.png)

### 6.2 字节码指令

JVM 的指令由两部分组成：

- **操作码（Opcode）**：一个字节长度的、代表着某种特定操作含义的数字
- **操作数（Operand）**：跟随操作码后面的零至多个代表此操作所需的参数

字节码指令集优劣势都很明显，首先劣势如下：

1. 操作码的长度为 1 个字节，因此最多表示 256 种指令。
2. Class 文件放弃了编译后代码的操作数对齐，因此 JVM 在处理超过 1 个字节的数据时必须从运行时重建出具体数据的结构，如表示一个 16 位的操作数 ：(byte1 << 8) | byte2。这时会损失一些性能。

优势也很明显，就是可以省略掉大量的填充和间隔符号。

字节码指令集中，大部分指令都包含了其操作所对应的数据类型，i 代表对 int 类型的数据操作，l 代表 long，s 代表 short，b 代表 byte，c 代表 char，f 代表 float，d 代表 double，a 代表 reference。

由于操作码所能表示的指令类型有限，因此并非每种数据类型和每种操作类型都有对应的指令，部分单独的指令在必要的时候，会将为支持的数据类型其转化为支持的数据类型。

> NOTE：例如 byte、short、char 以及 boolean，部分指令未提供支持，而是将其转化为 int 再调用 int 的指令进行操作。

![image-20210222213610858](https://gitee.com/zhxuankun/Image/raw/master/Avator/image-20210222213610858.png)

#### 6.2.1 加载和存储指令

加载和存储指令用于**将数据在栈帧中的局部变量表和操作数栈之间来回传输**：

- 将一个局部表的变量加载到操作栈：iload、`iload_<n>`、lload、`lload_<n>`、fload、`fload_<n>`、dload、 `dload_<n>`、aload、`aload_<n>`。
- ·将一个数值从操作数栈存储到局部变量表：istore、`istore_<n>`、lstore、`lstore_<n>`、fstore、 `fstore_<n>`、dstore、`dstore_<n>`、astore、`astore_<n>`。
- 将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、 `iconst_<i>`、`lconst_<l>`、`fconst_<f>`、`dconst_<d>`。
- 扩充局部变量表的访问索引的指令：wide。

除了上述指令之外，还有少量指令（如访问对象的字段或数组元素的指令）也会向操作数栈传输数据。

尖括号内的符号，代表了 0、1、2、3 这几条指令，主要是为了省去取操作数的动作。

#### 6.2.2 运算指令

算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。

- 加法指令：iadd、ladd、fadd、dadd
- 减法指令：isub、lsub、fsub、dsub
- 乘法指令：imul、lmul、fmul、dmul
- 除法指令：idiv、ldiv、fdiv、ddiv
- 求余指令：irem、lrem、frem、drem
- 取反指令：ineg、lneg、fneg、dneg
- 位移指令：ishl、ishr、iushr、lshl、lshr、lushr
- 按位或指令：ior、lor
- 按位与指令：iand、land
- 按位异或指令：ixor、lxor
- 局部变量自增指令：iinc
- 比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp

算数指令大体上可以分为整型数据以及浮点型数据两种运算指令，并且在溢出和被零除的时候行为也各不相同。

《Java虚拟机规范》中并没有明确定义过整型数据溢出具体会得到什么计算结果，仅规定了在处理整型数据时，只有除法指令（idiv和ldiv）以及求余指令（irem和lrem）中当出现除数为零时会导致虚拟机抛出 `ArithmeticException` 异常，其余任何整型数运算场景都不应该抛出运行时异常。

《Java虚拟机规范》要求虚拟机实现在处理浮点数时，必须完全支持 `IEEE 754` 中定义的 “非正规浮点数值”（Denormalized Floating-Point Number）和“逐级下溢”（Gradual Underflow）的运算规则。

IEEE 754 规范中的默认舍入模式，称为向最接近数舍入模式，如果有两种可表示的形式与该值一样接近，那将优先选择最低有效位为零的。

在 JVM 中，当浮点数向整形转化时，会导致小数点部分被丢弃，机在处理浮点数运算时，不会抛出任何运行时异常（指 Java 语言的异常，而非 IEEE 754 的浮点数异常，那种属于一种运算信号）。，当一 个操作产生溢出时，将会使用有符号的无穷大来表示；如果某个操作结果没有明确的数学定义的话， 将会使用NaN（Not a Number）值来表示。所有使用NaN值作为操作数的算术操作，结果都会返回 NaN。

#### 6.2.3 类型转换指令

类型转换指令一般用与用户代码中的显示转换，或者字节码中对应类型没有对应类型指令操作时所做的转换。

JVM 直接支持以下数值类型的**宽化类型转换（Widening Numeric Conversion）**：

- int 到 long、float、double 类型
- long 到 float、double 类型
- float 到 double 类型

处理**窄化类型转换（Narrowing Numeric Conversion）**时，就必须显示指定转化命令：括i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l 和 d2f。

窄化类型转换可能导致转换的结果有不同的正负号以及不同数量级，同时还可能导致精度丢失。

整形与浮点型在做窄化类转换时，需要遵循不同的规则：

- int、long 转化为整数类型 T 时，只需要保留最低 N（N 为 T 的位数）位数据即可。
- 浮点型转化为证书类型时，规则如下：
  - 如果浮点值是 NaN，那么转化结果就是 int 或 long 类型的 0；
  - 如果浮点值不是无穷大，使用 IEEE 754 的向零舍入模式取整获得整数值 v：
    - 如果 v 在所求类型范围内，则转换结果为 v
    - 如果 v 在所求类型范围外，则转化结果根据 v 的符号转化为该类型的最大值或者最小值正数。
  - double 转 float 则遵循 IEEE 754 的定义，向最接近数舍入模式舍入得到一个可以使用 flat 类型表示的数字：
    - 如果转换值的太小超出 float 范围，则返回 float 的正负零值
    - 如果转换值的太大超出 float 范围，则返回 float 的无穷大
    - double 的 NaN 值转化为 float 的 NaN 值

#### 6.2.4 对象创建与访问指令

- 创建类实例的指令：new
- 创建数组的指令：newarray、anewarray、multianewarray
- 访问类字段（static字段，或者称为类变量）和实例字段（非static字段，或者称为实例变量）的指令：getfield、putfield、getstatic、putstatic
- 把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload
- 将一个操作数栈的值储存到数组元素中的指令：bastore、castore、sastore、iastore、fastore、dastore、aastore
- 取数组长度的指令：arraylength
- 检查类实例类型的指令：instanceof、checkcast

#### 6.2.5 操作数栈管理指令

JVM 也提供而了一些直接操作操作数栈的指令：

- 将操作数栈的栈顶一个或两个元素出栈：pop、pop2
- 复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2
- 将栈最顶端的两个数值互换：swap

#### 6.2.6 控制转移指令

控制转移指令可以让 JVM 有条件或无条件地从指定位置指令（**而不是控制转移指令**）的下一条指令继续执行程序，从概念上可以认为是在有条件/无条件地修改程序计数器。

控制转移指令如下：

- 条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne
- 复合条件分支：tableswitch、lookupswitch
- 无条件分支：goto、goto_w、jsr、jsr_w、ret

JVM 有专门的指令集用于比较 int 与 reference 类型，也有专门的指令用来检测 null 值。

boolean、byte、char、short 类型的条件分支比较，都会调用 int 的比较指令完成。

long、float、double 类型的条件分支比较，会先执行对应类型的比较运算指令（dcmpg、dcmpl、fcmpg、fcmpl、lcmp），运算指令会返回一个整型值到操作数栈中，随后再执行 int 类型的分支条件比较来完成整个分支跳转。

int 的比较指令使用的最多的，因此也是设计最为丰富、强大。

#### 6.2.7 方法调用和返回指令

- invokevirtual指令：用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），这也是Java语言中最常见的方法分派方式。

- invokeinterface指令：用于调用接口方法，它会在**运行时**搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。

- invokespecial指令：用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。

- invokestatic指令：用于调用类静态方法（static方法）。

- invokedynamic指令：用于在运行时动态解析出调用点限定符所引用的方法。并执行该方法。


前面四条调用指令的分派逻辑都固化在 Java 虚拟机内部，用户无法改变，而 invokedynamic 指令的分派逻辑是由用户所设定的引导方法决定的。

方法调用与数据类型无关，方法返回指令则根据返回值的类型来区分。

#### 6.2.8 异常处理指令

Java 程序显示抛出异常，以及检测到异常状况时抛出一些运行异常，都由 athrow 指令实现。

处理异常（catch）语句不是由字节码指令实现的，而是采用异常表完成。

#### 6.2.9 同步指令

JVM 可以支持方法级的同步以及方法内部一段指令序列的同步，借助锁（管程，Monitor）实现。

方法级别的同步是隐式的，无需借助字节码指令实现，而是通过查询方法表中的 ACC_SYNCHRONIZED 访问标志来确定该方法是否为同步方法。如果是，执行线程则需要先获取锁，然后才能执行方法，方法执行结束时释放锁。

如果方法运行期间抛出了异常，且方法内部无法处理该异常，则在异常被抛到方法边界外时才会释放锁。

一段同步指令需要编译器即 JVM 协同配合，编译器确保在执行同步代码前，生成一个 monitorenter 指令获取锁，且之后都有其对应的 monitorexit 指令释放锁，无论方法是否正常结束。

## 第七章 虚拟机类加载机制

一个类型被加载直到卸载，在 JVM 中的生命周期如下：

1. 加载（Loading）
2. 连接（Linking）
   1. 验证（Verification）
   2. 准备（Preparation）
   3. 解析（Resolution）
3. 初始化
4. 使用
5. 卸载

![image-20210225190052778](https://gitee.com/zhxuankun/Image/raw/master/Avator/image-20210225190052778.png)

> NOTE：与那些在编译时需要进行连接的语言不同，在 Java 语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的。

加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地**开始**，而**解析阶段则不一定，一些情况下可以在初始化之后再开始**（为了实现 Java 语言的运行时特性，即动态绑定）。

> NOTE：类加载的各个阶段是交叉的，因此上文说的是开始，而非进行。

### 7.1 类加载的时机

《Java虚拟机规范》没有规定什么时候进行类的加载，但规定了有且仅有以下 6 种情况时必须立刻进入初始化阶段（加载、验证、准备一定在这阶段之前进行）：

1. 遇到 new、getstatic、putstatic 或 invokestatic 这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。典型的 Java 场景有：
   - 使用 new 关键字新建一个实例化对象。
   - 读取或者设置一个类型的静态字段（**final 修饰编译期就已放入常量池**的静态常量除外）。
   - 调用一个类型的静态方法。
2. 对一个尚未初始化过的类型进行反射调用（java.lang.reflect)的时候。
3. 初始化类时，如果父类尚未初始化则需先初始化
4. JVM 启动时，指定的 main 方法所在类需要先初始化。
5. JDK7 新添加的动态语言支持，一个 java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。
6. JDK8 中接口的默认方法，如果该接口的实现类发生了初始化，尚未初始化的接口需要在这之前初始化。

这六种行为称为对一个类型的主动引用，其他类型的引用都不会触发初始化，称为被动引用:

```java
package org.fenixsoft.classloading;
/**
* 被动使用类字段演示一：
* 通过子类引用父类的静态字段，不会导致子类初始化
**/
public class SuperClass {
	static {
		System.out.println("SuperClass init!");
	}
	public static int value = 123;
}

public class SubClass extends SuperClass {
	static {
		System.out.println("SubClass init!");
	}
}

/**
* 非主动使用类字段演示一
**/
public class NotInitialization {
	public static void main(String[] args) {
		System.out.println(SubClass.value);
	}
}

// 输出结果：
SuperClass init!
    
    
/**
* 被动使用类字段演示二：
* 通过数组定义来引用类，不会触发此类的初始化
**/
public class NotInitialization {
	public static void main(String[] args) {
		SuperClass[] sca = new SuperClass[10];
	}
}


/**
 * 被动使用类字段演示三：
 * 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的
类的初始化
**/
public class ConstClass {
	static {
		System.out.println("ConstClass init!");
	}
	public static final String HELLOWORLD = "hello world";
}

public class NotInitialization {
	public static void main(String[] args) {
		System.out.println(ConstClass.HELLOWORLD);
	}
}
```

演示三中，ConstClass 类的常量 HELLOWORLD 在编译阶段通过常量传播优化，已将其直接存储在了 NotInitialization 的常量池中，这两个类在编译后就没有任何联系了，NotInitialization 文件中并没有 ConstantClass 的符号引用。

接口较为特殊，并不能使用 static{} 代码块，但编译器会为其生成 `<clinit>()` 类构造器，用于初始化接口中所定义的成员变量。一个接口在初始化时，并不会要求其父接口也初始化，只有在真正使用到父接口（如引用接口中定义的常量）的时候才会初始化。

### 7.2 类加载的过程

## 第十二章 高效并发

现代计算机开始向多核并发方向发展，这种系统称为**共享内存多核系统（Shared Memory Multiprocessors System）**：

![image-20210226125308223](https://gitee.com/zhxuankun/Image/raw/master/Avator/image-20210226125308223.png)

增加高速缓存的目的是为了解决 CPU 与内存之间速度高度不一致的问题，但同时也带来了内存不一致的问题。因此也出现了一系列解决这个问题的协议，如 MSI、MESI（Illinois Protocol）、MOSI、Synapse、Firefly 及 Dragon Protocol 等。

处理器为了充分利用运算单元，可能会对输入的代码进行**乱序执行（Out-Of-Order Execution）**优化，同时，JVM 的 JIT 也有**指令重排序（Instruction Reorder）**优化。

### 12.1 Java 内存模型

Java 内存模型从 JDK1.2 开始建立，到 JDK5（实现了 JSR-133）开始正式成熟、完善起来。

Java 内存模型主要关注变量值存储到内存以及从内存中取出变量值的底层细节。

Java内存模型规定了所有的变量都存储在**主内存（Main Memory）**中，每条线程有自己的**工作内存（Working Memory）**，线程的工作内存中保存了被该线程使用的变量的**主内存副本**，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据。线程间变量值的传递均需要通过主内存来完成。线程、工作内存、主内存三者交互管辖如下：

![image-20210226141417031](https://gitee.com/zhxuankun/Image/raw/master/Avator/image-20210226141417031.png)

#### 12.1.1 内存间交互工作

Java 内存模型定义了以下 8 种操作必须是原子的，不可再分的（double、long 类型的 load、store、read、write 在不同平台有例外）：

- **lock（锁定）**：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
- **unlock（解锁）**：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
- **read（读取）**：作用于主内存的变量，它把一个**变量的值**从主内存传输到线程的工作内存中，以便随后的 load 动作使用。
- **load（载入）**：作用于工作内存的变量，它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。
- **use（使用）**：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。
- **assign（赋值）**：作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
- **store（存储）**：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。
- **write（写入）**：作用于主内存的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中

如果要把一个变量从主内从拷贝到工作内存，则需要经过 read、load 操作，如果要把一个变量从工作内存拷贝到主内存，则需要经过 store、write 操作。

Java 内存模型只要求上述的两个操作有前后顺序，但并不一定是连续进行的。

Java 内存模型还规定了 8 中基本操作必须满足如下规则：

- 不允许 read 和 load、store 和 write 操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起回写了但主内存不接受的情况出现。
- 不允许一个线程丢弃它最近的 assign 操作，即变量在工作内存中改变了之后必须把该变化同步回主内存（**同步时机不确定**）。
- 不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从线程的工作内存同步回主内存中。
- 一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load 或 assign）的变量，换句话说就是对一个变量实施 use、store 操作之前，必须先执行 assign 和 load 操作。
- 一个变量在同一个时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。
- 如果对一个变量执行 lock 操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作以初始化变量的值。
- 如果一个变量事先没有被 lock 操作锁定，那就不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定的变量。
- 对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中（执行 store、write 操作）。

可以将 Java 内存模型的操作简化为 read、write、lock 和 unlock 四种，但这只是语言层面的简化，底层模型仍为上面的 8 种。

#### 12.1.2 volatile

volatile 是 Java 内存模型提供的最轻量级的同步机制。

volatile 保证了工作内存中对该类型的变量进行 read 操作（不保证后续操作）的时候，能够读到最新的值。

普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致（Within-Thread As-If-Serial Semantics）。

volatile 禁止了指令重排序，通过添加内存屏障（字节码表现为添加了一个 lock 指令），指令重排序时不能把 lock 后面的指令重排序到 lock 前面。

> NOTE：查询IA32手册可知，lock 前缀的作用是将本处理器的缓存写入主存中，该写入动作也会导致其他处理器缓存中对应的值失效，也就是做了一次 store、write 操作（MESI 协议）。

处理器允许指令重排序，但如果两条指令之间有依赖，那么这两条指令是不允许重排序的，但如果第三条指令对前面两条指令都没有一来，那么第三条指令可能会被重排序到前两条指令之间。最终结果看来，重排序后的代码看起来已经是有序的。

volatile 性能并不一定比 synchronized 快（JVM 对锁实现了许多消除和优化），但绝大部分场景下是优于 synchronized 的，因此选择是否使用 volatile 仅取决于是否能够满足场景需求。

针对 double、long 这种 64 位数据的读写操作，Java 内存模型中特别定义了一条宽松的规定：允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行，即允许虚拟机实现自行选择是否要保证 64 位数据类型的 load、store、read 和 write 这四个操作的原子性。至于是否实现原子性交由 JVM 决定。

对于 long 类型，在 64 位 JVM 并不会出现非原子的访问行为，而在 32 位 JVM 可能出现（JDK9 可以通过 -XX:+AlwaysAtomicAccesses 强制原子性访问）。

对于 double，现代 CPU 通常都有专门处理单、双精度的浮点数据，因此 32 位 JVM 通常也不会出现非原子性访问的问题。

#### 12.1.3 原子性、可见性与有序性

**原子性（Atomicity）**，Java 内存模型直接保证的原子性**变量操作**有：read、load、use、assign、store、write，可以大致认为，**基本数据类型的访问、读写都是具备原子性的**；如果需要一个更大范围的原子性保证，则需要用到 lock、unlock 操作，字节码表现为 monitorenter、monitorexit，Java 语法层面表现为 synchronized。

**可见性（Visibility）**，当一个线程修改了共享变量时，其他线程能够立即得知这个修改。Java 内存模型是通过内存之间的传递来实现可见性的，普通变量与 volatile 变量都是如此，只不过 volatile 的特殊规则保证了新值能够立刻刷新到主存中，而普通变量不能保证。

除了 volatile 之外，还有 synchronized 和 final 也能实现可见性：

- synchronized 的底层是 lock、unlock 操作，unlock 操作之前，也有个必须把变量刷新到主存中的规定。
- final 修饰的字段一旦在构造其中被初始化完成，并且构造器没有把 “this” 的引用传递出去（this 逃逸，可能导致外部访问到一个 ”初始化了一半“ 的对象），那么外部能访问到构造器的时候，也一定能访问到 final 字段。

**有序性**，如果在一个线程内观察，那么所有操作都是有序的（Within-Thread As-If-Serial Semantics）；如果一个线程观察另一个线程，所有的操作都是无序的（指令重排序、工作内存与主内存同步延迟）。

#### 12.1.4 先行发生原则

Happens-Before 原则，是Java内存模型中定义的两项操作之间的偏序关系一个操作。

如果说操作 A 先发生于操作 B 之前，那么也就意味着操作 B 发生时，操作 A 的影响能被操作 B 观察到。这个影响包括修改了内存中的值，发送了消息，调用了方法等。

Java 内存模型下存在一些 “天然” 的先行发生关系，无序任何同步器协助就已经存在（如果不符合以下任意一条规则，就可能会被 JVM 进行重排序）：

- **程序次序规则（Program Order Rule）**：在**一个线程**内，按照**控制流顺序**，书写在前面的操作先行发生于书写在后面的操作。注意，这里说的是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。
- **管程锁定规则（Monitor Lock Rule）**：一个 unlock 操作先行发生于后面对**同一个锁**的 lock 操作。“后面”是指时间上的先后。
- **volatile变量规则（Volatile Variable Rule）**：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后。
- **线程启动规则（Thread Start Rule）**：Thread 对象的 start() 方法先行发生于此线程的每一个动作。
- **线程终止规则（Thread Termination Rule）**：线程中的所有操作都先行发生于对此线程的终止检测，可以通过 Thread::join() 方法是否结束、Thread::isAlive() 的返回值等手段检测线程是否已经终止执行。
- **线程中断规则（Thread Interruption Rule）**：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 Thread::interrupted() 方法检测到是否有中断发生。
- **对象终结规则（Finalizer Rule）**：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。
- **传递性（Transitivity）**：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那就可以得出操作 A 先行发生于操作 C 的结论。

只有符合上面这些场景，Java 语言才能无需任何同步手段就能保证先行原则成立。其他场景，即使某个操作先发生于下一个操作，也可能由于重排序等原因，无法保证在时间顺序上是先发生于下一个操作的。

> NOTE：要注意区分先行发生，时间上的先行发生，先行发生原则。

### 12.2 Java 与线程

并发可以依赖于多进程、多线程实现，而 Java 是依赖于多线程来实现并发的。

线程的引入，可以**把一个进程的资源分配和执行调度分开**，各个线程既可以共享进程资源（内存地址、文件I/O等），又可以独立调度。

实现线程主要有三种方式：使用**内核线程实现**（1：1实现），使用**用户线程实现**（1：N实现）， 使用**用户线程加轻量级进程混合实现**（N：M实现）。

#### 12.2.1 内核线程实现

使用内核线程实现的方式也被称为1：1实现。**内核线程（Kernel-Level Thread，KLT）**就是直接由操作系统内核（Kernel，下称内核）支持的线程，这种线程由内核来完成线程切换，内核通过操纵**调度器（Scheduler）**对线程进行调度，并负责将线程的任务映射到各个处理器上。

通常所说的 Java 线程，实际上是使用内核线程的一种高级接口——轻量级进程（Light Weight Process，LWP），由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。这种轻量级进程与内核线程之间 1:1 的关系称为一对一的线程模型：

![image-20210227163750699](https://gitee.com/zhxuankun/Image/raw/master/Avator/image-20210227163750699.png)

轻量级进程的优势：

- 基于内核线程的支持，每个轻量级线程都能成为一个独立的调度单元，即使其中一个轻量级线程阻塞了，也不会影响整个进程的继续工作。

轻量级进程的局限性：

- 由于是基于内核线程实现的，因此一些操作涉及到了 用户态-内核态 的切换，代价较高。
- 每个轻量级进程都需要一个内核线程的支持，因此轻量级进程需要消耗一定的内核资源（如内核线程的栈空间）。

#### 12.2.2 用户线程实现

使用用户线程实现的方式被称为 1:N 实现。

广义上来讲，一个线程只要不是内核线程，都可以认为是用户线程（User Thread，UT）。轻量级进程除外，因为其始终是建立内核线程之上的。

狭义上来讲，用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知到用户线程的存在以及具体实现。用户线程的简历、同步、销毁以及调度都在用户态完成。

用户线程不需要进行内核态的切换，因此操作是非常快速且低消耗的。这种进程与用户线程之间 1:N 的关系成为 一对多模型：

![image-20210227164803879](https://gitee.com/zhxuankun/Image/raw/master/Avator/image-20210227164803879.png)

用户线程的优势在不需要系统内核的支持，但劣势也在于此：

- 线程所有的操作都需要用户程序自己去处理。
- 部分具体操作问题解决起来异常困难，甚至不可能实现。

Java、Ruby 等语言曾经使用过用户线程，但最终都放弃转为使用轻量级进程，而今年来的高并发语言 GoLang、Erlang 等又使用了用户线程实现。

#### 12.2.3 混合实现

线程还有一种将内核线程与用户线程一起使用的实现方式，被称为 N:M 实现。在这种混合实现下，既存在用户线程，也存在轻量级进程。此时用户线程、轻量级进程的特性都可以使用，用户线程同轻量级进程的数量比比是不同的，属于 N:M 关系：

![image-20210227170350344](https://gitee.com/zhxuankun/Image/raw/master/Avator/image-20210227170350344.png)

#### 12.2.4 Java线程的实现及调度

《Java 虚拟机》 规范并未限定 Java 线程使用那种线程模型实现，这些取决于具体 JVM 的实现，但当前主流的 JVM 都是基于轻量级进程去实现的。

线程调度是指系统为线程分配处理器使用权的过程，调度主要方式有两种：

1. 协同式 （Cooperative Threads-Scheduling）线程调度。
   - 线程执行的时间由线程自己决定，当线程执行完成后，主动通知其他线程进行切换。
   - 实现简单，但线程时间不可控制，线程可能一直不切换导致整个系统崩溃。
2. 抢占式（Preemptive Threads-Scheduling）线程调度。
   - 每个线程运行时间交由系统分配，切换不由线程本身决定；Java 中可以用过 Thread::yield 来主动让出执行时间。
   - 想要主动获取执行没有什么太好的方法，因为最终也是映射到系统的原生线程实现的，只能通过设置优先级（不稳定）的方式来建议操作系统给某些线程分配多点执行时间。

> NOTE：依靠优先级并不稳定的原因是，Java 定义了 10 个优先级，但不同操作系统优先级的数量并不一致。

#### 12.2.5 线程的状态

- **新建（New）**：创建后尚未启动的线程处于这种状态。
- **运行（Runnable）**：包括操作系统线程状态中的 Running 和 Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着操作系统为它分配执行时间。
- **无限期等待（Waiting）**：处于这种状态的线程不会被分配处理器执行时间，它们要等待被其他线程显式唤醒。以下方法会让线程陷入无限期的等待状态：
  - 没有设置 Timeout 参数的 Object::wait() 方法；
  - 没有设置 Timeout 参数的 Thread::join() 方法；
  - LockSupport::park() 方法。
- **限期等待（Timed Waiting）**：处于这种状态的线程也不会被分配处理器执行时间，不过无须等待被其他线程显式唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：
  - Thread::sleep() 方法；
  - 设置了 Timeout 参数的 Object::wait() 方法；
  - 设置了 Timeout 参数的 Thread::join() 方法；
  - LockSupport::parkNanos()方法；
  - LockSupport::parkUntil()方法。
- **阻塞（Blocked）**：线程被阻塞了，“阻塞状态” 与 “等待状态” 的区别是 “阻塞状态” 在等待着获取到一个排它锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。
- **结束（Terminated）**：已终止线程的线程状态，线程已经结束执行。

几种状态之间转化关系如下：

![image-20210227200608082](https://gitee.com/zhxuankun/Image/raw/master/Avator/image-20210227200608082.png)

#### 12.2.5 Java 与协程

Java 基于轻量级线程实现的线程方案，随着时代的发展渐显疲态，内核线程切换的开销开始逐渐接近计算成本。

内核线程的调度成本主要来自于 用户态-内核态 之间的切换，而这两种状态转换的开销主要来源于**响应中断**，**保护**和**恢复现场**。

从硬件层面来看，每一次用户态-内核态的切换，就会引发内存、缓存、寄存器之间的来回拷贝。

协程属于用户线程，相比内核线程轻量许多，现存的问题主要是实现较为复杂，需要在应用层面实现的内容特别多。

OpenJDK 在 2018 年创建了Loom 项目，对有栈协程进行了实现，称为**纤程（Fiber）**。

在新并发模型下，一段使用纤程并发的代码会被分为两部分——**执行过程（Continuation）**和**调度器（Scheduler）**：

- 执行过程主要用于维护执行现场，保护、恢复上下文状态
- 调度器则负责编排所 有要执行的代码的顺序。

将执行过程与调度器分开的好处是用户可以自由选择控制其中的一个或者多个，Loom 中默认的调度器就是原来已存在与任务分解的 Fork/Join 池。

## 第十三章 线程安全与锁优化

> 当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的。
>
> ——《Java并发编程实战》

由于要实现绝对的线程安全，十分难以实现并且可能付出十分巨大的代价，因此我们通常会对线程安全作出一定的弱化。

### 13.1 Java 语言中的线程安全

Java 的线程安全概念，不是一个非真即假的二元排他选项，而是按照安全程度由强至弱来排序的，可以大致的分为五类：：**不可变**、**绝对线程安全**、**相对线程安全**、**线程兼容和线程对立**。

#### 13.1.1 不可变

Java 语言中，如果多线程共享的数据是一个基本数据类型，那么只要在定义时使用 final 关键字修饰它就可以保证它是不可变的。如果共享数据是一个对象，由于 Java 语言目前暂时还没有提供值类型的支持，那就需要对象自行保证其行为不会对其状态产生任何影响才行（最简单的就是将内部状态变量设置为 final）。

Java 中常见不可变的类型有 String，枚举类，java.lang.Number 的部分子类等。

#### 13.1.2 绝对线程安全

许多标注自己是线程安全的类，大多数都不是绝对线程安全的，根据使用的方式，也会产生线程不安全的情况。例如多个线程对 Vector 进行删除与读取操作。

#### 13.1.3 相对线程安全

相对线程安全就是绝大部分场景下所讲的线程安全，它需要保证对这个对象单次的操作是线程安全的。在调用的时候不需要进行额外的保障措施，但是对于一些**特定顺序的连续调用**，就可能需要在调用端使用额外的同步手段来保证调用的正确性。

#### 13.1.4 线程兼容

线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。

#### 13.1.5 线程对立

线程对立是指不管调用端是否采取了同步措施，都无法在多线程环境中并发使用代码。

Java 中这类代码较为少见，如线程类的 suspend() 和 resume() 方法，以及 System.setIn()、Sytem.setOut() 和 System.runFinalizersOnExit() 等。

> NOTE：如果一个线程执行了 suspend()，之后即使线程在后续代码中分别执行了 suspend() 以及 resume()，也可能由于指令重排序，先执行了 resume() 再执行  suspend()，导致线程挂起。

### 13.2 线程安全的实现方法

#### 13.2.1 互斥同步

**互斥同步（Mutual Exclusion & Synchronization）**是一种最常见也是最主要的并发正确性保障手段：

- 同步是指多线程并发访问数据时，保证数据在同一时刻仅被一个线程使用。
- 互斥是一种同步手段，临界区（Critical Section）、互斥量 （Mutex）和信号量（Semaphore）都是常见的互斥实现方式。

互斥同步中，互斥是因，同步是果，互斥是方法，同步是目的。

Java 中最常见的互斥同步手段就是 synchronized 以及 J.U.C 包中的 Lock 接口。

synchronized 有两个注意点：

- synchronized 修饰的同步块对持有锁的同一线程是可重入的，即同一线程反复进入同步块也不会把自己锁死。
- synchronized 修饰的同步块持有锁的线程释放锁之前，会无条件的阻塞其他线程的进入。

持有锁是一个重量级的操作（主要来源于 用户态-内核态 的切换开销），锁自身的开销有时候甚至大于计算的开销。JVM 也做了一系列优化，比如锁消除、阻塞前做一段自旋等待等。

J.U.C 的 Lock 接口使用户能够以非块结构实现互斥同步，**重入锁（ReentrantLock）**是 Lock 接口最常见的一种实现。

Lock 接口提供了比 synchronized 更加丰富的语义：

- **等待可中断**：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。可中断特性对处理执行时间非常长的同步块很有帮助。
- **公平锁**：是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized 中的锁是非公平的，ReentrantLock在默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。不过一旦使用了公平锁，将会导致 ReentrantLock 的性能急剧下降，会明显影响吞吐量。
- **锁绑定多个条件**：是指一个 ReentrantLock 对象可以同时绑定多个 Condition 对象。在 synchronized 中，锁对象的 wait() 跟它的 notify() 或者 notifyAll() 方法配合可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外添加一个锁；而 ReentrantLock 则无须这样做，多次调用 newCondition() 方法即可。

JDK5 及之前，Lock 接口的性能在高并发情况下性能是远远高于 synchronized，从 JDK6 开始，JVM 对 synchronized 做了许多优化，大部分场景下性能基本相当，因此在较新版本的 JDK 中两者的选择可以只基于 synchronized 功能是否能够满足要求。

从长远来看，使用 synchronized 能够让 JVM 更容易的进行优化，JVM 可以从线程和对象的元数据获取锁的相关信息，而使用 Lock 接口，JVM 是很难得知哪些锁对象是由特定线程持有的。

#### 13.2.2 非阻塞同步

互斥同步面临的主要问题是进行线程阻塞和唤醒所带来的性能开销，因此这种同步也被称为**阻塞同步（Blocking Synchronization）**，属于一种悲观锁策略。

随着硬件指令的发展，现代处理器多了另一种选择：基于冲突检测的乐观并发策略，先进行操作，再检测是否存在冲突，如果冲突了，则进行一些补偿策略，不断重试，直到检测不到冲突成功提交为止。

> NOTE：现代处理器新增了一些原子性的指令，使得乐观锁的并发策略成为可能，比如 CAS 策略，在IA64、x86 指令集中有用 cmpxchg 指令完成的 CAS 功能，在 SPARC-TSO 中也有用 casa 指令实现的，而在 ARM 和 PowerPC 架构下，则需要使用一对 ldrex/strex 指令来完成 LL/SC 的功能。

Java 中暴露出来的乐观锁就是基于 CAS 策略的，提供了一些原子类来实现。

CAS 策略需要面临一个问题，即 ABA 问题，但绝大部分场景下，该问题都不会导致业务异常问题；如果要解决该问题，可以添加一个版本信息（当前的实现有 AtomicStampedReference），但是性能会较差，可能传统的互斥同步性能会更优。

#### 13.2.3 无同步方案

实现线程安全，也并不一定要使用阻塞同步或非阻塞同步，同步与线程安全两者没有必然的联系，有些代码就是天生线程安全的。

可重入代码以及线程本地存储都是天生线程安全的代码。

**可重入代码（Reentrant Code）**：这种代码又称**纯代码（Pure Code）**，是指可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误，也不会对结果有所影响。

可重入代码有一些共同特征：不依赖全局变量、存储在堆上的数据和公用的系统资源， 用到的状态量都由参数中传入，不调用非可重入的方法等。判断代码是否满足可重入性，可以看如果一个代码返回的结果是可以预测的，只要输入相同的结果，就都能返回相同的结果，那么就满足可重入性的要求，当然也就是线程安全的。

**线程本地存储（Thread Local Storage）**：如果一段代码中所需要的数据必须与其他代码共享，且能够把共享数据的可见范围限制在同一个线程之内，那么无需同步也能解决线程安全问题。常见的有 Web 交互模式一个请求对应一个服务器线程（Thread-per-Request），Java 的 java.lang.ThreadLocal 类等。

### 13.3 锁优化

互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，因此优化的核心思想就是尽可能少的让线程进入阻塞状态。

#### 13.3.1 自旋锁与自适应自旋

在很多应用中，共享数据的锁定状态只会持续很短的一段时间，因为这一点等待时间让线程进入阻塞状态并不值得。如果一个机器上有**一个以上的处理器或者处理器核心，可以同时让两个或以上的线程同时运行**，那么可以让后面请求锁的线程**不放弃处理器时间**，等待一会尝试能不能获取到锁，而不是立刻进入阻塞状态，这项技术就是**自旋锁**。

自旋锁在锁被占用时间很短的情况下效果很好，但如果锁占用的时间很长，那么就会浪费处理器资源。

线程在自旋一段时间后，如果还无法获取锁，则会进入传统的阻塞流程。JDK6 之后，自旋的次数修改为了自适应，会**根据同一个锁上过往的自旋时间以及拥有者的状态**，动态调整自旋次数。

#### 13.3.2 锁消除

锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。**锁消除的主要判定依据来源于逃逸分析的数据支持**。

如果判断一段代码中，在堆上的数据都不会被其他线程访问到，那么就可以将其当做栈上的数据处理，省去加锁的步骤。

> NOTE：有时候一些代码表面上看着不需要加锁，但经过编译器编译后，部分代码会变成加锁的代码。例如 JDK5 之前的 String 字符串拼接，编译后默认使用 StringBuffer 拼接。

#### 13.3.3 锁粗化

大部分场景下，同步块的作用范围越小越好，这样可以让需要同步的操作减少。但有些场景下，比如在循环中频繁加锁解锁，进行互斥同步操作，也会导致不必要的性能损耗。

JVM 如果检测到有一串零碎的操作都对同一个对象加锁，就会将加锁同步的范围扩展（粗化）到整个操作外部。

#### 13.3.4 轻量级锁

轻量级锁是相对传统的基于互斥量实现的重量级锁而言的。

轻量级锁的目的不是为了取代重量级锁，而是减少重量级锁使用操作系统互斥量产生的性能消耗。

轻量级锁主要依赖于对象的对象头的 Mark Word 来实现：

![image-20210228181130743](https://gitee.com/zhxuankun/Image/raw/master/Avator/image-20210228181130743.png)

对象的对象头可以分为存储对象自身运行时信息的 **Mark Word**，以及指向方法区对象类型数据的**类型指针**。

**加锁过程**：在代码即将进入同步块的时候，如果这时候对象还没有加锁（锁标志位 “00”），那么线程会在自身的栈帧中开辟一块内存空间，称为**锁记录（Lock Record）**。线程会通过 CAS 将对象的 Mark Word 替换为指向自身锁记录的指针，将对象的 Mark Word 存储到锁记录中。如果成功了，表示线程持有了该对象的锁，则修改锁标志位为 “00”：

![ ](https://gitee.com/zhxuankun/Image/raw/master/Avator/image-20210228181951338.png)

如果更新操作失败了，那就意味着至少存在一条线程与当前线程竞争获取该对象的锁。JVM 会检查该对象的 Mark 是否指向当前线程的栈帧：

- 如果是，则代表线程已持有锁，进入同步块继续执行即可
- 如果不是，说明这个对象已经被其他线程占用了，则立刻将其膨胀为重量级锁，并修改标志位位 “10”。此时 Mark Word 中存储的就是指向重量级锁（互斥量）的指针。

**解锁过程**：同样通过 CAS 操作进行，检查对象的 Mark Word：

- 如果仍然指向线程自身，则通过 CAS 替换并恢复对象头的 Mark Word。
- 如果不指向线程自身，则说明有其他线程尝试过获取该锁，释放锁后唤醒被挂起的线程。

轻量级锁能提升同步性能的依据在于 “对于绝大部分的锁，在整个同步周期内都是不存在竞争的” 这一经验法则。当该法则不成立时，由于有 CAS 操作的开销，性能反而不如重量级锁。

#### 13.3.5 偏向锁

偏向锁也是 JDK6 中引入的一项锁优化措施，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。

当 JVM 启用了偏向锁（-XX:+UseBiasedLocking），那么当线程第一次获取锁对象时，JVM 会将对象头的锁标志替换为 “01”，把偏向模式设置为 “1”，表示可偏向，同时使用 CAS 把线程的 ID 保存在对象头的 Mark  Word 中。如果 CAS 操作成功，持有偏向锁的线程以后每次进入该锁的同步块时，JVM 都可以不再进行任何同步操作。

一旦出现另一个线程请求锁对象，偏向模式立刻结束，恢复为无锁（“00”）或者轻量级锁（“01”）模式。

偏向锁、轻量级锁、重量级锁的转化状态如下：

![image-20210228194001487](https://gitee.com/zhxuankun/Image/raw/master/Avator/image-20210228194001487.png)

进入偏向状态时，Mark Word 只存储了线程 ID，并未存储对象的哈希码。当调用了哈希码的来源 Object::hashCode() 方法计算哈希码时，如果对象正处于偏向状态，又收到了计算一致性哈希码请求（重写 hashCode 则不会产生该请求）时，偏向状态会被撤销，直接膨胀为重量级锁。



## Q&A

**Q：为什么需要加入临时的 GC Roots？**

A：两个原因，一个是由于使用了 RSET 来记录跨区域引用，因此需要将这些对象也加入 GC ROOTS；另一个则是由于 GC 如果存在并发标记阶段，则由于并发阶段可能存在引用关系的变化，因此需要进行再次标记，这时候就需要加入当时引用关系发生变化的相关对象。