---
title: GC 日志的相关参数
date: 2020-07-22 15:36:12
---
# GC 日志的相关参数

此处主要记录一些打印GC日志的相关参数及输出日志的含义，全文以下面代码为例：

```java
public class Application {

    private static Map<String, String> stringContainer = new HashMap<>();

    public static void main(String[] args) {
        System.out.println("Start of program!");
        String stringWithPrefix = "stringWithPrefix";

        // Load Java Heap with 3 M java.lang.String instances
        for (int i = 0; i < 3000000; i++) {
            String newString = stringWithPrefix + i;
            stringContainer.put(newString, newString);
        }
        System.out.println("MAP size: " + stringContainer.size());

        // Explicit GC!
        System.gc();

        // Remove 2 M out of 3 M
        for (int i = 0; i < 2000000; i++) {
            String newString = stringWithPrefix + i;
            stringContainer.remove(newString);
        }

        System.out.println("MAP size: " + stringContainer.size());
        System.out.println("End of program!");
    }
}
```

采用的GC收集器以及内存大小为：`-XX:+UseSerialGC -Xms1024m -Xmx1024m`。

## 1. -verbose:gc

`-verbose:gc` 主要是打印一些简短的 GC 日志，默认情况下，每次发生 young GC 以及 full GC 的时候都会输出信息。

添加 JVM 参数 `-XX:+UseSerialGC -Xms1024m -Xmx1024m -verbose:gc` ，运行代码，输出如下信息：

```java
Start of program!
[GC (Allocation Failure)  279616K->225945K(1013632K), 0.5030646 secs]
MAP size: 3000000
[Full GC (System.gc())  404212K->368958K(1013632K), 0.6541511 secs]
MAP size: 1000000
End of program!
```

接下来将上述日志进行拆解介绍：

1. `GC` 以及 `Full GC` 用于表示此次 GC 的类型。
2. `(Allocation Failure)` 以及 `(System.gc())` 表示此次发生 GC 的原因。
3. `279616K->225945K` 表示 GC 前后占用的内存用量。
4. `(1013632K)` 表示当前 Java 堆的容量大小。
5. `0.5030646 secs` 表示此次 GC 花费的时间。

从上面打印的信息我们可以得到每次 GC 的类型、前后的堆用量变化以及耗费时间，还有 Java 堆的容量。

## 2. -XX:+PrintGCDetails

前面的 `-verbose:gc` 只能打印一些简单的信息，如果我们需要得到更加细粒度的信息，则需要加上 `-XX:+PrintGCDetails` 参数，该参数能够打印更加详细的信息，比如：

* 年轻代以及老年代前后 GC 的堆用量变化以及耗费时间
* 每次 GC 中晋升的对象大小
* 整个堆大小的总结报告

添加 JVM 参数 `-XX:+UseSerialGC -Xms1024m -Xmx1024m -verbose:gc -XX:+PrintGCDetails` ，运行代码，输出如下日志：

```java
Start of program!
[GC (Allocation Failure) [DefNew: 279616K->34944K(314560K), 0.4519005 secs] 279616K->224720K(1013632K), 0.4519562 secs] [Times: user=0.31 sys=0.14, real=0.45 secs]
MAP size: 3000000
[Full GC (System.gc()) [Tenured: 189776K->368958K(699072K), 0.6843870 secs] 408484K->368958K(1013632K), [Metaspace: 3977K->3977K(1056768K)], 0.6844655 secs] [Times: user=0.64 sys=0.05, real=0.68 secs]
MAP size: 1000000
End of program!
Heap
 def new generation   total 314560K, used 217673K [0x00000000c0000000, 0x00000000d5550000, 0x00000000d5550000)
  eden space 279616K,  77% used [0x00000000c0000000, 0x00000000cd4925e8, 0x00000000d1110000)
  from space 34944K,   0% used [0x00000000d3330000, 0x00000000d3330000, 0x00000000d5550000)
  to   space 34944K,   0% used [0x00000000d1110000, 0x00000000d1110000, 0x00000000d3330000)
 tenured generation   total 699072K, used 368958K [0x00000000d5550000, 0x0000000100000000, 0x0000000100000000)
   the space 699072K,  52% used [0x00000000d5550000, 0x00000000ebd9faf0, 0x00000000ebd9fc00, 0x0000000100000000)
 Metaspace       used 3989K, capacity 4572K, committed 4864K, reserved 1056768K
  class space    used 439K, capacity 460K, committed 512K, reserved 1048576K
```

接下来对上述信息进行拆分：

1. `DefNew` 表示使用的垃圾收集器名称，使用不同的 GC 算法名称有所不同，这里使用的是 SerialGC 算法，回收的是年轻代的对象。
2. `279616K->34944K(314560K)` 表示年轻代 GC 前后的堆用量，其中 `314560K` 表示年轻代的总容量。
3. `0.4519005 secs` 年轻代此次 GC 耗费的时间。
4. `[Times: user=0.31 sys=0.14, real=0.45 secs]` GC在不同状态下耗费的时间。

这是对三个状态的解释：

* `user` : GC 消耗的CPU时间。
* `sys` : 系统调用或者等待系统时间所耗费的时间。
* `real` : 包括了其他线程所耗费的总时间。

由于我们使用的是 SerialGC 的单线程算法，因此 real 会等于 user 加 sys 所耗费的时间。

最后是 Java 堆的分析报告，我们可以看到 Eden 区使用了 77% 的内存， 老年代则用了 52% ，关于 Metadaspace 以及 class space 的信息也包含在其中。

## 3. -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps

`-XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps` 能够在 GC 日志中添加时间信息，其中 `-XX:+PrintGCTimeStamps` 会打印具体的日期，`-XX:+PrintGCDateStamps` 则会打印从 JVM 启动开始，到这次 GC 所经过的时间。

```java
2020-02-14T16:45:00.725+0800: 0.643: [GC (Allocation Failure)...
```

当我们需要以时间的形式来分析 GC 日志的时候，这两个参数很有用。

## 4. -Xloggc

若我们需要将 GC 日志输出成一个文件，则可以添加这个参数，并指定具体路径，形如：

```java
-Xloggc:/path/to/file/gc.log
```

该参数实际上也隐式地设置```-XX:+PrintGC`` 和 `-XX:+PrintGCTimeStamps` ，但仍然建议进行显示设定，以避免在将来 Java 版本的更新出出现不可预知的异常。

## 5. -XX:+PrintFlagsFinal

这个参数会在 JVM 启动的时候，打印 JVM 的所有参数，输出信息形如：

```java
[Global flags]
    uintx AdaptiveSizeDecrementScaleFactor          = 4                                   {product}
    uintx AdaptiveSizeMajorGCDecayTimeScale         = 10                                  {product}
    uintx AdaptiveSizePausePolicy                   = 0                                   {product}
    uintx AdaptiveSizePolicyCollectionCostMargin    = 50                                  {product}
    uintx AdaptiveSizePolicyInitializingSteps       = 20                                  {product}
    uintx AdaptiveSizePolicyOutputInterval          = 0                                   {product}
    ......
```

CMS 、 Parallel 等 GC 收集器的参数设置可以在这里面看到。

## 6.  -XX:+PrintReferenceGC

这个参数可以跟踪跟踪软引用、弱引用、虚引用和Finallize队列的信息，但需要先开启 `-XX:+PrintGCDetails`，打印日志如下：

```java
[GC (Allocation Failure) [DefNew[SoftReference, 0 refs, 0.0000246 secs][WeakReference, 0 refs, 0.0000048 secs][FinalReference, 2 refs, 0.0000071 secs][PhantomReference, 0 refs, 0 refs, 0.0000075 secs][JNI Weak Reference, 0.0000055 secs]: 279616K->34944K(314560K), 0.4945686 secs] 279616K->227278K(1013632K), 0.4946638 secs] [Times: user=0.42 sys=0.08, real=0.49 secs]
```

## 7. -XX:+UnlockDiagnosticVMOptions -XX:+G1SummarizeConcMark

这两个参数主要用于 G1 收集器，会打印出并发标记阶段的总结信息，如：

```java
 Concurrent marking:
      0   init marks: total time =     0.00 s (avg =     0.00 ms).
      0      remarks: total time =     0.00 s (avg =     0.00 ms).
         0  final marks: total time =     0.00 s (avg =     0.00 ms).
         0    weak refs: total time =     0.00 s (avg =     0.00 ms).
      0     cleanups: total time =     0.00 s (avg =     0.00 ms).
    Final counting total time =     0.00 s (avg =     0.00 ms).
    RS scrub total time =     0.00 s (avg =     0.00 ms).
  Total stop_world time =     0.00 s.
  Total concurrent time =     0.00 s (    0.00 s marking).
```

## 总结

总的来说，通常需要打印 GC 日志通用模板如下：

```vim
-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps
```

其余参数较为少用，或者得根据使用不同的 GC 算法添加不同的参数。

## 参考：

* [Verbose Garbage Collection in Java](https://www.baeldung.com/java-verbose-gc)
* [G1GC Feedback](https://wiki.openjdk.java.net/display/HotSpot/G1GC+Feedback)

