---
title: Kafka mirror maker 参数调优
date: 2020-07-22 10:57:04
---
# Kafka mirror maker 参数调优

Kafka Mirror Maker，可以把一个kafka集群中的log复制到另一个kafka集群，架构图如下：

![Kafka Mirror Maker](https://raw.githubusercontent.com/Rianico/Image/master/ARTS_Tips/mirror_maker.jpg)

从图中可以看出，Kafka Mirror Maker本质上是通过Consumer消费一个Kafka集群，再通过Producer将数据送往另一个集群的，因此调优的核心在于调整好Producer以及Consumer。

## 1. Whitelist or blacklist

Kafka Mirror Maker通过`whitelist`或`blacklist`来决定消费并送往哪些topic，两者只能存在一个。

## 2. Number of producers

`num.producers`可以指定Mirror Maker中Producer的线程数，每个Producer发出的请求，对应的Kafka Broker都会有一个单独的线程去处理，个人经验最好是Producer的数量最好能跟topic的partition数量对应上。

> Note：比如topic有4个partition，我们部署了2个Mirror Maker实例，那么每个Mirror Maker实例可以将`num.producers`设置为2。

## 3. Number of consumption streams

`num.streams`可以指定Mirror Maker中Consumer的线程数，同建议Consumer的数量最好跟topic的partition数量对应上。

> Note：比如topic有4个partition，我们部署了2个Mirror Maker实例，那么每个Mirror Maker实例可以将`num.streams`设置为2。

## 4. Producer

Producer分为两种模式：**异步发送**和**同步发送**（通过`producer.type`设置）。

### 4.1 异步发送

为了更高的吞吐量，我们可以使用异步模式，并且设置为阻塞模式（`queue.enqueueTimeout.ms=-1`，默认值为0），若不设置该参数，一旦Producer的队列满了，消息会因为QueueFullExceptions而丢失。在阻塞模式下，一旦producer的队列满了，它会自动限制consumer的消费速率，并将部分message暂时存放在磁盘上。

### 4.2 同步发送

如果需要保证partition内发送的消息有序，则可以设置为同步发送模式，`acks`设置为1\(`至少等待一个follower同步`\)/-1\(`等待所有follower同步`\)，并且将`retries`设置为1或以上，若为了更高的吞吐量并且不关心写入的结果，可以将acks设置为0，不需要等待follower即可立即返回。

同步模式下需要注意`producer.request.timeout.ms`（**默认值30s**）这个参数，Producer发出请求后，如果返回response的间隔超过了这个阈值，Producer将会重新发送请求或者认定请求失败。

如果在日志中有看到Producer超时异常：

```vim
org.apache.kafka.common.errors.TimeoutException: Expiring 1 record(s) for xxx due to 30024 ms has passed since batch creation plus linger time。
```

最直接的方式是适当调大Producer的超时时间，也可以通过增大batch size等。

官方建议该间隔还应大于`replica.lag.time.max.ms`，可以避免由于follower拉取产生的延迟从而导致额外的重试请求。

### 4.3 batch.size

`batch.size`可以指定Producer每个batch发送的大小，默认为16K，若batch过小，会导致Producer频发发送请求，从而导致效率的降低（如前面提到的Producer发送超时），可根据实际场景适当调大。

> 注意：增大Batch Size也就意味着需要压缩数据的时间也相应增长，最后能否提升吞吐量还得自行测试，可以使用Kafka自带的压测工具`kafka-producer-perf-test.sh` ，一般来说16K以及256K是一个较为合适的值。

对该参数进行调整的时候需要考虑到**message是否有压缩**，**Broker允许接收的最大message大小**等，举个例子：若Broker接收的消息允许的最大值为5MB，消息压缩采用了snappy（压缩比~1:5），那么`batch.size`最大可以配置为1MB，否则会因此为超过了消息最大大小而导致Broker拒绝接收message。

此处列出常用的几种压缩格式的对比：

| Algorithm | % remaining | Encoding | Decoding |
| :---: | :---: | :---: | :---: |
| GZIP | 13.4% | 21 MB/s | 118 MB/s |
| LZO | 20.5% | 172 MB/s | 410 MB/s |
| Zippy/Snappy | 22.2% | 172 MB/s | 409 MB/s |

### 4.4 linger.ms

`linger.ms`一般**仅在异步模式下使用**，这个参数指定了Producer在发送消息前的最大等待时间，默认为0（立即发送）。

这里有个前提条件，就是得message大小小于`batch.size`，若在`linger.ms`指定的范围内消息先达到了`batch.size`，Producer也会立即发送消息。

调大这个值可以提升吞吐量，但也也会增加数据发送的延时。

### 4.5 buffer.memory

`buffer.memory`指定了Producer可以用来缓存消息的内存大小，该值可以适当调大，若buffer过小从而频繁写满，会导致Consumer线程阻塞，如下图：

![buffer\_memory\_small](https://raw.githubusercontent.com/Rianico/Image/master/ARTS_Tips/batch_buffer_small.png)

调整的大小可以参考该公式：`buffer.size` = `total_topic_partitions`\* `batch.size`，buffer不仅会用来缓存消息，还会被用于压缩消息。

## 5. Consumer

### 5.1 session.timeout.ms & heartbeat.interval.ms

通过`session.timeout.ms`配置，**默认值10s**，用于确认一个消费者组内Consumer是否存活，若超过该时间仍没有heartbeat传递过来，则会认为Consumer已失效并触发rebalance。通常heartbeat间隔（`heartbeat.interval.ms`）应为该值的三分之一。

Kafka0.10之前，Consumer的heratbeat是跟poll一起发送的，这样当两个poll请求之间因为种种原因（e.g. 发生GC）延迟较大时，间隔大于`session.timeout.ms`从而导致Consumer超时失效：

![image](https://raw.githubusercontent.com/Rianico/Image/master/ARTS_Tips/heartbeat-old-way.png)

从Kafka0.10开始，新版Consumer支持通过一个后台线程去发送heartbeat请求，而不是再跟随poll请求一起发送。

![heartbeat-new-way](https://raw.githubusercontent.com/Rianico/Image/master/ARTS_Tips/heartbeat-new-way.png)

这样做的好处是heartbeat不再跟随poll一起发送，可以避免因为poll请求延迟的原因导致Consumer失效。

> Note：在旧的heartbeat发送模式下，若为了防止poll请求的原因导致Consumer超时失效而将`session.timeout.ms`也跟着调大间隔，也就意味着Consumer真的故障的话，发现故障Consumer并重新分配的间隔也会变长。

### 5.2 max.poll.records

`max.poll.records`默认为500，意思是Consumer每次poll的最大条数，根据`session.timeout.ms`默认值为10s，也就是说官方认为在10s内最多可以poll这么多条数据，若看到下列异常信息：

> Commit cannot be completed since the group has already rebalanced and assigned the partitions to another member. This means that the time between subsequent calls to poll\(\) was longer than the configured session.timeout.ms, which typically implies that the poll loop is spending too much time message processing. You can address this either by increasing the session timeout or by reducing the maximum size of batches returned in poll\(\) with max.poll.records.

可以考虑增大`session.timeout.ms`或者减少`max.poll.records`，以及排查集群网络等。

### 5.3 max.poll.interval.ms & consumer.request.timeout.ms

`max.poll.interval.ms`，**默认值300s**，指定一个group中Consumer的poll请求之间的最大时间间隔，若超过该值，则会触发rebalance。设定这个值的时候，需要考虑到具体处理下游业务所花费的时间，比如下游写入数据库需要花费5min，那么`max.poll.interval.ms`则可以考虑设置为6min，间隔过段从而导致无谓的rebalance。

`consumer.request.timeout.ms`配置，**默认值305s**，用于指定Consumer等待请求响应的超时时间，如果超过该值，Consumer将会重新发送请求或者认为请求失败。

由于`consumer.request.timeout.ms`也决定了多久没收到Consumer的响应就会离开group，所以`consumer.request.timeout.ms`应该总是略大于`max.poll.interval.ms`。

## 6. References

* [Kafka 0.11.0 Documentation](https://kafka.apache.org/0110/documentation.html#consumerconfigs)
* [What does the heartbeat thread do in Kafka Consumer?](https://chrzaszcz.dev/2019/06/kafka-heartbeat-thread/)
* [MirrorMaker Performance Tuning](https://engineering.salesforce.com/mirrormaker-performance-tuning-63afaed12c21)
* [Kafka mirroring \(MirrorMaker\)](https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=27846330)

