---
title: 03.硬件
date: 2021-06-03
---

## CPU 的三种工作模式

CPU 的工作模式有**实模式、保护模式、长模式**：

1. **实模式**，早期 CPU 是为了支持单道程序运行而实现的，单道程序能掌控计算机所有的资源，仅支持 16 位地址空间，**分段的内存模型**，**对指令不加限制地运行**，对内存没有保护隔离作用。
2. 保护模式，为了应对多道程序的出现，避免出现一个程序危害到其他程序的情况， CPU 实现了保护模式。通过增加了**特权级**的概念，对指令及其访问的资源进行控制，对**内存段与段之间**的访问进行严格检查，没有权限的不放行，对中断的响应也要进行严格的权限检查，扩展了 CPU 寄存器位宽，使之能够寻址 32 位的内存地址空间和处理 32 位的数据，从而 CPU 的性能大大提高。
3. 长模式，又名 AMD64 模式，在保护模式的基础上，把寄存器扩展到 64 位同时增加了一些寄存器，使 CPU 具有了能处理 64 位数据和寻址 64 位的内存地址空间的能力。

**硬件中断**，由硬件（中断控制器）发起一个电子信号给 CPU，CPU 做出应答后，硬件发送中断信号给 CPU。

**软件中断**，即 CPU 执行了 **INT 指令**，后面跟着一个数字。

为了实现中断，需要在内存中维护一个**中断向量表**，表中维护着描述符，CPU 能够根据中断中断号，通过中断向量表寻址到需要执行的代码及指令。

## 虚拟内存

虚拟内存用于解决多个程序之间的内存共享问题，需要 MMU 结合 TLB，将程序的虚拟内存转换为实际的物理内存并传递给 CPU。

32 位地址模式下，使用 CPU 保护模式，最大只能表示 4G 内存空间：

- 高 10bit 地址表示**页目录索引**，对应 1024 个页表

- 接下来 10bit 表示**页表索引**，对应 1024 个物理页

- 低 12bit 表示偏移量，对应 4KB

三者相乘正好等于 4GB。

![img](https://static001.geekbang.org/resource/image/00/f8/00b7f1ef4a1c4f6fc9e6b69109ae0bf8.jpg)

CPU 长模式下则可以使用 64 位地址，但当前操作系统最多中用到了内存地址中的 0 到 47 位，剩余的 48 ~ 63 位作为保留。

> NOTE：JVM 中的 ZGC 就是利用了保留的 bit ，实现了染色指针算法。

不同进程拥有不同的页表，并且是由操作系统分配的，从而形成了进程空间隔离。





![img](https://static001.geekbang.org/resource/image/d4/y0/d43c10bbb1a1159d9da7d3b14a3cfyy0.jpg)

## 高速缓存

**局部性原理**：CPU 大多数时间在访问相同或者相邻的数据。

为了解决 CPU 与内存之间速度不一致的问题，通过一块小而块的存储器，放在 CPU 与内存之间，并借助局部性原理，批量的先办数据、指令加载到缓存中，CPU 则从缓存中获取自己想要的数据。缓存可以做成独立芯片放在总线上，也可以集成在 CPU 内部：

![img](https://static001.geekbang.org/resource/image/47/56/474189597993406a01a2ae171b754756.jpg)

高速缓存会把自己分成大小相同的行，一行大小通常为 32 bytes 或者 64 bytes，称为缓存行。通常多个行又会形成一组。

随着多核时代的来临，带来了**多核心之间缓存不一致**的问题，多核心之间的结构通常如下：

![img](https://static001.geekbang.org/resource/image/97/bd/976f5cf91bc656e2a876235a5d2efabd.jpg)

在单核情况下，以 Java 为例，当 Java 在运行时修改了一处指令，这时这部分还只属于数据上的修改，因此新的指令数据会进入数据 Cache，写入地址 A。后续执行地址 A 处指令的时候，指令 Cache 的指令可能是过时的，因此需要把数据 Cache 中地址 A 的数据写入到内存中，并将指令 Cache 的指令置为失效，重新从内存中获取。

多核场景下，如果第一个核心修改了缓存内地址 A 的数据，如果第二个核心也需要访问地址 A 数据，那么也会在自己的缓存内存储一份相同的数据。但是当第一个核心修改地址 A 数据的时候，第二个核心内的缓存数据不一致了。

为了多核心缓存的解决一致性问题，硬件工程师开发了多种协议，其中最出名的就是 **MESI 协议**。

MESI 协议定义了 4 种基本状态：M、E、S、I，即**修改（Modified）**、**独占（Exclusive）**、**共享（Shared）**和**无效（Invalid）**：

- 修改：当前数据在 Cache 内有效，仅存在一个核心缓存中，有经过修改且与内存中的数据不一致。
- 独占：当前数据在 Cache 内有效，仅存在一个核心缓存中，且与内存中数据一致。
- 共享：当前数据在 Cache 内有效，且存在多个核心缓存中，且与内存中数据一致。
- 无效：不属于前面几种状态下的数据都属于无效。

这个协议是由硬件端保证的，对软件透明，但编写软件时需要注意这个问题。

由于一个缓存行通常能存储多条数据，且硬件判断无效的粒度为缓存行级别，因此一旦一条数据失效后，可能会导致相邻有效的数据也跟着被淘汰，即 CPU 中的为共享。

