---
title: 01.操作系统初识
date: 2021-05-28
---

## 1.计算机结构

近代计算机发展史中，人们基于图灵机 + 冯诺依曼体系创造出了近代计算机，接着再从汇编到 C 语言，成功诞生出了操作系统。

**图灵机**是一个抽象的模型，假设有一条无限长的纸带，纸带上每个格子都可以记录信息，还有个读头可以来回移动，便可以根据格子里的信息做出相应操作。

![img](https://static001.geekbang.org/resource/image/69/7d/6914497643dbb0aaefffc32b865dcf7d.png)

**冯诺依曼体系结构**则定义了现代计算的整体结构，实现了可存储编程的计算机，将图灵机翻译为冯诺依曼体系计算机则如下图：

![img](https://static001.geekbang.org/resource/image/bd/26/bde34df011c397yy42dc00fe6bd35226.jpg)

数据的写入由**数据总线**完成，格子的位置则对应**地址总线**，读头的移动则由**控制总线**完成。

## 2. 程序的运行

一段 C 代码要执行需要经过以下步骤：

![img](https://static001.geekbang.org/resource/image/f2/4a/f2b10135ed52436888a793327e4d5a4a.jpg)

```bash
# 源文件生成预处理文件
gcc -E HelloWorld.c -o HelloWorld.i
# 预处理文件生成编译文件
gcc -S HelloWorld.i -o HelloWorld.s
# 编译文件生成汇编文件：
gcc -c HelloWorld.s -o HelloWorld.o
# 汇编文件生成可执行文件
gcc HelloWorld.o -o HelloWorld

# 源文件生成可执行文件
gcc HelloWorld.c -o HelloWorld
# Linux系统运行可执行文件
./HelloWorld
```

代码示例：

```c
#include "stdio.h"
int main(int argc, char const *argv[])
{
  printf("Hello World!\n");
  return 0;
}
```

执行 `gcc HelloWorld.c -o HelloWorld` 得到一个可执行文件，接着使用 `objdump -d HelloWorld` 查看汇编代码及相关二进制数据：

![img](https://static001.geekbang.org/resource/image/39/14/3991a042107b90612122b14596c65614.jpeg)

第一列为地址，第二列表示十六进制指令（x86 为变长指令，在 arm 架构下编译则是定长的），第三列对应汇编代码，第四列则是相关注释。

将上述程序装载进计算机如下：

![img](https://static001.geekbang.org/resource/image/5d/6e/5d4889e7bf20e670ee71cc9b6285c96e.jpg)

**Q：：call 和 ret 指令在逻辑上执行的操作是怎样的呢？**

A：call 和 ret 都涉及地址的跳转，不同的是 call 会将当前地址入栈保存并跳转到指定地址，ret 则是将地址出栈返回至原来跳转的地址。

## 2. 实现一个最简单的操作系统

启动一个 OS 的流程如下：

![](https://static001.geekbang.org/resource/image/f2/bd/f2d31ab7144bf309761711efa9d6d4bd.jpg)

BISO 固件是固化在主板芯片上的，PC 上电后第一条指令就是作用于 BIOS 固件中的，负责检测和初始化 CPU、内存及主板平台，接着加载引导设备（大概率是硬盘）中第一个扇区数据直到 0x7c00 处，接着执行 0x7c00 处的指令，如 GRUB 引导程序。

C 语言作为高级语言，无法直接操作硬件，因此需要先使用汇编处理好 C 语言所需的环境（如栈）：

```assembly

;彭东 @ 2021.01.09
MBT_HDR_FLAGS EQU 0x00010003
MBT_HDR_MAGIC EQU 0x1BADB002 ;多引导协议头魔数
MBT_HDR2_MAGIC EQU 0xe85250d6 ;第二版多引导协议头魔数
global _start ;导出_start符号
extern main ;导入外部的main函数符号
[section .start.text] ;定义.start.text代码节
[bits 32] ;汇编成32位代码
_start:
jmp _entry
ALIGN 8
mbt_hdr:
dd MBT_HDR_MAGIC
dd MBT_HDR_FLAGS
dd -(MBT_HDR_MAGIC+MBT_HDR_FLAGS)
dd mbt_hdr
dd _start
dd 0
dd 0
dd _entry
;以上是GRUB所需要的头
ALIGN 8
mbt2_hdr:
DD MBT_HDR2_MAGIC
DD 0
DD mbt2_hdr_end - mbt2_hdr
DD -(MBT_HDR2_MAGIC + 0 + (mbt2_hdr_end - mbt2_hdr))
DW 2, 0
DD 24
DD mbt2_hdr
DD _start
DD 0
DD 0
DW 3, 0
DD 12
DD _entry
DD 0
DW 0, 0
DD 8
mbt2_hdr_end:
;以上是GRUB2所需要的头
;包含两个头是为了同时兼容GRUB、GRUB2
ALIGN 8
_entry:
;关中断
cli
;关不可屏蔽中断
in al, 0x70
or al, 0x80
out 0x70,al
;重新加载GDT
lgdt [GDT_PTR]
jmp dword 0x8 :_32bits_mode
_32bits_mode:
;下面初始化C语言可能会用到的寄存器
mov ax, 0x10
mov ds, ax
mov ss, ax
mov es, ax
mov fs, ax
mov gs, ax
xor eax,eax
xor ebx,ebx
xor ecx,ecx
xor edx,edx
xor edi,edi
xor esi,esi
xor ebp,ebp
xor esp,esp
;初始化栈，C语言需要栈才能工作
mov esp,0x9000
;调用C语言函数main
call main
;让CPU停止执行指令
halt_step:
halt
jmp halt_step
GDT_START:
knull_dsc: dq 0
kcode_dsc: dq 0x00cf9e000000ffff
kdata_dsc: dq 0x00cf92000000ffff
k16cd_dsc: dq 0x00009e000000ffff
k16da_dsc: dq 0x000092000000ffff
GDT_END:
GDT_PTR:
GDTLEN dw GDT_END-GDT_START-1
GDTBASE dd GDT_START
```

1. 1~40 行用汇编定义的 GRUB 的多引导协议头。
2. 44~52 行，关掉中断，设定 CPU 的工作模式。
3. 54~73 行，初始化 CPU 的寄存器和 C 语言的运行环境。
4. 78~87 行，GDT_START 开始的，是 CPU 工作模式所需要的数据。

可以看到，汇编代码中调用了 main 函数，表示为一个符号，这是因为该 main 函数定义在其他文件中，最后分别由 nasm 和 gcc 编译成可链接模块，由 LD 链接器链接在一起，形成可执行文件：

```C
//彭东 @ 2021.01.09
#include "vgastr.h"
void main()
{
  printf("Hello OS!");
  return;
} 
```

其中的 printf 不再是应用程序中的 printf 了，而是需要我们自己实现。

`vgastr.h` 表示依赖某个文件，这个文件中定义了输出显示相关的功能，会按照一定标准映射到 0xb8000 地址开始的显卡内存中，实现显示功能：

![img](https://static001.geekbang.org/resource/image/78/f5/782ef574b96084fa44a33ea1f83146f5.jpg)

具体实现如下：

```C
//彭东 @ 2021.01.09
void _strwrite(char* string)
{
  char* p_strdst = (char*)(0xb8000);//指向显存的开始地址
  while (*string)
  {
    *p_strdst = *string++;
    p_strdst += 2;
  }
  return;
}

void printf(char* fmt, ...)
{
  _strwrite(fmt);
  return;
}
```

之后借助 make 及其描述编译的 Maekfile 文件进行构建：

![img](https://static001.geekbang.org/resource/image/cb/34/cbd634cd5256e372bcbebd4b95f21b34.jpg)

得到 `Hello OS.bin` 后，我们需要让 GRUB 能够找到它，GRUB 会在启动时加载 `/boot/grub/grub.cfg` 文件，根据其中的内容执行相应操作，其中一部分就是启动项，添加 Hell OS 的启动项：

```c
menuentry 'HelloOS' {
     insmod part_msdos #GRUB加载分区模块识别分区
     insmod ext2 #GRUB加载ext文件系统模块识别ext文件系统
     set root='hd0,msdos4' #注意boot目录挂载的分区，这是我机器上的情况
     multiboot2 /boot/HelloOS.bin #GRUB以multiboot2协议加载HelloOS.bin
     boot #GRUB启动HelloOS.bin
}
```

- `insmode part_msdos`：如果是 gpt 格式的磁盘，还需修改为 `insmod part_gpt`。
- `set root='hd0,msdos4'`：如果是 gpt 格式的磁盘，还需修改为 `hd0,gpt2`。

启动项主要是得配置对磁盘格式以及路径，grub 下第一块硬盘定义为 `hd0`，接着就是指定 `Hello OS.bin` 所在分区，通常也是 boot 目录所在。

> NOTE：实际上 boot 目录只是一个约定俗成的路径，操作系统镜像可以放在其他位置，只要加载路径设置正确即可。
