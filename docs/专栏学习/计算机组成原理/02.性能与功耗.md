---
title: 性能与功耗
date: 2020-08-22
---



## 1. 性能

**性能**，主要有两个衡量标准，一个是**响应时间**（Response time）或者叫**执行时间**（Execution time），还有一个叫做**吞吐率**（Throughput）或者**带宽**（Bandwidth）。

通常提升吞吐率较为简单，比如增加机器核数、数量等，但是响应时间较为难提升。因此一般可以将性能定义为响应时间的倒数：
$$
性能 = 1 / 响应时间
$$
通过时间来衡量存在一个问题，每次执行程序所花费的时间都不一样，这是由于计算机可能同时运行着好多个程序，CPU 在不同的程序之间来回切换，这期间就存在等待所耗费的时间，并且可能还存在着等待网络读取、磁硬盘读取等所耗费的时间。因此**要想准确统计某个程序运行时间，进而去比较两个程序的实际性能，我们得把这些时间给刨除掉**。

Linux 有一个 time 命令，可以统计出在运行程序所花费的时间（**real time**）里，有多少时间是真正在运行程序（**user time** + **sys time**）的。

> 有时候看到 user time + sys time 大于 real time，是因为执行的计算机是多核。

![](https://static001.geekbang.org/resource/image/0b/00/0b340db019d7e389a2bde4c237ee4700.jpg)

即使拿到了 CPU 时间，但 CPU 可能存在满载、降频等情况，所以比较结果也不一定准确，因此还需要对时间继续进行拆解，把程序的 CPU 执行时间变成 **CPU 时钟周期数（CPU Cycles）**和 **时钟周期时间（Clock Cycle）**的乘积：
$$
程序的 CPU 执行时间 =CPU 时钟周期数×时钟周期时间
$$


- CPU 时钟周期时间：CPU 的主频，表示 CPU 周期与周期之间的最小时间间隔，频率越高，间隔越小，这个是由晶体振荡器（Oscillator Crystal，晶振）完成的，将其作为 CPU 内部电子表，每一次转动就相当于一次周期时间。
- CPU 时钟周期数：在执行时间不变的前提下，CPU 时钟周期时间越小，时钟周期数越大。也就是说， CPU 频率越高，单位时间内所能够执行的周期数也就越多，而一个指令的完成往往需要几个周期。

时钟周期时间取决于硬件，软件方面无法控制，因此需要从 CPU 时钟周期数着手。

对于 CPU 时钟周期数，可以转化为 “**指令数×每条指令的平均时钟周期数（Cycles Per Instruction，简称 CPI）**”。不同的指令需要的时钟周期也不一样，因此对于软件方面来说，最终程序的执行时间公式如下：
$$
程序的 CPU 执行时间 = 指令数×CPI×时钟周期时间
$$

---

## 2. 功耗

CPU，一般都被叫作超大规模集成电路（Very-Large-Scale Integration，VLSI），这些电路都是由一个个晶体管组合而成的，CPU 在运算的时候，就是借助晶体管来组合完成各种运算和功能。

因此，要提高 CPU 性能，可以通过两个途径：

1. 在同样的 CPU 面积里，多放一些晶体管，即**增加密度**（增加晶体管可以增加硬件能够支持的指令数量，增加数字通路的位数，以及利用好电路天然的并行性，从硬件层面更快地实现特定的指令）；
2. 让晶体管速度更快，也就是**提升主频**。这两者都会增加功耗，带来耗电和散热问题。

一个 CPU 的功率，可以用这样一个公式来表示：**功耗 ~= 1/2 ×负载电容×电压的平方×开关频率×晶体管数量**。

从公式来看，功耗跟电压的平方成正比，因此降低电压是一种收益较为明显的方式。

从增加密度这点来看，这也是为什么越是高端的芯片，越是对芯片的制程有要求。

但是 CPU 的主频到达一定瓶颈以后已经很难再上去了，会受到功耗的制约，因此只能转而**通过并行提高性能**。

并行提高性能遵循**阿姆达尔定律（Amdahl’s Law）**，对于一个程序进行优化之后，处理器并行运算之后效率提升的情况。具体可以用这样一个公式来表示：
$$
优化后的执行时间 = 受优化影响的执行时间 / 加速倍数 + 不受影响的执行时间
$$
也就是想要通过并行提高性能，首先得计算之间可以相互拆分，彼此之间没有依赖，这部分可以优化。至于无法拆分的那部分，就属于不受影响的执行时间。并行加速效果如下：

![](https://static001.geekbang.org/resource/image/f1/e5/f1d05ec439e6377803df741bc07b09e5.jpeg)

可以看到，并行加速的收益是逐渐下降的，总存在一部分时间是无法通过并行加速的。

## 3. 总结

在优化性能可以从以下几方面入手：

1. **时钟周期时间**，取决于计算机主频，并且这个时间往往是按照**放下最复杂的一条指令的时间长度**来算的。主频的提升可以参考[摩尔定律](https://zh.wikipedia.org/wiki/%E6%91%A9%E5%B0%94%E5%AE%9A%E5%BE%8B)，但近年来 CPU 的性能发展逐渐到达瓶颈，摩尔定律逐渐失效。

   ![](https://static001.geekbang.org/resource/image/18/80/1826102a89e4cdd31f7573db53dd9280.png)

2. 每条指令的**平均时钟周期数 CPI**，这里的，现代的 CPU 通过流水线技术（Pipeline），让一条指令需要的 CPU Cycle 尽可能地少。

3. **指令数**，表示我们的程序需要多少条指令，这个往往交由编译器去做，相同的代码，编译成计算机指令的时候，就有各种不同的表示方式。

4. 并行计算。

5. 加速大概率事件，比如向量和矩阵运算使用 GPU ，缓存，热点代码等。

6. 通过流水线提高性能，将 CPU 指令执行的过程进行拆分，减少 CPI，但过长的流水线也会带来新的功耗和效率方面的影响。

7. 通过预测提高性能，比如分支和冒险（JVM 的 JIT 优化）、局部性原理、预读取等。
