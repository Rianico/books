---
title: 09. CPU流水线
date: 2020-09-20
---



## 1. 单指令周期处理器

CPU 的时钟周期是固定的，但指令的电路复杂程度是不同的，所以不同的指令执行的时间是不同的，这样一来，如果按照单指令周期处理器的设计思路，根据木桶原理，一个时钟周期至少要等于最复杂的那条指令所耗费的时间。

![](https://static001.geekbang.org/resource/image/6c/ee/6c85e2dd9b9988d8a458fb1200d96eee.jpeg)

这样一来就会导致 CPU 的时钟频率无法太高，有些复杂指令没有办法在一个时钟周期内运行完成。那么在下一个时钟周期到来，开始执行下一条指令的时候，前一条指令的执行结果可能还没有写入到寄存器里面。那下一条指令读取的数据就是不准确的，就会出现错误：

![](https://static001.geekbang.org/resource/image/30/9b/3097988ae8dfc82e33ab80234bd5a29b.jpeg)

## 2. 指令流水线

指令的执行可以拆分成 “取指令、译码、执行” 三大大步骤，可以让一个步骤对应一个指令周期，来**提高 CPU 的吞吐率**：

![](https://static001.geekbang.org/resource/image/1e/ad/1e880fa8b1eab511583267e68f0541ad.jpeg)

这样一来，下一条指令的取指令步骤，不需要等到上一条指令全部执行完成，就可以开始执行了。

这样种协作模式就是**指令流水线**。每一个独立的步骤，称之为**流水线阶段**或者**流水线级（Pipeline Stage）**。

> 如果我们把一个指令拆分成“取指令 - 指令译码 - 执行指令”这样三个部分，那这就是一个三级的流水线。如果我们进一步把“执行指令”拆分成“ALU 计算（指令执行）- 内存访问 - 数据写回”，那么它就会变成一个五级的流水线。

通过更细粒度的拆分，我们不需要确保最复杂的那条指令在时钟周期里面执行完成，而只要保障一个最复杂的流水线级的操作，在一个时钟周期内完成就好了。

> 现代的 ARM 或者 Intel 的 CPU，流水线级数都已经到了 14 级。

流水线的深度，也是有性能成本的，每一级流水线对应的输出，都要放到**流水线寄存器（Pipeline Register）**里面，然后在下一个时钟周期，交给下一个流水线级去处理。

每增加一级的流水线，就要多一级写入到流水线寄存器的操作，每个操作耗时约 20 皮秒（ps，$10^{−12}$ 秒）。

![](https://static001.geekbang.org/resource/image/d9/26/d9e141af3f2c5eedd5aed438388cfe26.jpeg)

一旦流水线级数过多，就会导致这部分 overhead 开销过大，设计合理的流水线级数也是现代 CPU 中非常重要的一点。

**流水线技术并不能缩短单条指令的响应时间这个性能指标，但是可以增加在运行很多条指令时候的吞吐率，同时更新的粒度带来了更多的优化可能（如乱序执行）。**

CPU 的设计，又是由一个个独立的组合逻辑电路串接起来形成的，天然能够适合这样采用流水线“专业分工”的工作方式。

并不是主频越高，流水线级数越多越好，主要存在以下两方面问题：

1. **功耗**，提升水线深度，必须要和提升 CPU 主频同时进行，才能跟原来的处理器保持相同的性能，但这也代表功耗大大增加。
2. **冒险问题**，实际编程中不同语句之间往往存在着依赖关系，数据之间的依赖关系属于数据冒险（还有结构冒险、控制冒险等），对于这些问题，也有乱序执行、分支预测等相应的解决方案。然而，**流水线越长，也意味着这些问题越难解决**。

流水线技术可以解决单指令周期问题，但也需要讲究适度，属于一个折衷（Trade-Off）方案，过深的流水线，不仅不能提升计算机指令的吞吐率，更会加大计算的功耗和散热问题。

一般用 **IPC（Instruction Per Cycle）**来衡量 CPU 执行指令的效率，是 **CPI（Cycle Per Instruction）**的倒数，

