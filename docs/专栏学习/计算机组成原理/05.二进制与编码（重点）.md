---
title: 05. 二进制与编码（重点）
date: 2020-09-08
---

## 1. 二进制

二进制有**原码**、**反码**、**补码**三种表示方式，通常原码用于做正数的计算，补码则用于负数的计算。

补码用于做负数的计算十分简单，仍将左侧最高位用于表示正负，但在转化为十进制的时候不再单纯的将其当做符号位，而是参与进计算中：

![](https://static001.geekbang.org/resource/image/bf/ae/bf4cfd001308da2be317b08d1f40a7ae.jpg)

转化为十进制：
$$
-1*2^3 + 1*2^2 + 0*2^1 + 0*2^0 = -4
$$

$$
0*2^3 + 0*2^2 + 0*2^1 + 1*2^0 = 1
$$

## 2. 字符串与二进制

字符也可以用二进制表示，字符可以转化为对应的二进制，而实现这种转化需要借助**字符集**（Charset）以及**字符编码**（Character Encoding）。

英文中只需要表示字母，加上一些数字以及特殊符号，因此使用 8 位的二进制即可表示所有了，即 **ASCII 码**（American Standard Code for Information Interchange，美国信息交换标准代码）。

![](https://static001.geekbang.org/resource/image/be/05/bee81480de3f6e7181cb7bb5f55cc805.png)

使用字符会占用较多空间，以 ASCII 码为例，如果我们需要表示 `2147483647` 这个值，则每位上的数字都需要转化为对应 8 位的二进制编码（e.g. 2 的 ASCII 码位 `0032`， 即 `0000 0000 0011 0010`），10 位则总共需要转化为 80 位的二进制编码，但这个数字实际上使用一个 8 位的二进制数字即可表示了。

> NOTE：上述转化同时说明了，为什么我们传输数据的时候，**不管是整数也好，浮点数也好，采用二进制序列化会比存储文本省下不少空间**。

### 2.1 字符集与字符编码

![](https://static001.geekbang.org/resource/image/99/3e/9911c58d79e8a1f106d48a83457d193e.jpg)

**字符集**，表示的是字符的合集，比如 ASCII 码，Unicode等。Unicode 包含了 150 种语言的 14 万个不同的字符，表示范围为 0x0000 - 0x10FFFF，即 0 ~ 21 bit，需要使用 1 ~ 3 个字节来存储

**字符编码**，描述了在字符集中这些字符，怎么表示为一个二进制，e.g. UTF-8、UTF-16，乃至 UTF-32。

> NOTE：UTF 的英文字母是 Unicode Transformation Format，后面的数字则表示了使用多少字节表示一个字符。

UTF-8 使用了 1 ~ 4 个字节来应对 Unicode 字符集里的可变字符长度问题，编码的前 n 位都为 1，表示使用了多少字节来表示字符，接下来每个字节都以 10 开头，后面跟着 Unicode 码。

![image-20210619130958453](https://gitee.com/zhxuankun/Image/raw/master/ARTS_Tips/image-20210619130958453.png)

乱码的原因主要是因为一个字符使用了一种编码，而解析的时候使用了另一种编码，被解析为了其他字符。

> NOTE：锟斤拷”的来源：如果我们想要用 Unicode 编码记录一些文本，特别是一些遗留的老字符集内的文本，但是这些字符在 Unicode 中可能并不存在。于是，Unicode 会统一把这些字符记录为 U+FFFD 这个编码。如果用 UTF-8 的格式存储下来，就是\xef\xbf\xbd。如果连续两个这样的字符放在一起，\xef\xbf\xbd\xef\xbf\xbd，这个时候，如果程序把这个字符，用 GB2312 的方式进行 decode，就会变成“锟斤拷”。这就好比我们用 GB2312 这本密码本，去解密别人用 UTF-8 加密的信息，自然没办法读出有用的信息。

> NOTE：烫烫烫”的来源，如果你用了 Visual Studio 的调试器，默认使用 MBCS 字符集。“烫”在里面是由 0xCCCC 来表示的，而 0xCC 又恰好是未初始化的内存的赋值。于是，在读到没有赋值的内存地址或者变量的时候，电脑就开始大叫“烫烫烫”了。