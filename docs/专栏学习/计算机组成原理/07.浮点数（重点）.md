---
title: 07. 浮点数（重点）
date: 2020-09-12
---

## 1. 定点数

如果将数值的位数限定在 32 位的，那么要表示小数的，只能取部分位数用于表示小数部分。

通常我们取 4 个比特来表示 0 ~ 9 的整数，那么 32 个比特就可以拆分为 8 部分，将左边 6 部分用于表示整数位，右边 2 部分表示小数位，那么就可以表示 0 ~ 999999.99 这样 1 亿个实数了：

![](https://static001.geekbang.org/resource/image/f5/b3/f5a0b0f2188ebe0d18f4424578a588b3.jpg)

这种用二进制来表示十进制的编码方式，叫作 **BCD 编码**（Binary-Coded Decimal），常见于超市、银行这种需要记录小数金额的场景，这种表示方式较为直观清楚，但存在几个缺点：

- 可表示的数值范围较小，造成了浪费；
- 无法同时表示很大的数字和很小的数字

## 2. 浮点数

为了解决 BCD 编码存在的问题，我们参考了科学计数法，并结合一定的规则，发明了**浮点数**（Floating Point）。

浮点数有一个 IEEE 的标准，它定义了两个基本的格式：

- 用 32 比特表示单精度的浮点数，也称 float 或者 float32 类型
- 用 64 比特表示双精度的浮点数，也称 double 或者 float64 类型。

以 float 为例，格式如下：

![](https://static001.geekbang.org/resource/image/91/41/914b71bf1d85fb6ed76e1135f39b6941.jpg)

1. 第一部分是一个 1 比特的**符号位**，用于表示正负，一般用 s 来表示。在浮点数里，**所有的浮点数都是有符号的**。

2. 第二部分是一个 8 个比特的**指数位**，一般用 **e** 来表示。8 个比特能够表示的整数空间，就是 0～255，**将其中的 1 ~ 254 映射到 -126 ~ 127 这 254 个数上，0 以及 255 用于表示特殊含义**。指数位有正有负，也就能同时表示很大的数以及很小的数。

   > NOTE：这里有个方便计算的技巧，就是按照 127 + 指数，再转化为指数位，如 127 + （-1）= 126，那么指数位就是 ‭01111110‬。

3. 最后部分是 23 比特的**有效数位**，用 **f** 表示。

结合上面几条规则，最终浮点数的表示形式为： $(−1)^s×1.f×2^e$。

这条公式还无法表示 0，因此需要依赖 e 上 0 以及 255 的特殊含义：

![](https://static001.geekbang.org/resource/image/f9/4c/f922249a89667c4d10239eb8840dc94c.jpg)

以 0.5 为例，0.5 套用公式则为 $(−1)^0×1.0×2^{-1}$ ，对应的浮点数表示为：

![](https://static001.geekbang.org/resource/image/51/50/5168fce3f313f4fc0b600ce5d1805c50.jpeg)

> NOTE：由于 -1 处于 -126 ~ 127 中的第 126 位，因此 e 上表示为 01111110。

> NOTE：浮点数最大值以及最小值的计算方式：
>
> 最大的数，会是 f 全部为1，e 全部为 1，即二进制：$1.11111...^{(2^{127})}$，约等于十进制 $1.9999999 ^{(2^{127})} ≈ 3.4028235 * (10 ^ {38})$ 。
>
> 最小的数，二进制为 $1.000..... ^ {(2^{-126})}$，约等于十进制 $1.0000 ^ {(2^{-126})} ≈ 1.17549435 * (10^{-38})$。

## 3. 浮点数的误差

通常浮点数都是采用 IEEE-754 标准，浮点数是存在误差的，如下代码：

```python
>>> 0.3 + 0.6
0.8999999999999999
```

这是因为浮点数计算的时候，是采用先对齐（e）再计算（f）的。

一个十进制要转化为二进制的浮点数，其形式为 "**符号位 s+ 指数位 e+ 有效位数 f**"。

以 9.1 为例：

- 首先整数位 9 转化为二进制为 1001。

- 小数位的转化与整数位不同，通过小数位乘以 2，如果超过 1，就记下 1，并把结果减去 1，否则记为 0 ，进一步循环操作。

  ![](https://static001.geekbang.org/resource/image/f9/ae/f9213c43f5fa658a2192a68cd26435ae.jpg)

此处的 0.1 会变成一个无限循环的二进制小数：0.000110011... 将其与整数部分拼接起来，这个数就变成了：1001.000110011… 再转化为科学计数法如下：
$$
1.001000110011…×2^3
$$
这样一来，我们就得到了 e 与 f，由于 f 最多只有 23 位，因此 23 位之后的都会被被截断，3 的偏移量位 130，因此 e 为 10000010：

![](https://static001.geekbang.org/resource/image/9a/27/9ace5a7404d1790b03d07bd1b3cb5a27.jpeg)

> 二进制小数位转化为十进制的方式为 2 取 -n 幂次方，以小数位的 1001 为例：
> $$
> 1×2^{−1}+0×2^{−2}+0×2^{−3}+1×2^{−4}=0.5625
> $$

**浮点数之间做加法，需要先将 e 对齐为较大的一边，之后再计算 f 位，这样一来， e 较小的那边的 f 位就需要向右位移，导致丢失右边的精度**。

> NOTE：实际计算的时候，只要两个数，差出 $2^{24}$，也就是差不多 1600 万倍，那这两个数相加之后，结果完全不会变化。

以下例子可以验证这个问题：

```java
public class FloatPrecision {
  public static void main(String[] args) {
    float sum = 0.0f;
    for (int i = 0; i < 20000000; i++) {
      float x = 1.0f;
      sum += x;      
    }
    System.out.println("sum is " + sum);   
  }  
}

// sum is 1.6777216E7
```

面对这个问题，通常可以采用 [Kahan Summation](https://en.wikipedia.org/wiki/Kahan_summation_algorithm) 来解决，每次做加法都记录下这一轮的精度损失，然后在下一轮的时候再补回去：

```java
public class KahanSummation {
  public static void main(String[] args) {
    float sum = 0.0f;
    float c = 0.0f;
    for (int i = 0; i < 20000000; i++) {
      float x = 1.0f;
      float y = x - c;
      float t = sum + y;
      // 此处若有精度损失，c 会是一个负值
      c = (t-sum)-y;
      sum = t;      
    }
    System.out.println("sum is " + sum);   
  }  
}

// sum is 2.0E7
```

这个方法在实际的数值计算中也是常用的，也是大量数据累加中，解决浮点数精度带来的 “大数吃小数” 问题的必备方案。

通常在在实践应用中，对于需要精确数值的，比如银行存款、电商交易，都会使用定点数（e.g. MySQL 中的 `decimal(12,2)`，Java 中的 BigDecimal）或者整数类型。

对于浮点数加法中可能存在的精度损失，特别是大量加法运算中累积产生的巨大精度损失，则可以用 Kahan Summation 这样的软件层面的算法来解决。