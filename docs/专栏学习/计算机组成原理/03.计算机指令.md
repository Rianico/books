---
title: 计算机指令
date: 2020-08-22
---



## 1. 计算机的指令

从硬件的角度来看，CPU 就是一个**超大规模集成电路**，通过电路实现了加法、乘法乃至各种各样的处理逻辑。

从软件工程师的角度来讲，CPU 就是一个执行各种**计算机指令**（Instruction Code）的逻辑机器。这里的计算机指令，也叫作**机器语言**（Machine Language）。

虽然现在我们都是用高级语言进行编程，但实际上计算机只认识 0 和 1，我们使用的高级语言都是通过某种方式翻译为机器语言的。

不同的 CPU 有不同的**计算机指令集**（Instruction Set），一个计算机程序会有成千上万条指令，CPU 无法存储全部指令，所以一般将这些指令存储在存储器中，这类计算机叫做**存储程序型计算机**（Stored-program Computer）。

以 C 语言为例，通常是将一段代码**编译**（Compile）成**汇编语言**（ASM，Assembly Language），再用**汇编器**（Assembler）将其翻译成**机器码**（Machine Code）。这一条条机器码，就是一条条计算机指令。

```c
// test.c
int main()
{
  int a = 1; 
  int b = 2;
  a = a + b;
}
```

执行以下步骤可以看到汇编代码以及机器码：

```bash
$ gcc -g -c test.c
$ objdump -d -M intel -S test.o
```

左边为机器码，右边为汇编代码：

```java
test.o:     file format elf64-x86-64
Disassembly of section .text:
0000000000000000 <main>:
int main()
{
   0:   55                      push   rbp
   1:   48 89 e5                mov    rbp,rsp
  int a = 1; 
   4:   c7 45 fc 01 00 00 00    mov    DWORD PTR [rbp-0x4],0x1
  int b = 2;
   b:   c7 45 f8 02 00 00 00    mov    DWORD PTR [rbp-0x8],0x2
  a = a + b;
  12:   8b 45 f8                mov    eax,DWORD PTR [rbp-0x8]
  15:   01 45 fc                add    DWORD PTR [rbp-0x4],eax
}
  18:   5d                      pop    rbp
  19:   c3                      ret    
```

> 计算机是只认识机器码的，机器码是给人阅读的。而汇编码，是为了给人读的。
>
> 与 C 语言不通，Java 是通过将程序翻译为字节码，再由 JVM 将字节码翻译为机器码的。

---

## 2. 指令的分类

不同的 CPU 的指令集通常也不同，但通常指令可以分为五大类：

1. **算术类指令**，加减乘除在 CPU 层面，都会变成一条条算术类指令。
2. **数据传输类指令**，给变量赋值、在内存里读写数据，用的都是数据传输类指令。
3. **逻辑类指令**，逻辑上的与或非，都是这一类指令。
4. **条件分支类指令**，`if/else` 其实都是条件分支类指令。
5. **无条件跳转指令**，在调用函数的时候，其实就是发起了一个无条件跳转指令。

![](https://static001.geekbang.org/resource/image/eb/97/ebfd3bfe5dba764cdcf871e23b29f197.jpeg)

以开源的 MIPS 指令集为例，MIPS 指令是一个 32 位的整数，高 6 位叫**操作码**（Opcode），也就是代表这条指令具体是一条什么样的指令，剩下的 26 位有三种格式，分别是 R、I 和 J：

- **R 指令**是一般用来做算术和逻辑操作，里面有读取和写入数据的寄存器的地址。如果是逻辑位移操作，后面还有位移操作的**位移量**（shamt），而最后的**功能码**，则是在前面的操作码不够的时候，扩展操作码表示对应的具体指令的。
- **I 指令**，则通常是用在数据传输、条件分支，以及在运算的时候使用的并非变量还是常数的时候。这个时候，没有了位移量和操作码，也没有了第三个寄存器，而是把这三部分直接合并成了一个地址值或者一个常数。
- **J 指令**就是一个跳转指令，高 6 位之外的 26 位都是一个跳转后的地址。

以下面的 R 指令为例：

```bash
# OP rd, rs, rt
add $t0,$s2,$s1
```

![](https://static001.geekbang.org/resource/image/8f/1d/8fced6ff11d3405cdf941f6742b5081d.jpeg)

opcode 是 0，rs 代表第一个寄存器 s1 的地址是 17，rt 代表第二个寄存器 s2 的地址是 18，rd 代表目标的临时寄存器 t0 的地址，是 8。因为不是位移操作，所以位移量是 0。这些都可以表示为二进制以及十六进制。

以前都是通过打孔卡来存储程序的，上面的指令用十六进制在打孔卡上表示如下：

![](https://static001.geekbang.org/resource/image/31/9c/31b430f9e4135f24a998b577cae8249c.png)



---

## 3. 指令的执行

从逻辑上来看，CPU 其实就是由一堆**寄存器**组成的。而寄存器就是 CPU 内部，由多个触发器（Flip-Flop）或者锁存器（Latches）组成的简单电路。

触发器和锁存器，其实就是两种不同原理的数字电路组成的逻辑门。N 个触发器或者锁存器，就可以组成一个 N 位（Bit）的寄存器，能够保存 N 位的数据。

> 比方说，我们用的 64 位 Intel 服务器，寄存器就是 64 位的。

CPU 里有许多寄存器，但有三个较为特殊：

- **PC 寄存器**（Program Counter Register），也叫**指令地址寄存器**（Instruction Address Register，Java 中叫做程序计数器），用来存放下一条需要执行的计算机指令的内存地址。
- **指令寄存器**（Instruction Register），用来存放当前正在执行的指令。
- **条件码寄存器**（Status Register），用里面的一个一个标记位（Flag），存放 CPU 进行算术或者逻辑计算的结果。

还有一些其他很多寄存器，根据存放的数据类型来分类，比如整数寄存器、浮点数寄存器、向量寄存器和地址寄存器等等。有些寄存器既可以存放数据，又能存放地址，我们就叫它通用寄存器。

![](https://static001.geekbang.org/resource/image/cd/6f/cdba5c17a04f0dd5ef05b70368b9a96f.jpg)

一个程序执行的时候，CPU 会根据 PC 寄存器里的地址，**从内存里面把需要执行的指令读取到指令寄存器里面执行**，然后根据指令长度自增，开始顺序读取下一条指令。一个程序的一条条指令，在内存里面是**连续保存**的，也会一条条顺序加载。

当遇到一些特殊指令，比如 J 指令的时候，会修改 PC 寄存器里的地址，这时候就不是按照顺序加载了。这也是 `if/else` 实现的原理。

以下面代码为例：

```c
// test.c


#include <time.h>
#include <stdlib.h>


int main()
{
  srand(time(NULL));
  int r = rand() % 2;
  int a = 10;
  if (r == 0)
  {
    a = 1;
  } else {
    a = 2;
  } 
```

进行编译：

```bash
$ gcc -g -c test.c
$ objdump -d -M intel -S test.o 
```

汇编代码如下：

```java
    if (r == 0)
  3b:   83 7d fc 00             cmp    DWORD PTR [rbp-0x4],0x0
  3f:   75 09                   jne    4a <main+0x4a>
    {
        a = 1;
  41:   c7 45 f8 01 00 00 00    mov    DWORD PTR [rbp-0x8],0x1
  48:   eb 07                   jmp    51 <main+0x51>
    }
    else
    {
        a = 2;
  4a:   c7 45 f8 02 00 00 00    mov    DWORD PTR [rbp-0x8],0x2
  51:   b8 00 00 00 00          mov    eax,0x0
    } 
```

可以看到 `if(r == 0)` 被编译成了 `cmp` 和 `jne` 两条指令：

- `DWORD PTR` 代表操作的数据类型是 32 位的整数，而 `[rbp-0x4]` 则是一个寄存器的地址，所以第一个操作数就是从指定的寄存器里拿到变量 r 的值，接着跟第二个操作数进行比较，并将结果存到**条件码寄存器**。

- 如果比较结果为 True，就把**标志条件码**（对应的条件码是 ZF，Zero Flag）设置为 1。

  > cmp 指令可以理解为是在对两个操作数做减法，但是不保存结果，而是根据计算结果，修改条件码寄存器的标志位：CF（是否借位）、PF（bit 位位 1 的奇偶数）、ZF（结果是否为 0）、SF（符号位）、OF（溢出位）。

- `jne`（ jump if not equal）指令会查看对应的标志位，如果为 0，则会跳转到后面操作数 4a 指定的位置。

  > 除了零标志之外，Intel 的 CPU 下还有**进位标志**（CF，Carry Flag）、**符号标志**（SF，Sign Flag）以及**溢出标志**（OF，Overflow Flag），用在不同的判断条件下。
  >
  > J 指令除了 jne（Jump if not equal）之外，还有 jle（Jump if less or equal）等，不同指令读取的是条件码寄存器上不同的标志位，对应关系详见[链接](http://www.unixwiz.net/techtips/x86-jumps.html)。

- 最后一条指令的操作数 `eax` ，代表累加寄存器，通常没有实际作用，只是代表一个占位符，这是由于 main 函数一般没有返回值，因此特意生成一个返回值为 0 的默认指令。

![](https://static001.geekbang.org/resource/image/b4/fa/b439cebb2d85496ad6eef2f61071aefa.jpeg)

实际上，for loop 也是借助 J 指令来实现的，以下面汇编码为例：

```java
    for (int i = 0; i <= 2; i++)
   b:   c7 45 f8 00 00 00 00    mov    DWORD PTR [rbp-0x4],0x0
  12:   eb 0a                   jmp    1e 
    {
        a += i;
  14:   8b 45 f8                mov    eax,DWORD PTR [rbp-0x4]
  17:   01 45 fc                add    DWORD PTR [rbp-0x8],eax

  1a:   83 45 f8 01             add    DWORD PTR [rbp-0x4],0x1
  1e:   83 7d f8 02             cmp    DWORD PTR [rbp-0x4],0x2
  22:   7e f0                   jle    14 
  24:   b8 00 00 00 00          mov    eax,0x0
    }
```

可以看到，在 1e 以及 22 处，通过 `cmp` 以及 `jle` 的结合使用，不断地从 22 调回 14 处，直到满足条件才能执行到 24。

![](https://static001.geekbang.org/resource/image/fb/17/fb50fe39181abb0f70fcfec53cf12317.jpg)

指令的执行，除了简单地通过 PC 寄存器自增的方式顺序执行外，条件码寄存器会记录下当前执行指令的条件判断状态，然后通过跳转指令读取对应的条件码，修改 PC 寄存器内的下一条指令的地址，最终实现 if…else 以及 for/while 这样的程序控制流程。

因此，想要实现 goto 这个语义，需要三个寄存器来实现：PC 寄存器、指令寄存器、条件码寄存器。
