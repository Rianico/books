---
title: 11. 虚拟内存和内存保护
date: 2021-03-07
---



## 1. 虚拟内存与物理内存

虚拟内存技术，让程序运行过程中认为自己有一块连续的内存，从而无需要再关注真实的物理内存。虚拟内存则会被操作系统，其映射到真正的物理内存上去，映射的方式称为**页表**。

## 2. 简单页表

一个虚拟/物理内存的地址可以分成**页号（Directory）**和**偏移量（Offset）**两个部分。

页表会将一个虚拟地址的页号映射到物理地址上，再加上偏移量，就是虚拟地址所对应的物理内存地址了。

如果物理内存按照 4KB 的大小来分页，那么一个虚拟地址则会有 20bit 高位表示页号，12bit 低位表示偏移量。

![](https://static001.geekbang.org/resource/image/22/0f/22bb79129f6363ac26be47b35748500f.jpeg)

这种简单页表方式有个弊端，就是页表体积过大。假设一台服务器的内存为 4GB，则页表共需要存储 4GB/4KB = 2^20 个虚拟地址映射，每个虚拟地址为 4bytes，则页表共需要 4MB 大小。

## 3. 多级页表

程序在内存中的布局，往往是两头实中间空的布局，栈自顶向下占用空间，而堆则是自底向上的，所以虚拟内存往往也可以分为两块连续的内存空间。

多级页表是简单页表的改进，采用了时间换空间的方式。

这种方式下，页表会按照多叉树的结构，分为多级结构。这样一来，就不用加载全部虚拟地址映射关系，而是按需加载所需的树节点即可，这种方式也常称为**页表树（Page Table Tree）** ：

![](https://static001.geekbang.org/resource/image/5b/4e/5ba17a3ecf3f9ce4a65546de480fcc4e.jpeg)

由于虚拟内存空间通常是连续，因此第一层（4 级页表）的很多子节点都是空的，从上往下，以此类推，这样一来，可以大大的减少需要加载的页表条目。

假设每一级页表都用 5bit 表示，那么一个页表下可以有 32 个页表条目，则一个一级页表可以表示 32 * 4KB = 128KB 的内存空间。

如果一个程序请求空间为 8MB，划分为两块连续的 4MB 内存，则共需要 64 个一级索引，2 个填满的二级索引，2 个三级索引，1 个 4 级索引，共 69 个索引表，每个索引表 128 字节，只需要约 9KB 的页表空间大小。

简单来说，一级页表可以从 程序总内存/128K 求得需要的个数，之后每往上每一层则除以 32，每层都相加可以得到最终的页表索引数目。对比原来的简单列表，需要的页表索引数目大大减少（按需存取）。

## 3. 加速地址转换

页表是存储在内存空间的，如果每次 CPU 需要获取虚拟内存对应的物理内存地址都需要访问内存（多级页表则需要访问多次），那么这个效率是十分低下的。

现代的 CPU 采取了两个策略来加速地址转换：

- CPU 里添加一块缓存芯片，称之为 TLB（Translation-Lookaside Buffer，地址变换高速缓冲），会缓存之前查询过的地址转换结果
  - 由于内存空间是连续的，通常连续多条指令也都会属于同一个虚拟页号
  - TLB 缓存同样也分为数据（DTLB）以及指令（ITLB）
  - TLB 同样可以根据大小划分为 L1、L2，同时也会采用脏标记来执行回写

- CPU 里封装一个**内存管理单元（MMU，Memory Management Unit）**芯片，用来完成地址转换，负责 CPU与 TLB 的交换和访问

![](https://static001.geekbang.org/resource/image/43/d9/432050446f68569a37c7699cccda75d9.jpeg)

## 4. 安全性与内存保护

计算机底层对内存的一些保护措施：

1. 可执行空间保护（Executable Space Protection），将内存划分为可执行部分（通常是指令）以及不可执行部分（通常是数据），类似于常见的 SQL 注入，将注入的部分划分为不可执行部分，当成普通的数据。
2. 地址空间布局随机化（Address Space Layout Randomization），如果内存布局按照固定套路分配，则可以很容易的猜测出内存哪部分属于指令部分，哪部分属于数据部分，因此进程内存空间会将各部分内存的布局不再固定，而是加入随机性。