---
title: 程序的执行
date: 2020-08-29
---



## 1. 方法调用

### 1.1 压栈和出栈

虽然可以试用跳转自由跳转到对应的地址，但是实际上程序调用方法的时候，并不是使用单纯的 jmp 指令，而是使用 call 指令完成方法的调用，这个指令涉及到了栈以及跳转。

> 栈是一个后进先出（LIFO，Last In First Out）的数据结构。

以下面的代码为例：

```C
// function_example.c
#include <stdio.h>
int static add(int a, int b)
{
    return a+b;
}


int main()
{
    int x = 5;
    int y = 10;
    int u = add(x, y);
}
```

进行编译：

```bash
$ gcc -g -c function_example.c
$ objdump -d -M intel -S function_example.o
```

汇编码如下：

```assembly
int static add(int a, int b)
{
   0:   55                      push   rbp
   1:   48 89 e5                mov    rbp,rsp
   4:   89 7d fc                mov    DWORD PTR [rbp-0x4],edi
   7:   89 75 f8                mov    DWORD PTR [rbp-0x8],esi
    return a+b;
   a:   8b 55 fc                mov    edx,DWORD PTR [rbp-0x4]
   d:   8b 45 f8                mov    eax,DWORD PTR [rbp-0x8]
  10:   01 d0                   add    eax,edx
}
  12:   5d                      pop    rbp
  13:   c3                      ret    
0000000000000014 <main>:
int main()
{
  14:   55                      push   rbp
  15:   48 89 e5                mov    rbp,rsp
  18:   48 83 ec 10             sub    rsp,0x10
    int x = 5;
  1c:   c7 45 fc 05 00 00 00    mov    DWORD PTR [rbp-0x4],0x5
    int y = 10;
  23:   c7 45 f8 0a 00 00 00    mov    DWORD PTR [rbp-0x8],0xa
    int u = add(x, y);
  2a:   8b 55 f8                mov    edx,DWORD PTR [rbp-0x8]
  2d:   8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]
  30:   89 d6                   mov    esi,edx
  32:   89 c7                   mov    edi,eax
  34:   e8 c7 ff ff ff          call   0 <add>
  39:   89 45 f4                mov    DWORD PTR [rbp-0xc],eax
  3c:   b8 00 00 00 00          mov    eax,0x0
}
  41:   c9                      leave  
  42:   c3                      ret    
```

可以看到，在 call 指向地址 0 （调用 add 方法）之后，开头就执行了 `push` 以及 `mov` 指令，这里称为**压栈**（Push）。在方法结束时，又执行了 `pop` 以及 `ret` 指令，这里称为**出栈**（Pop）。栈是存储在内存上的。

- ESP/RSP（64 位机器）：栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。（64位机器变为RSP）
- EBP/RBP（64 位机器）：基址指针寄存器(extended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。
- `push rbp`：将 rbp 中的值进行压栈。
- `pop  rbp`：弹出最近一次 push 到栈中的值至 rbp 中。

上面的调用流程如下：

1. `call` 会将 PC 中下一条要执行的指令地址（即返回地址）压栈；
2. `push rbp` ，把当前的栈帧的栈底压栈，也就是 main 函数的栈底地址。
3. `mov rbp,rsp` 把 rsp 的地址赋值给 rbp，此时 rbp 指向 add 栈底地址（这样 add 方法中后面的地址才能正确计算）；
4. add 函数执行完成后，会调用 `pop rbp` 将之前 push 压栈的指针（即 main 的栈底）出栈，并重新赋值给 rbp；
5. `ret` 指令会将返回地址出栈弹至 PC 中。

借助栈这种数据结构，我们只需要维护好 `rbp` 以及 `rsp` 这两个寄存器的地址即可。

![](https://static001.geekbang.org/resource/image/d0/be/d0c75219d3a528c920c2a593daaf77be.jpeg)

### 1.2 为什么需要压栈和出栈？

如果不使用栈的方式，而是在调用函数的地方，插入对应函数的指令，那么当 A 函数调用 B 函数， B 函数又调用 A 函数的时候，就会需要相互往里面插指令，从而导致代码无限展开。

如果不通过 jmp 指令，而是借助寄存器来存储指令地址也可以，但是存储器的数量是有限的，一旦嵌套层数较多就存不下了。

### 1.3 内联优化

虽然前面提到在函数相互调用的时候，直接在调用函数的地方插入指令不可行，但当代码里没有调用其他方法的时候，这是可行的。

这个方法属于编译器一个自动优化的场景，称为**函数内联**（Inline）。在使用 gcc 编译的时候，加上参数 `-O`，编译器就会在可行的情况下进行内联优化。

以下面代码为例 ：

```c
#include <stdio.h>
#include <time.h>
#include <stdlib.h>

int static add(int a, int b)
{
    return a+b;
}

int main()
{
    srand(time(NULL));
    int x = rand() % 5
    int y = rand() % 10;
    int u = add(x, y)
    printf("u = %d\n", u)
}
```

进行编译：

```bash
$ gcc -g -c -O function_example_inline.c
$ objdump -d -M intel -S function_example_inline.o
```

可以看到方法调用被优化成了以下指令：

```java
    return a+b;
  4c:   01 de                   add    esi,ebx
```

内联的优势是，需要执行的指令数变少了，也不再需要入栈、出栈。但内联展开也有一定代价，比如函数展开，也意味整个程序占用的空间变大。

> 在 Java 中，当一个方法成为热点方法，且方法体足够小的时候，也会被内联。

## 2. 编译、链接和装载

实际上，从程序到可执行的机器码，并不仅仅是编译那么简单，而是可以分为两大部分：

1. 第一个部分由**编译**（Compile）、**汇编**（Assemble）以及**链接**（Link）三个阶段组成。在这三个阶段完成之后，我们就生成了一个可执行文件。
2. 第二部分，通过**装载器**（Loader）把可执行文件**装载**（Load）到内存中。CPU 从内存中读取指令和数据，来开始真正执行程序。

![](https://static001.geekbang.org/resource/image/99/a7/997341ed0fa9018561c7120c19cfa2a7.jpg)

以下面两个代码为例：

```c
// add_lib.c
int add(int a, int b)
{
    return a+b;
}
```

```C
// link_example.c

#include <stdio.h>
int main()
{
    int a = 10;
    int b = 5;
    int c = add(a, b);
    printf("c = %d\n", c);
}
```

直接对这两个文件进行编译：

```bash
$ gcc -g -c add_lib.c link_example.c
$ objdump -d -M intel -S add_lib.o
$ objdump -d -M intel -S link_example.o
```

两个文件的汇编码如下：

```assembly
add_lib.o:     file format elf64-x86-64
Disassembly of section .text:
0000000000000000 <add>:
// add_lib.c
int add(int a, int b)
{
   0:   f3 0f 1e fa             endbr64
   4:   55                      push   rbp
   5:   48 89 e5                mov    rbp,rsp
   8:   89 7d fc                mov    DWORD PTR [rbp-0x4],edi
   b:   89 75 f8                mov    DWORD PTR [rbp-0x8],esi
    return a+b;
   e:   8b 55 fc                mov    edx,DWORD PTR [rbp-0x4]
  11:   8b 45 f8                mov    eax,DWORD PTR [rbp-0x8]
  14:   01 d0                   add    eax,edx
  16:   5d                      pop    rbp
  17:   c3                      ret
```

```assembly
Disassembly of section .text:
0000000000000000 <main>:
// link_example.c
#include <stdio.h>
int main()
{
   0:   f3 0f 1e fa             endbr64
   4:   55                      push   rbp
   5:   48 89 e5                mov    rbp,rsp
   8:   48 83 ec 10             sub    rsp,0x10
    int a = 10;
   c:   c7 45 f4 0a 00 00 00    mov    DWORD PTR [rbp-0xc],0xa
    int b = 5;
  13:   c7 45 f8 05 00 00 00    mov    DWORD PTR [rbp-0x8],0x5
    int c = add(a, b);
  1a:   8b 55 f8                mov    edx,DWORD PTR [rbp-0x8]
  1d:   8b 45 f4                mov    eax,DWORD PTR [rbp-0xc]
  20:   89 d6                   mov    esi,edx
  22:   89 c7                   mov    edi,eax
  24:   b8 00 00 00 00          mov    eax,0x0
  29:   e8 00 00 00 00          call   2e <main+0x2e>
  2e:   89 45 fc                mov    DWORD PTR [rbp-0x4],eax
    printf("c = %d\n", c);
  31:   8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]
  34:   89 c6                   mov    esi,eax
  36:   48 8d 3d 00 00 00 00    lea    rdi,[rip+0x0]        # 3d <main+0x3d>
  3d:   b8 00 00 00 00          mov    eax,0x0
  42:   e8 00 00 00 00          call   47 <main+0x47>
  47:   b8 00 00 00 00          mov    eax,0x0
  4c:   c9                      leave
  4d:   c3                      ret
```

如果直接执行 `./link_example.o` 是无法执行的，这是由于在 `call 2a <main+0x2a>`（调用 add 方法） 处，程序无法正确找到需要执行的指令。

使用 objdump 出来的汇编代码里面的重复地址，都是因为 add_lib.o 以及 link_example.o 并不是一个**可执行文件**（Executable Program），而是**目标文件**（Object File）。只有通过**链接器**（Linker）把多个目标文件以及调用的各种函数库链接起来，才能得到一个可执行文件。

使用链接器对两个目标文件进行链接：

```c
$ gcc -o link-example add_lib.o link_example.o
$ ./link_example
c = 15
```

程序最终是通过装载器变成指令和数据的，所以其实生成的可执行代码 `link_example` 也并不只是一条条指令，其内容如下：

```assembly
link_example:     file format elf64-x86-64
Disassembly of section .init:
...
Disassembly of section .plt:
...
Disassembly of section .plt.got:
...
Disassembly of section .text:
...

 6b0:   55                      push   rbp
 6b1:   48 89 e5                mov    rbp,rsp
 6b4:   89 7d fc                mov    DWORD PTR [rbp-0x4],edi
 6b7:   89 75 f8                mov    DWORD PTR [rbp-0x8],esi
 6ba:   8b 55 fc                mov    edx,DWORD PTR [rbp-0x4]
 6bd:   8b 45 f8                mov    eax,DWORD PTR [rbp-0x8]
 6c0:   01 d0                   add    eax,edx
 6c2:   5d                      pop    rbp
 6c3:   c3                      ret    
00000000000006c4 <main>:
 6c4:   55                      push   rbp
 6c5:   48 89 e5                mov    rbp,rsp
 6c8:   48 83 ec 10             sub    rsp,0x10
 6cc:   c7 45 fc 0a 00 00 00    mov    DWORD PTR [rbp-0x4],0xa
 6d3:   c7 45 f8 05 00 00 00    mov    DWORD PTR [rbp-0x8],0x5
 6da:   8b 55 f8                mov    edx,DWORD PTR [rbp-0x8]
 6dd:   8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]
 6e0:   89 d6                   mov    esi,edx
 6e2:   89 c7                   mov    edi,eax
 6e4:   b8 00 00 00 00          mov    eax,0x0
 6e9:   e8 c2 ff ff ff          call   6b0 <add>
 6ee:   89 45 f4                mov    DWORD PTR [rbp-0xc],eax
 6f1:   8b 45 f4                mov    eax,DWORD PTR [rbp-0xc]
 6f4:   89 c6                   mov    esi,eax
 6f6:   48 8d 3d 97 00 00 00    lea    rdi,[rip+0x97]        # 794 <_IO_stdin_used+0x4>
 6fd:   b8 00 00 00 00          mov    eax,0x0
 702:   e8 59 fe ff ff          call   560 <printf@plt>
 707:   b8 00 00 00 00          mov    eax,0x0
 70c:   c9                      leave  
 70d:   c3                      ret    
 70e:   66 90                   xchg   ax,ax
...
Disassembly of section .fini:
...
```

可以看到，文件内容多了很多东西。

在 Linux 下，可执行文件和目标文件所使用的都是一种叫 **ELF**（Execuatable and Linkable File Format，可执行与可链接文件格式）的文件格式，这里面不仅存放了编译成的汇编指令，还保留了很多别的数据。

ELF 文件把各种信息，拆分为一个个 Section 保存起来， 有一个基本的**文件头**（File Header），用来表示这个文件的基本属性（比如是否是可执行文件，对应的 CPU、操作系统等等）。除了这些基本属性之外，大部分程序还有这么一些 Section：

1. `.text Section`，也叫作**代码段**或者**指令段**（Code Section），用来保存程序的代码和指令；
2. `.data Section`，也叫作**数据段**（Data Section），用来保存程序里面设置好的初始化数据信息；
3. `.rel.text Secion`，叫作**重定位表**（Relocation Table）。重定位表里，保留的是当前的文件里面，哪些跳转地址其实是我们不知道的。比如上面的 link_example.o 里面，我们在 main 函数里面调用了 add 和 printf 这两个函数，但是在链接发生之前，我们并不知道该跳转到哪里，这些信息就会存储在重定位表里；
4. `.symtab Section`，叫作**符号表**（Symbol Table）。符号表保留了我们所说的当前文件里面定义的函数名称和对应地址的地址簿。

![](https://static001.geekbang.org/resource/image/27/b3/276a740d0eabf5f4be905fe7326d9fb3.jpg)



**链接器**会扫描所有输入的目标文件，然后把所有**符号表**里的信息收集起来，构成一个**全局的符号表**。然后再根据**重定位表**，把所有不确定要跳转地址的代码，根据符号表里面存储的地址，进行一次修正。最后，把所有的目标文件的对应段进行一次**合并**，变成了最终的可执行代码。

![](https://static001.geekbang.org/resource/image/f6/12/f62da9b29aa53218f8907851df27f912.jpeg)

在这之后，装载器只需要解析 ELF 文件，把对应的指令和数据加载到内存中供 CPU 执行即可。

> Windows 上的格式称为 **PE**（Portable Executable Format），与 Linux 不同，因此同一个程序无法在不同操作系统下执行。
>
> Java 的跨平台是交由 JVM 去实现的，JVM 根据不同平台有不同的实现。

ELF 可以看作是程序经过编译->汇编转化为机器码后存放的载体。

编译型的语言都是通过先转化为汇编，再转化为机器码执行的，也存在部分语言是通过解释器、虚拟机等翻译成机器码执行的。

查看符号表以及重定位表：

```c
//查看符号表
readelf -s link_example.o
//查看重定位表
objdump -r link_example.o
```

## 3. 分段及分页

装载器装载程序时，需要满足以下两个要求：

1. **可执行程序加载后占用的内存空间应该是连续的**，在执行指令的时候， PC 是按顺序一条条执行的，因此要求指令存放在连续的内存空间中。
2. **由于需要同时加载很多个程序，因此不能让程序自己规定在内存中加载的位置**，这部分应当交由操作系统控制。

针对第二个问题，我们一般通过映射的方式去解决，把指令里用到的内存地址叫作**虚拟内存地址**（Virtual Memory Address，通常位于硬盘），实际在内存硬件里面的空间地址，我们叫**物理内存地址**（Physical Memory Address）。

这样一来，程序就不需要关心指令的地址了，而是借助虚拟内存地址，认为自己有一块连续的内存，虚拟内存与物理内存之间的映射关系则交由操作系统去处理。这个映射关系则是交由页表来维护的。

至于第一个要求，根据历史的演化，共经历了**分段**（Segmentation）以及**分页**（Paging）两个历程。

### 3.1 分段

分段，通过找出一段连续的物理内存与虚拟内存地址进行映射。

![](https://static001.geekbang.org/resource/image/24/18/24596e1e66d88c5d077b4c957d0d7f18.png)

分段存在一个问题，就是**内存碎片**（Memory Fragmentation），当一个程序退出时，如果释放的那段内存地址正好位于中间，而后面新装载的程序所需内存又大于那段释放的内存，那么那段释放的内存是无法使用的。

![](https://static001.geekbang.org/resource/image/57/d1/57211af3053ed621aeb903433c6c10d1.png)

这个问题可以通过内存交换（Memory Swapping）来解决，通过将正在运行的程序先交换到硬盘，再由硬盘重新交换到之前被释放的内存，从而消除碎片。

但是硬盘的访问速度要比内存慢很多，每一次内存交换，都需要把一大段连续的内存数据写到硬盘上。因此，这个方案从效率上来看仍有不足。

### 3.2 分页

针对分段的解决方案，分页主要从两个方向出发：

1. 减少内存碎片；
2. 减少交换的数据。

和分段这样分配一整段连续的空间给到程序相比，分页是把**整个物理内存空间切成一段段固定尺寸的大小**（Linxu 通常设定为 4KB）；虚拟内存空间也会同样切成一段段固定尺寸的大小。这样**一个连续并且尺寸固定**的内存空间，我们叫**页**（Page）。

从虚拟内存到物理内存的映射，不再是拿整段连续的内存的物理地址，而是按照一个一个页来的。

```bash
// 查看分页大小
$ getconf PAGE_SIZE
```

这样一来，释放内存后就不再会有空间碎片，而是会有多个小块的内存页。即使一旦内存不够了，需要交换的只有少部分的小内存页。

分页还存在一个好处，就是不需要一次性把全部程序加载到内存中，而是按需加载：当要读取特定的页，却发现数据并没有加载到物理内存里的时候，就会触发一个来自于 CPU 的**缺页错误**（Page Fault），操作系统会捕捉到这个错误，然后将对应的页，从存放在硬盘上的虚拟内存里读取出来，加载到物理内存。

![](https://static001.geekbang.org/resource/image/0c/f0/0cf2f08e1ceda473df71189334857cf0.png)

通过**虚拟内存、内存分页、内存交换**这三个技术，使得程序不再需要关心物理内存地址、大小以及当前分配空间的问题。

这种解决方案是计算机的软硬件开发中常用的一种方法，就是加入一个**间接层**。

> NOTE：程序要求页的物理内存地址必须是连续的，但是页与页之间并不要求是连续的物理内存。

### 3.3 思考

1. **比尔·盖茨在上世纪 80 年代说的 “640K ought to be enough for anyone” 正确吗？**
   - 从技术上来讲，是正确的，理论上内存只需要存放需要执行的指令，这部分占用的内存实际很少，但是其他部分如数据等，如果都放到硬盘按需加载，那么就会导致计算机速度非常慢。
2. Java 这样使用虚拟机的编程语言里面，写的程序是怎么装载到内存里面的？是通过内存分页和内存交换的方式加载到内存里面来的么？
   - 首先 JVM 是一个应用级的程序，也会使用内存分页、内存交换的管理方式。
   - 其次 Java 是先编译为字节码，再由 JVM 翻译为机器码的，受到 JVM 的内存管理策略。

## 4. 动态链接

链接器会将不同不同模块的代码链接到一起，最终生成一个可执行的程序，但对于一些通用的标准代码，如果每个程序都生成一份，那么将会导致空间的浪费：

![](https://static001.geekbang.org/resource/image/09/51/092dfd81e3cc45ea237bb85557bbfa51.jpg)

我们将代码分成一个个文件、模块，其实就是为了模块化，标准化，而链接除了将有其拼接起来的目的之外，同时还为了达到复用，节省内存空间的目的。

对于我们自己编写的代码，链接器合并代码的方法称为**静态链接**（Static Link）；而调用系统内存中**共享库**（Shared Libraries）代码的方式则称为**动态链接**（Dynamic Link）。

加载到内存中的共享库会被很多个程序的指令调用到，在 Windows 下，这些共享库文件就是 `.dll` 文件，也就是 **Dynamic-Link Libary**（DLL，动态链接库）。在 Linux 下，这些共享库文件就是 `.so` 文件，也就是 **Shared Object**（一般也称之为动态链接库）。

![](https://static001.geekbang.org/resource/image/29/60/2980d241d3c7cbfa3724cb79b801d160.jpg)

共享库代码的一个前提是：**机器码必须是地址无关（Position-Independent Code）的**。也就是这段代码无论加载在那个内存地址，都能够正常执行。

常见的函数库都是地址无关的，它们都接受特定的输入，进行确定的操作，然后返回结果，代码逻辑和输入的数据在内存里面的位置并不重要。

常见的地址相关的代码，比如绝对地址代码（Absolute Code）、利用重定位表的代码等等，都是地址相关的代码。

> 比如静态链接中的重定位表，在程序编译链接的时候，函数调用跳转的地址就已经确定。一旦函数在内存中的地址发生变化，那么跳转就会失败。

![](https://static001.geekbang.org/resource/image/8c/4a/8cab516a92fd3d7e951887808597094a.jpg)

对于所有动态链接共享库的程序来讲，**共享库用的都是同一段物理内存地址**，但是在不同的应用程序里，它所在的**虚拟内存地址是不同的**。

> NOTE：动态链接同一个共享库的时候，不同程序的指向共享库的虚拟内存也是不同的，如果要求相同，那意味着我们编写程序的时候就需要关心到内部的地址分配了。

动态代码库内部的变量和函数调用都很容易解决，通过使用**相对地址**（Relative Address），各种指令中使用到的内存地址，给出的不是一个绝对的地址空间，而是一个相对于当前指令偏移量的内存地址。因为整个共享库是放在**一段连续的虚拟内存**地址中的，**无论装载到哪一段地址，不同指令之间的相对地址都是不变的**。

### 4.1 PLT 和 GOT

PLT（Procedure Link Table），程序链接表，目的是为了做延迟绑定，一旦调用到，才会去更新 GOT。

GOT（Global Offset Table），全局偏移表，共享库的代码部分的物理内存是共享的，但是数据部分是各个动态链接它的应用程序里面**各加载一份**的。

程序正是通过上面两个解决方案来解决动态链接的问题的。

以下面代码为例：

```C
// lib.h
#ifndef LIB_H
#define LIB_H

void show_me_the_money(int money);

#endif
```

lib.c 包含了 lib.h 的实际实现：

```C
// lib.c
#include <stdio.h>


void show_me_the_money(int money)
{
    printf("Show me USD %d from lib.c \n", money);
}
```

show_me_poor.c 调用了 lib 里面的函数：

```C
// show_me_poor.c
#include "lib.h"
int main()
{
    int money = 5;
    show_me_the_money(money);
}
```

最后，把 lib.c 编译成了一个动态链接库，也就是 .so 文件：

```bash
# -fPIC 表示与地址无关，即 Position Independent Code 
$ gcc lib.c -fPIC -shared -o lib.so
$ gcc -o show_me_poor show_me_poor.c ./lib.so
```

查看 show_me_poor 汇编码：

```bash
$ objdump -d -M intel -S show_me_poor
```

内容如下：

```assembly
……
0000000000400540 <show_me_the_money@plt-0x10>:
  400540:       ff 35 12 05 20 00       push   QWORD PTR [rip+0x200512]        # 600a58 <_GLOBAL_OFFSET_TABLE_+0x8>
  400546:       ff 25 14 05 20 00       jmp    QWORD PTR [rip+0x200514]        # 600a60 <_GLOBAL_OFFSET_TABLE_+0x10>
  40054c:       0f 1f 40 00             nop    DWORD PTR [rax+0x0]

0000000000400550 <show_me_the_money@plt>:
  400550:       ff 25 12 05 20 00       jmp    QWORD PTR [rip+0x200512]        # 600a68 <_GLOBAL_OFFSET_TABLE_+0x18>
  400556:       68 00 00 00 00          push   0x0
  40055b:       e9 e0 ff ff ff          jmp    400540 <_init+0x28>
……
0000000000400676 <main>:
  ......
  40068a:       e8 c1 fe ff ff          call   400550 <show_me_the_money@plt>
  ......
……
```

调用共享库汇编代码为 `call   400550 <show_me_the_money@plt>`，后面的 `@plt` 表示要从 PLT 中找要调用的函数，地址为 400550.

在 400550 处，又跳转了一次，后面的注释为 `GLOBAL_OFFSET_TABLE+0x18`，其中的 `GLOBAL_OFFSET_TABLE` 就是**全局偏移表**。

```assembly
400550:       ff 25 12 05 20 00       jmp    QWORD PTR [rip+0x200512]        # 600a68 <_GLOBAL_OFFSET_TABLE_+0x18>
```

在动态链接对应的共享库 data section 里面，保存了一张**全局偏移表**（GOT，Global Offset Table）。

虽然共享库的代码部分的物理内存是共享的，但是**数据部分是各个动态链接它的应用程序里面各加载一份**的。所有需要引用当前共享库地址的外部指令，都会查询 GOT，来找到当前运行程序的虚拟内存里的对应位置。而 GOT 表里的数据，则是在加载一个个共享库的时候写进去的。

不同的进程，调用同样的 lib.so，各自 GOT 里面指向最终加载的动态链接库里面的虚拟内存地址是不同的。

![](https://static001.geekbang.org/resource/image/11/c8/1144d3a2d4f3f4f87c349a93429805c8.jpg)

GOT 表位于共享库自己的数据段里。GOT 表在内存里和对应的代码段位置之间的偏移量，始终是确定的。

对应的各个程序只需要在物理内存里面加载同一份代码，当需要用到外部变量和函数的地址时，查询各自的 GOT 表即可。

> NOTE：这种运行时才确定具体调用的，还有 Java 中的多态

