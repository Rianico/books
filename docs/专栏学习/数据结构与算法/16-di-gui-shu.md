---
title: 16-di-gui-shu
date: 2020-07-22 14:48:49
permalink: /pages/d7b69f/
categories: 
  - Algorithm
  - 数据结构与算法（专栏学习）
tags: 
  - 
---
# 16 | 二叉树

树除了之前提到的用法，还有一种特殊用法：分析递归的时间复杂度。

有些情况，比如快排的平均时间复杂度的分析，用递推公式的话，会涉及非常复杂的数学推导。这时我们就可以借助树来分析递归的时间复杂度。

## 1. 递归树与时间复杂度分析

递归的思想就是，将一个问题拆成小问题来解决，并逐层分解，直到不能再被拆分为止，这样的过程我们可以将其表示为一棵树。

以裴波那契数列为例，将其以递归方式进行拆解如图：

![](https://static001.geekbang.org/resource/image/1d/a3/1d9648b7f43e430473d76d24803159a3.jpg)

再来看归并排序，归并排序也是每次都从中间进行拆分，表示为树就是：

![](https://static001.geekbang.org/resource/image/c6/d0/c66bfc3d02d3b7b8f64c208bf4c948d0.jpg)

我们把每一层花费的时间记为 n ，现在，我们只需要知道这棵树的高度 h，用高度 h 乘以每一层的时间消耗 n，就可以得到总的时间复杂度 O\(n∗h\)。

从上图能看出，这棵树是一颗满二叉树，满二叉树的高度 h 约为 logn ，因此我们可以得到总的时间复杂度为 nlogn 。

## 2. 分析快速排序的时间复杂度

快速排序算法，理想状态下，每次分区都能一分为二，但是现实情况往往没法这么理想，我们假设每次分区的比例为 1:k ，每层花费的时间为 n ，那么两个分区耗费的时间也可以大致的表示为 1:k 。我们取 k 为 9 ，并表示为树：

![](https://static001.geekbang.org/resource/image/44/43/44972a3531dae0b7a0ccc935bc13f243.jpg)

由于分区并不是每次都均匀的一分为二，因此这棵树并不是一颗**满二叉树**，但也有一个简单的解决办法，就是将递归树中最短的路径诚意 1/10 ，最长路径乘以 9/10 ，加上快速排序最小区间为 1 个，节点可以很容易的得到树的最短和最长路径：

![](https://static001.geekbang.org/resource/image/7c/ed/7cea8607f0d92a901f3152341830d6ed.jpg)

根据大 O 表示法，对数的底数不管是多少，都可以笼统的表示为 logn ，因此快速排序即使分区不均匀，时间复杂度仍为 n\*h = nlogn 。

## 3. 分析斐波那契数列的时间复杂度

先看下裴波那契数列的实现：

```java
int f(int n) {
  if (n == 1) return 1;
  if (n == 2) return 2;
  return f(n-1) + f(n-2);
}
```

将其拆解为递归树如下：

![](https://static001.geekbang.org/resource/image/9c/ce/9ccbce1a70c7e2def52701dcf176a4ce.jpg)

由于每次减少的数一边是 1 ，一边是 2 ，因此这棵树也不是一颗满二叉树，两边的路径长度不一。所以，从根节点走到叶子节点，每条路径是长短不一的。如果每次都是 −1，那最长路径大约就是 n；如果每次都是 −2，那最短路径大约就是 n/2。

如果路径长度都为 n，那这个总和就是 ：

![](https://static001.geekbang.org/resource/image/86/1f/86d301fc5fa3088383fa5b45f01e4d1f.jpg)

如果路径长度都是 n/2 ，那这个总合就是：

![](https://static001.geekbang.org/resource/image/55/d4/55fcb1570dfa09e457cdb93ba58777d4.jpg)

所以，这个算法的时间复杂度就介于 $O\(2^n\)$ 和 $O\(2^{n/2}\)$ 之间。虽然这个结果不够精确，但也能看出这个算法的时间复杂度是指数级别。

## 4. 分析全排列的时间复杂度

“如何把 n 个数据的所有排列都找出来”，这就是全排列的问题。

比如，1，2，3 这样 3 个数据，有下面这几种不同的排列：

```java
1, 2, 3
1, 3, 2
2, 1, 3
2, 3, 1
3, 1, 2
3, 2, 1
```

我们可以通过递归的方式将其求解出来，一旦确定了最后一位是哪个数字，剩下的问题就变成了求解剩下的 n-1 个数据的排列问题，而最后一位数可以是 n 个数据中的任意一个，最终问题就被拆解为了 n 个 “n−1 个数据的排列”的子问题。

递推公式如下：

> 假设数组中存储的是1，2， 3...n。 f\(1,2,...n\) = {最后一位是1, f\(n-1\)} + {最后一位是2, f\(n-1\)} +...+{最后一位是n, f\(n-1\)}。

代码实现如下：

```java
// 调用方式：
// int[]a = a={1, 2, 3, 4}; printPermutations(a, 4, 4);
// k表示要处理的子数组的数据个数
public void printPermutations(int[] data, int n, int k) {
  if (k == 1) {
    for (int i = 0; i < n; ++i) {
      System.out.print(data[i] + " ");
    }
    System.out.println();
  }

  for (int i = 0; i < k; ++i) {
    int tmp = data[i];
    data[i] = data[k-1];
    data[k-1] = tmp;

    printPermutations(data, n, k - 1);

    tmp = data[i];
    data[i] = data[k-1];
    data[k-1] = tmp;
  }
}
```

首先画出递归树，不过当前的递归树已经不是一个标准的递归树了：

![](https://static001.geekbang.org/resource/image/82/9b/82f40bed489cf29b14192b44decf059b.jpg)

第一层分解有 n 次交换操作。

第二层有 n 个节点，每个节点分解需要 n−1 次交换，所以第二层总的交换次数是 n∗\(n−1\)。

第三层有 n∗\(n−1\) 个节点，每个节点分解需要 n−2 次交换，所以第三层总的交换次数是 n∗\(n−1\)∗\(n−2\)。

以此类推，第 k 层总的交换次数就是 n∗\(n−1\)∗\(n−2\)∗…∗\(n−k+1\)。最后一层的交换次数就是 n∗\(n−1\)∗\(n−2\)∗…∗2∗1。每一层的交换次数之和就是总的交换次数。

```java
n + n*(n-1) + n*(n-1)*(n-2) +... + n*(n-1)*(n-2)*...*2*1
```

最后一个数，n∗\(n−1\)∗\(n−2\)∗…∗2∗1 等于 n!，而前面的 n−1 个数都小于最后一个数，所以，总和肯定小于 n∗n!，也就是说，全排列的递归算法的时间复杂度大于 O\(n!\)，小于 O\(n∗n!\)。

## 5. 思考

**Q：1 个细胞的生命周期是 3 小时，1 小时分裂一次。求 n 小时后，容器内有多少细胞？请你用已经学过的递归时间复杂度的分析方法，分析一下这个递归问题的时间复杂度。**

> 这里先假定细胞是在第三次分裂完后才死亡，先推导出递推公式：f\(n\) = f\(n-1\)\*2 - f\(n-3\)。
>
> 代码实现：

```scala
def fun(time: Int): Int = {
    if(time == 0) return 1
    if(time == 1) return 1 << 1
    if(time == 2) return 1 << 2
    return (fun(time - 1) << 1) - fun(time - 3)
}
println(fun(4))
// 12
```

> 画成递归树的话，一边是 -1 ，一边是 -3 ，于是可以知道这棵树不是一颗满二叉树，两边差距可以参考裴波那契数列递归树，时间复杂度为指数级。

