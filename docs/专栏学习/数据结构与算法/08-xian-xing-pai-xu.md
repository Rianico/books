---
title: 08. 线性排序
date: 2020-07-22 14:48:49
---
# 08 | 桶、计数、基数排序

排序算法中，有三种时间复杂度是 O\(n\) ：**桶排序**、**计数排序**、**基数排序**。因为这些排序算法的时间复杂度是线性的，所以我们把这类排序算法叫作**线性排序**（Linear sort）。

这几种的时间复杂、空间复杂度也较为简单，但是对使用场景较为苛刻。

## 1. 桶排序（Bucket Sort）

桶排序，就是将各个数据分配到**有序的桶**内，每个桶都放置一定大小范围的元素，在各个桶内再进行排序，排序完成都都取出来，序列就为有序的了。

![&#x6876;&#x6392;&#x5E8F;](https://static001.geekbang.org/resource/image/98/ae/987564607b864255f81686829503abae.jpg)

假设要排序的序列有n个元素，我们将其分为m个桶，理想情况下，每个桶都会有k=n/m个元素，每个桶内部使用快速排序，时间复杂度为 O\(klogk\)。m 个桶排序的时间复杂度就是 O\(m  _klogk\)，因为 k=n/m，所以整个桶排序的时间复杂度就是 O\(n_log\(n/m\)\)。当桶的个数 m 接近数据个数 n 时，log\(n/m\) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O\(n\)。

**桶排序对要排序的序列要求很高，序列要能够被均匀的分配到各个桶里，如果部分数据倾斜集中到某个桶中，那么时间复杂度就退化为了O\(nlogn\)**。

桶排序比较适合用于**外部排序**，当数据很大，内存放不下的时候，可以放在磁盘中，逐个桶进行排序最后再组合起来。

## 2. 计数排序（Counting sort）

计数排序可以看成是桶排序的一种特殊情况，当要排序的范围并不是很大的时候，比如序列有n个元素，取值范围有k，当k不是很大的时候，我们可以让每个桶都只放一种元素，这样一来就省去了桶内排序的时候。

计数排序跟桶排序十分类似，只不过桶的粒度大小不一样。

虽然计数排序跟桶排序很类似，但是由于其实现使用到了计数，因此才被成为“计数排序”。接下来介绍其具体实现。

以考试分数排名作为场景，假设只有 8 个考生，分数在 0 到 5 分之间。这 8 个考生的成绩我们放在一个数组 A\[8\] 中，它们分别是：2，5，3，0，2，3，0，3。

由于取值范围在0到5之间，共有6种可能性，因此我们新建长度为6的数组C\[6\]。C\[6\]内存储的是某个分数内考生的人数，这也是计数的由来，我们对A\[8\]进行遍历，比如3分就在C\[6\]的index为3的地方加1，直到全部遍历完成。

接着我们对C\[6\]中的元素进行顺序求和，得到如下结果：

![](https://static001.geekbang.org/resource/image/dd/1f/dd6c62b12b0dc1b3a294af0fa1ce371f.jpg)

这里解释下，从这个数组我们可以看出一些信息，比如index为3的元素为7，意味着分数&lt;=3的共有7人，顺序求和后我们就可以得到小于等于当前分数共有多少个元素后。

再对A\[8\]进行遍历，根据分数取C\[6\]中的某个元素tmp，在R\[8\]中的tmp-1出放入分数，C\[6\]对应位置-1，往复循环：

![](https://static001.geekbang.org/resource/image/1d/84/1d730cb17249f8e92ef5cab53ae65784.jpg)

最后就得到一个有序数组了。

代码实现：

```java
// 计数排序，a是数组，n是数组大小。假设数组中存储的都是非负整数。
public void countingSort(int[] a, int n) {
  if (n <= 1) return;

  // 查找数组中数据的范围
  int max = a[0];
  for (int i = 1; i < n; ++i) {
    if (max < a[i]) {
      max = a[i];
    }
  }

  int[] c = new int[max + 1]; // 申请一个计数数组c，下标大小[0,max]
  for (int i = 0; i <= max; ++i) {
    c[i] = 0;
  }

  // 计算每个元素的个数，放入c中
  for (int i = 0; i < n; ++i) {
    c[a[i]]++;
  }

  // 依次累加
  for (int i = 1; i <= max; ++i) {
    c[i] = c[i-1] + c[i];
  }

  // 临时数组r，存储排序之后的结果
  int[] r = new int[n];
  // 计算排序的关键步骤，有点难理解
  for (int i = n - 1; i >= 0; --i) {
    int index = c[a[i]]-1;
    r[index] = a[i];
    c[a[i]]--;
  }

  // 将结果拷贝给a数组
  for (int i = 0; i < n; ++i) {
    a[i] = r[i];
  }
}
```

**计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数**。

## 3. 基数排序（Radix sort）

假设我们有 10 万个手机号码，希望将这 10 万个手机号码从小到大排序，你有什么比较快速的排序方法呢？

由于手机号范围太大，桶排序以及计数排序明显不合适，因此这里可以考虑使用基数排序。

基数排序，就是从低位开始排序，每一轮排序完后指针再指向高位，对高位进行排序，如此重复，直到所有位置都进行过一轮排序，如下：

![&#x57FA;&#x6570;&#x6392;&#x5E8F;](https://static001.geekbang.org/resource/image/df/0c/df0cdbb73bd19a2d69a52c54d8b9fc0c.jpg)

这里需要注意的一点事，我们具体实现的时候算法必须是稳定的，否则高位若不稳定，会导致低位的排序失去意义。

对于每一位进行排序，我们可以使用桶排序或者计数排序来实现，如果有k位需要比较，那么时间复杂度就是kO\(n\)，当n很大的时候，k也就可以忽略了，所以基数排序的时间复杂度为O\(n\)。

实际上，有时候需要排序的数据并不都是等长的，比如英文单词排序，那么我们可以通过在低位填充元素（比如0）将其转化为等长的。

**基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O\(n\) 了**。

