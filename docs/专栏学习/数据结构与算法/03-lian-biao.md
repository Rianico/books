---
title: 03-lian-biao
date: 2020-07-22 14:48:49
permalink: /pages/6f5a01/
categories: 
  - Algorithm
  - 数据结构与算法（专栏学习）
tags: 
  - 
---
# 03 | 链表

链表（Linked list），相对于数组来看，使用了**一连串不连续的零散内存空间**来存储数据。

链表的结构五花八门，常见的链表有**单链表**、**双链表**、**循环链表**。

## 1. 几种链表结构

### 1.1 单链表

在单链表中，每个数据节点除了存储数据之外，还会额外记录指向下个一个节点的地址，我们将指向下一个节点的指针称为**后继指针 next** ，下一个节点称为**后继节点**。

![&#x5355;&#x94FE;&#x8868;](https://static001.geekbang.org/resource/image/b9/eb/b93e7ade9bb927baad1348d9a806ddeb.jpg)

在单链表中，有两个节点较为特殊，分别是第一个节点**头结点**，用来记录链表的基地址（指向第一个节点），以及最后一个节点**尾结点**，指向一个空地址 NULL ，表示是链表的最后一个节点。

在单链表中，**单纯的插入、删除**操作是非常高效的，只需要将next指向的地址修改一下即可，时间复杂度为 $O\(1\)$ 。

![&#x63D2;&#x5165;&#x3001;&#x5220;&#x9664;&#x64CD;&#x4F5C;](https://static001.geekbang.org/resource/image/45/17/452e943788bdeea462d364389bd08a17.jpg)

由于链表的内存不是连续的，因此无法像数组一样直接通过下标访问元素，而需要从头遍历到尾，直到找到所要的元素位置，时间复杂度为 $O\(n\)$ 。

单链表的结构大致如此，它还有两个升级版的结构：**循环链表**、**双向链表**。

### 1.2 循环链表

循环链表是一种特殊的单链表。循环链表的尾结点指向的是头结点，如图：

![&#x5FAA;&#x73AF;&#x94FE;&#x8868;](https://static001.geekbang.org/resource/image/86/55/86cb7dc331ea958b0a108b911f38d155.jpg)

当需要处理的数据具有环形结构的时候，如[约瑟夫问题](https://zh.wikipedia.org/wiki/约瑟夫斯问题)使用循环链表就特别合适。

但在实际开发中，更常用的一种链表是双向链表。

### 1.3 双向链表

单向链表只存储了指向下一点节点的后继指针 **next** ，而双向链表除此之外，还存储了指向上个节点（也称为**前驱节点**）的指针 **prev** ，prev 也称为**前驱指针**。

![&#x53CC;&#x5411;&#x94FE;&#x8868;](https://static001.geekbang.org/resource/image/cb/0b/cbc8ab20276e2f9312030c313a9ef70b.jpg)

对比单链表来看，存储相同的数据，双向链表花费的内存更多了，但同时也支持了双向遍历，也因此带来了操作上的灵活性。

以删除操作为例，假设要删除节点 q ，花费 $O\(n\)$ 时间查找到节点 q 后，由于需要修改 q 的前驱节点的 next 指针，因此又需要花费一次 $O\(n\)$ 的时间复杂度去查找 q 的前驱节点，而双向链表只要花费$O\(1\)$ 即可访问到前驱节点。这里也体现了一种**空间换时间**的思想。

> NOTE：其实从这还可以看出一点，链表在添加、删除指定元素的时候，由于需要遍历查找元素，实际上已经先有了 $O\(n\)$ 的开销。

在有了前面的基础知识后，双向循环链表也可以轻松的知道结构：

![&#x53CC;&#x5411;&#x5FAA;&#x73AF;&#x5EFA;&#x8868;](https://static001.geekbang.org/resource/image/d1/91/d1665043b283ecdf79b157cfc9e5ed91.jpg)

## 1.4 链表 VS 数组性能

由于内存存储方式的不同，数组跟链表在访问、删除、插入方面有了截然不同的时间复杂度：

![&#x6027;&#x80FD;&#x5BF9;&#x6BD4;](https://static001.geekbang.org/resource/image/4f/68/4f63e92598ec2551069a0eef69db7168.jpg)

但在实际开发中，不能仅仅因为时间复杂度就决定使用，还要取决于具体的使用场景。

1. 数组简单易用，使用了连续的内存空间，可以借助 **CPU 的缓存机制**，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。
2. 数组的大小一开始就固定了，一旦需要扩容，起码需要花费额外一倍多的空间进行数据的拷贝。而链表则是可以动态扩展，这也是两者之间最大的区别。

如果对内存的使用非常苛刻，那么数组会更加合适点，由于链表内存消耗会翻倍，并且链表频繁的插入、删除操作也会导致频繁的申请和释放内存，造成内存碎片。

> NOTE：关于CPU的缓存机制，是为了弥补CPU执行速度与内存访问速度过慢（相对于CPU而言）之间差异而引入的。CPU通常会有 3 级缓存（速度上 1&gt;2&gt;3，容量上 1级 2级 -&gt; 3级 开始查找，找不到才会再去内存中查找，而缓存中存放的通常是一块连续的内存数据，所以会对内存地址连续的数组更加友好。

## 2. 基于链表实现LRU算法

在缓存机制中，由于缓存空间大小有限，因此有时候需要释放部分内存空间，这时候就使用到了淘汰策略。

常见的策略有三种：**先进先出策略 FIFO**（First In，First Out）、**最少使用策略 LFU**（Least Frequently Used）、**最近最少使用策略 LRU**（Least Recently Used）。

基于链表实现的思路：维护一个有序单链表，越靠近队尾的就是越早之前使用过的。当我们需要访问某个元素时，遍历链表：

1. 若在链表中能够找到，则将该节点删除，并重新作为头结点插入链表。
2. 若在链表中无法找到，且缓存还有足够空间，则将该元素作为头结点插入链表。
3. 若在链表中无法找到，且缓存没有足够空间，则将队尾元素删除，并将该元素作为头结点插入链表。

由于以上三个操作，每次都需要遍历一次链表，因此缓存访问的时间复杂度为 $O\(n\)$ 。

## 3. 编写链表的几点技巧

链表即使掌握了理论，实际编写的时候，由于操作比较复杂，往往会出错，因此接下来以 C 语言为例，讨论几个编写链表代码的技巧。

### 1. 理解指针或引用的含义

在 C 语言中，有“指针”的概念，有些语言（比如 Java）则是将之称为“引用（Reference）”，然而不管是“指针”还是“引用”，实际上都是指**对象的内存地址**。

**对指针赋值，实际上就是将对象的内存地址赋予指针。**

C 语言中编写链表代码的时候，我们常常能看到 `p->next=q`，实际上就是将q的内存地址赋给p的next指针。`p->next=p->next->next`则是指将p的next指针存储了p的下下个节点的内存地址。

## 2. 警惕指针丢失和内存泄漏

![&#x63D2;&#x5165;&#x8282;&#x70B9;](https://static001.geekbang.org/resource/image/05/6e/05a4a3b57502968930d517c934347c6e.jpg)

以插入一个节点为例，由于需要将指针指来指去，经常就将指针指丢了，如下代码：

```c
a->next = x;  // 将p的next指针指向x结点；
x->next = a->next;  // 将x的结点的next指针指向b结点；
```

a在指向新节点后，a的next指针已经不再指向 b 了，而是指向 x ，此时 x 的 next 指针就会自己指向自己。

所以，我们在对链表进行操作的时候，一定要注意执行的先后顺序，应该先让 x 指向 b ，再让 a 指向 x。

对于 C 语言来说，由于内存是自己管理的，此时链表断裂，如果没有手动回收内存，就会发生内存泄漏。对于 Java 这种由 JVM 来管理的就不需要考虑这些。

### 3. 利用哨兵简化实现难度

如果我们要对链表插入一个结点，往往两行代码就可以搞定：

```c
new_node->next = cur->next;
cur->next = new_node;
```

但是，当链表为空的时候，对于头结点head来说就不合适了，我们需要进行特殊处理：

```c
if (head == null) {
  head = new_node;
}
```

再来看看删除操作：

```c
cur->next = cur->next->next;
```

但是，如果我们要删除最后一个结点tail，这时逻辑又不适用了：

```c
if(cur->next == null) {
    prev->next = null
}
```

从以上两段代码我们可以总结出，在编写链表相关的代码时，需要**对添加第一个结点、删除最后一个结点**进行特殊处理。这样代码会十分繁琐，也不简洁，这时候可以通过“哨兵”来解决。

“哨兵”的思想往往是用于**解决边界问题**，不直接参与逻辑业务。

在一个链表中，我们可以让头/尾结点head一直指向一个哨兵结点，这样一来，不管链表是不是为空，删除的是否为最后一个节点，永远不需要为头/尾结点做特殊处理。

这种有哨兵结点的链表叫**带头链表**。相反，没有哨兵结点的链表就叫作**不带头链表**。

![&#x54E8;&#x5175;&#x8282;&#x70B9;](https://static001.geekbang.org/resource/image/7d/c7/7d22d9428bdbba96bfe388fe1e3368c7.jpg)

接下来举一个使用“哨兵”的思想来解决问题的例子。

代码一：

```c
// 在数组a中，查找key，返回key所在的位置
// 其中，n表示数组a的长度
int find(char* a, int n, char key) {
  // 边界条件处理，如果a为空，或者n<=0，说明数组中没有数据，就不用while循环比较了
  if(a == null || n <= 0) {
    return -1;
  }

  int i = 0;
  // 这里有两个比较操作：i<n和a[i]==key.
  while (i < n) {
    if (a[i] == key) {
      return i;
    }
    ++i;
  }

  return -1;
}
```

代码二：

```c
// 在数组a中，查找key，返回key所在的位置
// 其中，n表示数组a的长度
// 我举2个例子，你可以拿例子走一下代码
// a = {4, 2, 3, 5, 9, 6}  n=6 key = 7
// a = {4, 2, 3, 5, 9, 6}  n=6 key = 6
int find(char* a, int n, char key) {
  if(a == null || n <= 0) {
    return -1;
  }

  // 这里因为要将a[n-1]的值替换成key，所以要特殊处理这个值
  if (a[n-1] == key) {
    return n-1;
  }

  // 把a[n-1]的值临时保存在变量tmp中，以便之后恢复。tmp=6。
  // 之所以这样做的目的是：希望find()代码不要改变a数组中的内容
  char tmp = a[n-1];
  // 把key的值放到a[n-1]中，此时a = {4, 2, 3, 5, 9, 7}
  a[n-1] = key;

  int i = 0;
  // while 循环比起代码一，少了i<n这个比较操作
  while (a[i] != key) {
    ++i;
  }

  // 恢复a[n-1]原来的值,此时a= {4, 2, 3, 5, 9, 6}
  a[n-1] = tmp;

  if (i == n-1) {
    // 如果i == n-1说明，在0...n-2之间都没有key，所以返回-1
    return -1;
  } else {
    // 否则，返回i，就是等于key值的元素的下标
    return i;
  }
}
```

对比上面两段代码，其中代码二使用了哨兵的思想，将数组`a[]`最后一个结点设为了哨兵，从而成功节省了代码一种`i < n`的比较，当`a[]`的长度有几十万，上百万的时候，这个性能上的优化节省的时间就比较明显了。

不过第二段代码可读性太差，除非是追求极致性能，不然一般也不会那么写。

### 4. 重点留意边界条件处理

**在日常编写代码完成后，一定要确认下边界条件是否考虑全面，确保代码在边界条件下能够正常执行**。

通常编写链表代码可以总结为以下几个边界条件：

* 如果链表为空时，代码是否能正常工作？
* 如果链表只包含一个结点时，代码是否能正常工作？
* 如果链表只包含两个结点时，代码是否能正常工作？
* 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？

在写任何代码时，也千万不要只是实现业务正常情况下的功能就好了，一定要多想想，你的代码在运行的时候，可能会遇到哪些边界情况或者异常情况。遇到了应该如何应对，这样写出来的代码才够健壮！

### 5. 举例画图，辅助思考

在编写链表代码的时候，我们也可以通过画图来释放脑容量，让更多的逻辑用于思考。

![](https://static001.geekbang.org/resource/image/4a/f8/4a701dd79b59427be654261805b349f8.jpg)

### 6. 多写多练，没有捷径

* 单链表反转
* 链表中环的检测
* 两个有序的链表合并
* 删除链表倒数第 n 个结点
* 求链表的中间结点
* 基于链表判断回文

如何判断一个字符串是否是回文字符串？

```scala
class SingleLinkedList() {
    var head:Node = _

    def this(elems: Array[String]) = {
        this()
        head = Node(elems.head,null)
        var tmp = head
        elems.tail.foreach { ele =>
            val newNode = Node(ele, null)
            tmp.next = newNode
            tmp = newNode
        }
    }

    def isBack(): Boolean = {

        var slow: Node = head
        var fast: Node = head
        var prev: Node = null

        while(null != fast && null != fast.next) {
            fast = fast.next.next
            val next = slow.next
            slow.next = prev
            prev = slow
            slow = next
        }
        // 针对列表元素为奇数的时候，slow需要往后再走一步，越过中点
        if(fast != null) {
            slow = slow.next
        }

        while(slow.next != null){
            if(prev.data != slow.data){
                // println(prev.data + "_" + slow.data)
                return false
            }
            prev = prev.next
            slow = slow.next
        }
        true
    }
    // 链表模型
    case class Node(data: String, var next: Node)
}

// 执行测试
val node = new SingleLinkedList(Array("a",  "b", "b", "a"))
println(node.isBack)
```

由于需要遍历一遍链表，因此时间复杂度为 $O\(n\)$ ，随着代码的执行，空间复杂度并无变化，仍为原来的大小，因此空间复杂度为 $O\(1\)$ 。

## 思考

写链表代码是**最考验逻辑思维能力的**。因为，链表代码到处都是指针的操作、边界条件的处理，稍有不慎就容易产生 Bug。链表代码写得好坏，可以看出一个人写代码是否够细心，考虑问题是否全面，思维是否缜密。所以，这也是很多面试官喜欢让人手写链表代码的原因。所以链表一定要自己写代码实现一下，才有效果。

