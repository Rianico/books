---
title: 06-di-gui
date: 2020-07-22 14:48:49
permalink: /pages/5a8205/
categories: 
  - Algorithm
  - 数据结构与算法（专栏学习）
tags: 
  - 
---
# 06 | 递归

**递归**是一种使用非常广泛的算法（或者说是编程技巧），许多算法实现都要使用到递归，如DFS 深度优先搜索、前中后序二叉树遍历等等。

编写递归需要满足三个条件：

1. 一个问题可以分解为几个子问题。
2. 每个子问题的解决思路都是一样的。
3. 存在递归终止条件。

递归最关键的一点就是**找出递推公式以及递归终止条件**,再将其转化为代码。

## 1. 递归代码示例

举个例子，假设有n个台阶，每次你可以跨 1 个台阶或者 2 个台阶，请问走这 n 个台阶有多少种走法？如果有 7 个台阶，你可以 2，2，2，1 这样子上去，也可以 1，2，1，1，2 这样子上去，总之走法有很多，那如何用编程求得总共有多少种走法呢？

首先，假设我们在第n个台阶，那么到达台阶的方法有$f\(n-1\)$以及$f\(n-2\)$,那么能得到该公式：$f\(n\)=f\(n-1\)+f\(n-2\)$。

接着我们再对最起始的台阶（终止条件）进行验证，如$f\(1\)$和$f\(2\)$。

由于$f\(1\)$只有一层台阶，因此只有一种走法，于是得到$f\(1\)=1$。

至于$f\(2\)$,若按照前面的公式可以得到$f\(2\)=f\(1\)+f\(0\)$，但很明显$f\(0\)$是不存在的，因此$f\(2\)$也应当作为终止条件，很明显$f\(2\)=2$。

有了上述几个公式，最终我们得到的公式如下：

$$
f(1) = 1\\
f(2) = 2\\
f(n) = f(n-1)+f(n-2)
$$

接下来转化为代码

```java
int f(n) {
    if (n == 1) return 1;
    if (n == 2) return 2;
    return f(n-1) + f(n-2);
}
```

**写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。**

## 2. 递归导致堆栈溢出

递归要警惕堆栈溢出，这是使用递归常会遇到的问题，递归若到达了一定深度，那么就会导致深度过深，从而导致对战溢出，

若我们将堆栈的大小改为1KB，再执行刚才的代码，那么当n为9999的时候，就会抛出如下异常：

```java
Exception in thread "main" java.lang.StackOverflowError
```

我们可以限制递归深度（比如增加个终止条件）来解决这个问题，但是只是治标不治本，因为一来不知道业务会要求到什么地步，二来允许递归的最大深度跟当前线程的剩余栈空间大小有关系，不好估算。

通常来说，其实所有递归代码都可以修改为非递归代码，比如我们将刚才的代码重写如下：

```java
int f(int n) {
  if (n == 1) return 1;
  if (n == 2) return 2;

  int ret = 0;
  int pre = 2;
  int prepre = 1;
  for (int i = 3; i <= n; ++i) {
    ret = pre + prepre;
    prepre = pre;
    pre = ret;
  }
  return ret;
}
```

但是这种思路实际上是将递归改为了“手动”递归，本质并没有变，而且也并没有解决前面讲到的某些问题，徒增了实现的复杂度。

在Scala中，还可以通过注解尾递归进行优化：

## 3. 递归要警惕重复计算

仍然是刚刚那么个递归代码的例子，若将其转化为图则如下：

![&#x9012;&#x5F52;-&#x91CD;&#x590D;&#x8BA1;&#x7B97;](https://static001.geekbang.org/resource/image/e7/bf/e7e778994e90265344f6ac9da39e01bf.jpg)

可以很直观的看到，若要计算$f\(5\)$,那么就要计算$f\(4\)$和$f\(3\)$，而$f\(4\)$也要计算一遍$f\(3\)$，这样一样就导致重复计算，浪费了计算资源。

这里我们可以通过空间换时间的方法，使用一个散列表来存储已经计算过的资源：

```java
public int f(int n) {
  if (n == 1) return 1;
  if (n == 2) return 2;

  // hasSolvedList可以理解成一个Map，key是n，value是f(n)
  if (hasSolvedList.containsKey(n)) {
    return hasSolvedList.get(n);
  }

  int ret = f(n-1) + f(n-2);
  hasSolvedList.put(n, ret);
  return ret;
}
```

递归存在着很多问题，当递归调用的函数数量较大时，就会积攒出一个可观的时间成本；并且由于每递归一次，就需要入栈并保存一次现场，空间复杂度上也为O\(n\)。

## 4. 思考

**Q**：我们平时调试代码喜欢使用 IDE 的单步跟踪功能，像规模比较大、递归层次很深的递归代码，几乎无法使用这种调试方式。对于递归代码，你有什么好的调试方法呢？

> 1.打印日志发现，递归值。 2.结合条件断点进行调试（idea的debug就有条件断点）。

