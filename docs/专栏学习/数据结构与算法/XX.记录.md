---
title: 记录
date: 2021-06-03
---

# 记录

## 1. 贪心算法

贪心算法的核心是追求局部最优，每个局部最优之间不会相互影响，多个局部最优叠加起来就是全局最优了。

实际操作中，绝大部分贪心算法都涉及到排序，但也并非绝对。

常见的贪心算法操作：

1. 先排序，再局部求解。
2. 先从一端遍历，再从末尾重新往前遍历迭代一次。

Leetcode：455、135、435、605、452、763、122、655

452 注意点：

1. 考虑多条件并集的时候，单个下标变量仅会存在一种情况，如头或尾，而不必拆分为多个 if/else。
2. 排序时指定的 Comparator 尽量不用加减法，避免溢出。

763 注意点：

1. 先对字符串信息做统计。
2. 如果统计对象是一个有限范围内的元素，那么可以考虑使用数组来代替 Map 做映射。

655 注意点：

1. 需要考虑初始状态，即临界条件。
2. 逻辑条件组合时，如果担心越界，往往 `||`、`&&` 的短路性质可以利用起来，将临界条件放前面，后面的如果能过去，自然就已经不需要考虑临界了。
3. 思考下最终结果的特征，然后局部去做运算，但要仔细思考，**局部最优解是否有多种**，如果有，则要思考下选择哪种局部最优解不会对全局造成影响。

## 2. 双指针

双指针常用于数组遍历，通常有以下特征：

1. 多个指针相同个方向前进，形成一个滑动窗口，常用于区间搜索。
2. 多个指针相互靠拢，这种往往是针对排好序的数组。

Leetcode：167、88、142、76、633、680

88 注意点：

1. 注意外部循环的终止条件，为 nums2 迁移完成

142 注意点：

1. 使用快慢两指针，设置交点之前的长度为 a，环 长度为 b。
2. 相遇时，f = 2s，同时 f = s + nb，因此 s = nb
3. 再根据 a + nb = 交点可得知，此时重置其中一个指针，交点 nb 继续前进直到相交，即可求得 a。

76 注意点：

1. 有限集合可以采用数组替代 Hash 集合。
2. 使用滑动窗口先求得结果
3. 尝试缩小窗口获取最优值，并记录最小集合长度

633 注意点：

1. 绝大部分双指针都可以转化为一个矩阵搜索。
2. 涉及到数字的计算，一定要注意是否会溢出。

680 注意点：

1. 要形成回文，可能删除左边也可能删除右边，因此只能将两边的情况各尝试一遍。

## 3. 二分查找

二分查找需要注意 **mid 是靠左还是靠右计算的**，通常 `mid = l + (r - l)/2` 都是偏向左端，在查找连续数字时左边跟右边是有区别的。

普通的二分查找则不需要注意该问题。

43、81

154：

1. 注意考虑重复数字的场景
2. 旋转数组本质上还是原来的二分查找，只不过结合重复数字场景下需要注意下起始点在哪一边，考虑进去决策。

540：

1. 不同对数的 mid 会存在奇偶上的不同
2. 因此比较稳妥的方法不是看取得对数的数字在左还是在右，而是根据奇偶，+1 或者 -1，如果所求数字在左边，，经过奇偶修改后的 mid 下标都是指向右边的。

## 4. 排序

掌握快排的手写方式还是必要的。

215：求第 k 大的元素，可以使用快排，逐渐缩小左右区间，一旦遇到左超过右，或者返回的区间点正好在 k -1 位（降序排序），则终止返回。

451：按照字符串里元素出现频率排序，可以先统计每个元素出现的频率（这里可以使用 int 数组，因为字符集有限），接着快排时以频率作为排序依据。

## 5. 深度优先

**深度优先搜索（depth-ﬁrst search，DFS）**在搜索到一个新的节点时，立即对该新节点进行遍历；因此遍历需要用先入后出的栈来实现，也可以通过与栈等价的递归来实现。对于树结构而言， 由于总是对新节点调用遍历，因此看起来是向着“深”的方向前进。

深度优先搜索也可以用来**检测环路**：记录每个遍历过的节点的父节点，若一个节点被再次遍 历且父节点不同，则说明有环。

深度优先搜索无非是上下左右四个方向进行递归判断，需要注意是否能够修改原始矩阵，必要时自行建立标记矩阵。

**回溯法**，在深度优先的基础上，在返回时逐步恢复现场，以避免影响其他搜索。

417:

1. 通过逆向思维，从边缘出发，建立两个标记用矩阵，记录各边所能到达的区域
2. 对两个标记用矩阵求重合的位置。

46、76：

1. 分别是对排列的深度搜索以及组合的深度搜索
2. 答案都是通过一个循环深度搜索每个组合的可能性，但在返回时恢复现场

### 6. 树

104，求树深度：

1. 递归，深度优先搜索

110，二叉树平衡判断：

1. 先求左右深度
2. 如果一旦发现两边深度差距大于 1，立刻返回，避免继续比较，浪费开销

543，求树的最长直径

1. 先求左右深度
2. 在求深度的过程中，不断求左右深度的和，用于更新 max

## 附录

### 快速排序

虽然绝大部分面试题都不需要写排序，但快排还是需要掌握的，并可以顺带解决其衍生题目。

使用左闭右闭方式：

```java
void quick_sort(int[] nums, int l, int r) {
	if (l >= r) return;
	int first = l, last = r - 1, key = nums[first];
	while (first < last) {
		while (first < last && nums[last] >= key) {
			last--;
		}
		nums[first] = nums[last];
		while (first < last && nums[first] <= key) {
			first++;
		}
		nums[last] = nums[first];
	}
	nums[first] = key;
	quick_sort(nums, l, first);
	quick_sort(nums, first + 1, r);
}
```

虽然只是简单的选择了区间第一个元素作为分割点，可能存在最坏选择，但巧妙地利用了 length 跟分割点需要 -1，简化编码，同时也减少了需要交换的次数。

另一种写法：

```java
void quick_sort(int[] nums, int l, int r) {
	if (l >= r) return;
	int slow = l, fast = l, key = nums[r];
	while (slow < r  && fast < r) {
		if (nums[fast] < key && nums[slow] > key) {
			int tmp = nums[fast];
			nums[fast] = nums[slow];
			nums[slow++] = tmp;
		}
		fast++;
		if (nums[slow] <= key) slow++;
	}
	nums[r] = nums[slow];
	nums[slow] = key;
	System.out.println(l + " : " + slow + " : " + r);
	quick_sort(nums, l, slow - 1);
	quick_sort(nums, slow + 1, r);
}
```

