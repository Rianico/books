---
title: 11-tiao-biao
date: 2020-07-22 14:48:49
permalink: /pages/62cbc8/
categories: 
  - Algorithm
  - 数据结构与算法（专栏学习）
tags: 
  - 
---
# 11 | 跳表

**跳表**（Skip list）：在基于链表的基础上，建立**多层索引**，从而快速定位查找元素，解决链表的查找操作时间复杂度为 O\(n\) 的问题，从而实现了链表上的“二分查找”。

## 1. 时间复杂度与空间复杂度

![&#x8DF3;&#x8868;-&#x4E8C;&#x5C42;&#x7D22;&#x5F15;](https://static001.geekbang.org/resource/image/49/65/492206afe5e2fef9f683c7cff83afa65.jpg)

![&#x8DF3;&#x8868;-&#x591A;&#x5C42;&#x7D22;&#x5F15;](https://static001.geekbang.org/resource/image/46/a9/46d283cd82c987153b3fe0c76dfba8a9.jpg)

上述是通过**每2个节点**就新建一个索引节点的方式来建立索引，第一级索引有 n/2 个节点，第二级索引为 n/4 个节点，假设有k层索引，到了最后就是 $n/2^k = 2$ 个节点。

从时间复杂度来看，当我们需要查找某个元素的时候，需要走过每层索引，根据前面的公式，那么索引的高度 $k=logn\_{2}n-1$ ，再加上每层都需要遍历 m 个节点，因此时间复杂度为 O\(mlogn\) 。

![](https://static001.geekbang.org/resource/image/d0/0c/d03bef9a64a0368e6a0d23ace8bd450c.jpg)

每2个节点创建索引的话，m 的值为 3 ，比如查找 x ，当索引到了 y 的时候，假设 x 大于 y，那么 x 还得和 z 进行比较，因此总共有 3 个节点（包含 y 和 z）。

从空间复杂度来看，就是将每层的索引节点相加，得到 n-2 个节点，因此空间复杂度为 O\(n\) 。

从空间复杂度来看，跳表的空间复杂度为 O\(n\) ，貌似占用内存较多，但是往往链表节点存储的对象都会大于索引节点，而且索引节点只是存储了一个指针，并不存储任何具体数据，因此与链表本身存储的内容对比起来，索引节点对内存的占用也并没有那么高。

## 2. 动态插入与删除

![&#x8DF3;&#x8868;-&#x63D2;&#x5165;](https://static001.geekbang.org/resource/image/65/6c/65379f0651bc3a7cfd13ab8694c4d26c.jpg)

如上图，当我们需要插入数据 6 的时候，只需要在 O\(logn\) 的时间复杂度下定位到链表的某范围内，即可实现高效的插入（删除同理）。

## 3. 索引动态更新

跳表的插入有个问题，当我们不停地插入同个数据的时候，可能导致某段索引之间的数据特别多，从而导致插入、删除操作退化为链表。

![&#x8DF3;&#x8868;-&#x9000;&#x5316;](https://static001.geekbang.org/resource/image/c8/c5/c863074c01c26538cf0134eaf8dc67c5.jpg)

**作为一种动态数据结构，我们需要一种手段来维护索引以及原始链表之间的平衡关系**。

也就是说，一旦某两个索引之间的数据多了，那么我们就要考虑在这两个索引节点之间再插入一个索引节点。我们在插入数据的时候，可以同时选择将这个数据插入某一层索引中。

我们通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第 K 级这 K 级索引中。

随机函数的选择很有讲究，从概率上来讲，能够保证跳表的索引大小和数据大小平衡性，不至于性能过度退化。

代码实现：

```scala

```

## 4. 思考

**Q：为什么 Redis 要用跳表来实现有序集合，而不是红黑树？**

Redis 中的有序集合支持的核心操作主要有下面这几个：

* 插入一个数据；
* 删除一个数据；
* 查找一个数据；
* **按照区间查找数据**（比如查找值在 \[100, 356\] 之间的数据）；
* 迭代输出有序序列。

其中前三点红黑树都可以实现，且时间复杂度也一样，但是按照区间来查找元素，红黑树不如跳表高效。并且，跳表更容易代码实现。

虽然跳表的实现也不简单，但比起红黑树来说还是好懂、好写多了，而简单就意味着可读性好，不容易出错。还有跳表更加灵活，它可以通过**改变索引构建策略**，有效平衡执行效率和内存消耗。

然而红黑树出现较早，大部分语言都有现成的实现，而跳表则往往需要自己实现一个，并且更新索引的随机函数也有很多讲究。

**Q：对于跳表的时间复杂度分析，前面分析了每两个结点提取一个结点作为索引的时间复杂度。如果每三个或者五个结点提取一个结点作为上级索引，对应的在跳表中查询数据的时间复杂度是多少呢？**

以每三个节点为例，假设链表有 n 个节点，索引高度共有 k 层，第一级索引为 n/3 个节点， 第二级索引为 n/9 个节点，以此类推，第 k 层则有 $n/3^k=3$ 个节点，由此得出 k 为 $log_{3}n-1=k$ ，每层索引遍历都需要比较 4 个节点，因此时间复杂度为 $4log_{3}n$ ，即 O\(logn\)。

