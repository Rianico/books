---
title: 02.数组
date: 2020-07-22
---
数组：是一个使用了**一片连续的内存空间**存储**同一类型**数据的**线性表**。除了数组，链表、队列、栈等也是线性表结构，其特点是**每个数据节点只有前跟后的访问方向**。

![&#x7EBF;&#x6027;&#x8868;](https://static001.geekbang.org/resource/image/b6/77/b6b71ec46935130dff5c4b62cf273477.jpg)

与线性表相对的则是**非线性表**，树、堆、图等都是非线性表，数据之间并不是简单的前后关系。

![&#x975E;&#x7EBF;&#x6027;&#x8868;](https://static001.geekbang.org/resource/image/6e/69/6ebf42641b5f98f912d36f6bf86f6569.jpg)

## 1. 如何实现随机访问？

比方我们有下面这样一个数组：

![&#x6570;&#x7EC4;](https://static001.geekbang.org/resource/image/98/c4/98df8e702b14096e7ee4a5141260cdc4.jpg)

其中左边为下标，右边可以当做内存地址，这个数组就是分配到了一块地址从1000到1039的内存块。

如果要访问下标为k的元素，那么只需要在起始内存地址（base\_address）的基础加上 k * 数据类型长度（data\_size）即可得到目标元素的地址（target\_address）：

$$
target\_address=base\_address+k*data\_size
$$

可以看出，数组随机访问（Random Access）的时间复杂度为 $O(1)$ 。

> NOTE：此处说的是随机访问，而不是查找，比如使用了二分查找，那么时间复杂度也就不是 $O(1)$ ，用词要严谨。

## 2. 低效的“插入”和“删除”

由于数组使用了一片连续的内存空间，若在执行删除/插入操作师还要保有数据的顺序性，此时性能会有下降。

以插入操作为例，因为需要把对应下标的位置腾给新元素，而下标及下标后面的每个元素都需要往后挪一位，该操作的平均时间复杂度为 $O(n)$ 。删除操作也是类似，涉及到了数组元素的位移。

若使用数组存储的是一段**顺序无关的数据**，对于插入操作，有一种取巧的方式可以提升效率。

假设我们需要在下标k的位置插入一个新的元素x，那么只需要将k上原来的元素放到队尾，x放入下标，这时插入操作的时间复杂度为 $O(1)$ ：

![&#x63D2;&#x5165;-&#x987A;&#x5E8F;&#x65E0;&#x5173;](https://static001.geekbang.org/resource/image/3f/dc/3f70b4ad9069ec568a2caaddc231b7dc.jpg)

对于删除操作，若需要删除多个元素，那么我们可以先将要删除的元素逐个做标记，最后再进行一次真正的删除，可以避免数据的多次移动，也可以提升性能：

![img](https://static001.geekbang.org/resource/image/b6/e5/b69b8c5dbf6248649ddab7d3e7cfd7e5.jpg)

> NOTE：这种方法有点像 JVM 中的 “标记-回收” 算法，在 GC 时，垃圾回收器会进行可达性分析，将不能连通到 GC ROOTS 的对象标记，最后再一并回收。
>
> 可以看出，不管是在软件开发还是架构设计中，总能找到某些算法和数据结构的影子。

## 3. 警惕数组的访问越界问题

再看下以下的C语言代码：

```c
int main(int argc, char* argv[]){
    int i = 0;
    int arr[3] = {0};
    for(; i<=3; i++){
        arr[i] = 0;
        printf("hello world\n");
    }
    return 0;
}
```

从 for 循环可以看出，上述代码中对数组的访问越界了，此时程序很可能会一直无限循环打印 "hello world" ，这是为什么呢？

代码执行的顺序其实就是不断地压栈出栈，在 Linux 内存布局中，栈是在高位，也就是说，i 对比数组 `arr[3]` 来说处于高位，一旦访问到了 `arr[3]` ，实际上访问到的内存块是属于 i 的，导致将 i 的值修改为 0 ，从而发生了无限循环。这种内存分配方式是**内存地址递减**的方式。

而在Java中，关于数组越界则交给了编译器来检查。

不管如何，在使用数组的时候，一定要警惕数组越界，因为会发生各种不可预测的行为。

## 4. 容器能否完全替代数组？

容器封装了大量的底层细节（比如 ArrayList 封装了数据插入、删除、自动扩容等操作），增加了易用性。但是使用容器也有以下几个注意点：

1. Java 中的 ArrayList 无法直接存储基本类型，需要转为 Integer、Long 等，涉及到了自动装/拆箱，会有一定的性能损失。
2. 如果事先知道要存储的数据量，而且设计的操作非常简单（比如只有读，追加操作），那么使用数组会更加高效。
3. 表示多维数组的时候，数组的表示形式会更加直观，比如`Object[][] array`，而用容器的话则需要这样定义：`ArrayList<ArrayList<object> > array`。

如果只是日常业务使用，则使用容器封装好的即可，但若涉及到底层、中间件的开发，则往往需要使用数组来实现一些高效的操作。

## 思考

Q：为什么数组的下标是从0开始的？

> A：这个要结合内存地址的模型来看，下标有一种更加准确的说法叫做**位移（offset）**，a\[0\] 则是偏移量为 0 的内存块，即为首地址，a\[k\] 则是代表偏移为 k 的内存地址，那么只需要计算 $base\_address+k*data\_size$ 即可，若使用 1 作为首地址的话， a\[k\] 的计算则是 $base\_address+(k-1)*data\_size$ ，这样一来，CPU 计算就会多一层指令，影响效率。

Q：二维数组的内存寻址公式是怎样的呢？

> A：以 `arr[m][n]` 为例，若要访问第 m 行的第 n 个元素（即最后一个元素），那么偏移量的就是 $base\_address+(m*n+n)*data\_size$ 。

