---
title: 03.Semaphore 信号量
date: 2021-03-14
---

Spmaphore 信号量对比起 Lock 和 Condition，能够**控制一个临界区内最大的并发数量**，且 Semaphore 中没有 Condition 的概念。

Semaphore 可以用于做流量限制，特别是在共有资源有限的应用场景，如数据库连接。

信号量的模型可以分为**一个计数器，一个等待队列，三个方法**：

![](https://static001.geekbang.org/resource/image/6d/5c/6dfeeb9180ff3e038478f2a7dccc9b5c.png)

Java 剩下的信号量模型中，等待队列对于用户来说是透明的，用户只需要关注计数器与三个方法：

- **init()**:初始化信号量时指定允许进入临界区的线程数(计数器)。

- **donw()**:线程成功获取信号量时计数器 - 1，如果线程申请锁时计数器小于 0，则将线程移入等待队列。

  **up()**:线程释放信号量，计数器 + 1。

以上三个方法都是原子性的，由信号量模型的实现方保证。

Java 中使用信号量实现一个限流器的代码示例：

```java
public class SemaphoreTest {

    private static final int THREAD_COUNT = 30;
    private static ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);
    private static Semaphore s = new Semaphore(10);

    public static void main(String[] args) {
        for (int i = 0; i < THREAD_COUNT; i++) {
            threadPool.execute(() -> {
                try {
                    s.acquire();
                    int waits = s.getQueueLength();
                    if (waits > 0) {
                        // 打印正在等待的线程数
                        System.out.println(waits);
                    }
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                } finally {
                    s.release();
                }
            });
        }
        threadPool.shutdown();
    }
    
}
```

在 Spark 中的 LiveListenerBus 中，还见到有将信号量设置为 0，通过先提交 event 并执行信号量的 release 方法来控制并发数的实现。