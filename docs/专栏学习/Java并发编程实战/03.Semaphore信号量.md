---
title: 03.Semaphore 信号量
date: 2021-03-14
---

## 1. Semaphore 信号量

Semaphore 信号量对比起 Lock 和 Condition，能够**控制一个临界区内最大的并发数量**，且 Semaphore 中没有 Condition 的概念。

Semaphore 可以用于做流量限制，特别是在共有资源有限的应用场景，如数据库连接。

信号量的模型可以分为**一个计数器，一个等待队列，三个方法**：

![](https://static001.geekbang.org/resource/image/6d/5c/6dfeeb9180ff3e038478f2a7dccc9b5c.png)

Java 剩下的信号量模型中，等待队列对于用户来说是透明的，用户只需要关注计数器与三个方法：

- **init()**:初始化信号量时指定允许进入临界区的线程数(计数器)。
- **donw()**:线程成功获取信号量时计数器 - 1，如果线程申请锁时计数器小于 0，则将线程移入等待队列。
- **up()**:线程释放信号量，计数器 + 1。

以上三个方法都是原子性的，由信号量模型的实现方保证。

## 2. 实践

### 2.1 Java 实现限流器

Java 中使用信号量实现一个限流器的代码示例：

```java
public class SemaphoreTest {

    private static final int THREAD_COUNT = 30;
    private static ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);
    private static Semaphore s = new Semaphore(10);

    public static void main(String[] args) {
        for (int i = 0; i < THREAD_COUNT; i++) {
            threadPool.execute(() -> {
                try {
                    s.acquire();
                    int waits = s.getQueueLength();
                    if (waits > 0) {
                        // 打印正在等待的线程数
                        System.out.println(waits);
                    }
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                } finally {
                    s.release();
                }
            });
        }
        threadPool.shutdown();
    }
    
}
```

### 2.2 Spark 事件总线

在 Spark 中的 LiveListenerBus 中，还见到有将信号量设置为 0，通过先提交 event 并执行信号量的 release() 方法来控制并发数的实现。

### 2.3 利用信号量进行排序

通过建立多个初始信号不同的信号量，实现排序：

```java
import java.util.concurrent.Semaphore;

public class FooBar4 {

    private int n;

    public FooBar4(int n) {
        this.n = n;
    }

    Semaphore fooSem = new Semaphore(1);
    Semaphore barSem = new Semaphore(0);

    public void foo(Runnable printFoo) throws InterruptedException {
        for (int i = 0; i < n; i++) {
            fooSem.acquire();
            // printFoo.run() outputs "foo". Do not change or remove this line.
            printFoo.run();
            barSem.release();


        }
    }

    public void bar(Runnable printBar) throws InterruptedException {
        for (int i = 0; i < n; i++) {
            barSem.acquire();
            // printBar.run() outputs "bar". Do not change or remove this line.
            printBar.run();
            fooSem.release();
        }

    }
}

```

测试代码：

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Test {

    public static void main(String[] args) {
        final ExecutorService executors = Executors.newFixedThreadPool(2);
        Runnable r1 = () -> System.out.print("foo");
        Runnable r2 = () -> System.out.println("bar");
        FooBar4 foobar = new FooBar4(3);
        executors.execute(() -> {
            try {
                foobar.bar(r2);
            } catch (Exception e) {
            }
        });
        executors.execute(() -> {
            try {
                foobar.foo(r1);
            } catch (Exception e) {
            }
        });
        executors.shutdown();
    }
}
```

