---
title: 12. 并发常见问题
date: 2021-03-28
---

### 1. while(true)

注意退出条件，以及 “活锁” 问题。

使用原子类时，需要注意复合操作，以及原子类赋值位置，否则也可能变为一个 while(true) 死循环：

```java
public class SafeWM {
  class WMRange{
    final int upper;
    final int lower;
    WMRange(int upper,int lower){
    //省略构造函数实现
    }
  }
  final AtomicReference<WMRange>
    rf = new AtomicReference<>(
      new WMRange(0,0)
    );
  // 设置库存上限
  void setUpper(int v){
    WMRange nr;
    WMRange or;
    //原代码在这里
    //WMRange or=rf.get();
    do{
      //移动到此处
      //每个回合都需要重新获取旧值
      or = rf.get();
      // 检查参数合法性
      if(v < or.lower){
        throw new IllegalArgumentException();
      }
      nr = new
        WMRange(v, or.lower);
    }while(!rf.compareAndSet(or, nr));
  }
}
```

### 2. signalAll()

signal() 有时候会导致某些线程再也无法唤醒，虽然不至于说是错误，但用 signalAll() 会更加保险，保证工程的稳定性：

```java
// RPC结果返回时调用该方法   
private void doReceived(Response res) {
  lock.lock();
  try {
    response = res;
    done.signalAll();
  } finally {
    lock.unlock();
  }
}
```

### 3. Semaphore 内需要注意锁

Semaphore 临界区内允许有多个线程进入，因此仍需要注意共享问题。

### 4. CyclicBarrier 注意执行回调方法的线程

CyclicBarrier 执行回调方法时，回调方法可能是同步阻塞的，默认交给将计数器减为 0 的那个线程。如果不交给其他线程池执行，可能无法达到提升性能的作用。

**无论是在任何场景，一旦涉及到回调，都需要注意执行回调方法的线程归属**。

### 5. 如何优雅的终止线程

1. 检测中断，并恢复中断位。
2. 自定义维护一个中断标志。

以上两者通常是一起使用的，当前业界较为成熟的做法为**两阶段终止模式** ，将中止过程拆分为两个阶段，第一个阶段主要是线程 T1 向线程 T2 发送中断指令，第二阶段为线程 T2 响应中断指令。

![](https://static001.geekbang.org/resource/image/a5/5c/a5ea3cb2106f11ef065702f34703645c.png)

这套方案中，检测中断是由线程生命周期的状态变化得到的，线程要进入终止状态，需要先恢复为 RUNNABLE 状态，因此可以通过抛出 InterruptException 来进入 RUNNABLE 状态，同时重新标记中断位（良好规范）。

由于线程中可能调用了第三方库，第三方库是否能够正确应对线程中断状态是无法保证的，因此也需要我们手工维护一个中断标志，

```java
class Proxy {
  //线程终止标志位
  volatile boolean terminated = false;
  boolean started = false;
  //采集线程
  Thread rptThread;
  //启动采集功能
  synchronized void start(){
    //不允许同时启动多个采集线程
    if (started) {
      return;
    }
    started = true;
    terminated = false;
    rptThread = new Thread(()->{
      while (!terminated){
        //省略采集、回传实现
        report();
        //每隔两秒钟采集、回传一次数据
        try {
          Thread.sleep(2000);
        } catch (InterruptedException e){
          //重新设置线程中断状态
          Thread.currentThread().interrupt();
        }
      }
      //执行到此处说明线程马上终止
      started = false;
    });
    rptThread.start();
  }
  //终止采集功能
  synchronized void stop(){
    //设置中断标志位
    terminated = true;
    //中断线程rptThread
    rptThread.interrupt();
  }
}
```

### 6. 如何优雅的关闭线程池

线程池的关闭可以分为 `shutdown()` 和 `shutdownNow()`：

- **shutdown()**：线程池拒绝接受新的任务，并会继续等待直到任务队列中的任务都执行完后才关闭线程池。
- **shutdownNow()**：会中断正在执行的任务，同时任务队列中的任务也不在运行，但可以将这些任务作为一个数组返回。