---
title: 04.ReadWriteLock 与 StampedLock
date: 2021-03-14
---

## 1. Java SDK 包里的其他工具

Java SDK 包除了提供 Lock 与 Condition 实现管程之外，还提供了其他许多的工具类，本质上是为了能够在不同场景需求下按需优化，提高并发性能。

## 2. ReadWriteLock

读写锁是一个广为通用的技术，规定了以下三条基本原则：

1. 允许多个线程同时读共享变量；
2. 只允许一个线程写共享变量；
3. 如果一个写线程正在执行写操作，此时禁止读线程读共享变量。

读写锁允许多个线程同时读取一个共享变量，在读多写少的场景下性能比互斥锁更优。

```java
class Cache<K,V> {
  final Map<K, V> m =
    new HashMap<>();
  final ReadWriteLock rwl = 
    new ReentrantReadWriteLock();
  final Lock r = rwl.readLock();
  final Lock w = rwl.writeLock();
 
  V get(K key) {
    V v = null;
    //读缓存
    r.lock();         ①
    try {
      v = m.get(key); ②
    } finally{
      r.unlock();     ③
    }
    //缓存中存在，返回
    if(v != null) {   ④
      return v;
    }  
    //缓存中不存在，查询数据库
    w.lock();         ⑤
    try {
      //再次验证
      //其他线程可能已经查询过数据库
      v = m.get(key); ⑥
      if(v == null){  ⑦
        //查询数据库
        v=省略代码无数
        m.put(key, v);
      }
    } finally{
      w.unlock();
    }
    return v; 
  }
}
```

读写锁中，**读锁不可以升级为写锁，写锁可以降级为读锁**：

- 如果在读锁解锁之前使用了写锁，那么会导致写锁阻塞，同时读锁中其他线程也执行不下去了。
- 在写锁解锁之前可以使用读锁，这样可以保证使用写锁的线程不用重新竞争获取读锁资源。

读写锁同样支持公平与非公平模式，但只有写锁有 Condition，读锁没有该对象。

ReentrantReadWriteLock 使用了一个 volatile int 状态变量维护了读写两种，高 16 位维护读状态，低 16 位维护写状态，通过按位与计算来快速获取响应的读写锁状态。

如果一个线程尝试获取写锁，发现状态变量不为 0 ，且写锁状态为 0 或者独占的线程不等于当前线程，则会进入等待队列：

```java
        protected final boolean tryAcquire(int acquires) {
            /*
             * Walkthrough:
             * 1. If read count nonzero or write count nonzero
             *    and owner is a different thread, fail.
             * 2. If count would saturate, fail. (This can only
             *    happen if count is already nonzero.)
             * 3. Otherwise, this thread is eligible for lock if
             *    it is either a reentrant acquire or
             *    queue policy allows it. If so, update state
             *    and set owner.
             */
            Thread current = Thread.currentThread();
            int c = getState();
            int w = exclusiveCount(c);
            if (c != 0) {
                // (Note: if c != 0 and w == 0 then shared count != 0)
                if (w == 0 || current != getExclusiveOwnerThread())
                    return false;
                if (w + exclusiveCount(acquires) > MAX_COUNT)
                    throw new Error("Maximum lock count exceeded");
                // Reentrant acquire
                setState(c + acquires);
                return true;
            }
            if (writerShouldBlock() ||
                !compareAndSetState(c, c + acquires))
                return false;
            setExclusiveOwnerThread(current);
            return true;
        }
```

> NOTE：从这段代码也可以看出，在读锁释放之前使用写锁的话，会导致写锁阻塞。

**Q：写锁中获取读锁是否有必要？**

是有必要的，本质上是为了可见性(业务层面），如果线程 A 直接释放写锁，之后如果有线程 B 也会获取写锁修改变量，那么这时线程 A 获取读锁读到的变量，可能就是线程 B 做的修改了，可能导致业务上出现问题。

不支持读锁升级也是为了可见性，如果支持了锁升级，即使线程 A 获取写锁修改了变量，已经获取读锁的 B 阻塞在写锁外，线程 B 也是看不到线程 A 做出的修改的（因为没有重新读取一次 volatile 状态变量，即请求锁）

## 3. StampedLock

StampedLock 相比 ReentrantReadWriteLock，主要是通过增加了乐观读的模式来提升性能。

StampedLock 有三种模式：**悲观读锁**、**写锁**以及**乐观读**。

StampedLock 用法如下：

```java
final StampedLock sl = 
  new StampedLock();
// 尝试乐观读，并验证期间是否有写操作
long stamp = sl.tryOptimisticRead();
...
sl.validate(stamp)
    
// 获取/释放悲观读锁示意代码
long stamp = sl.readLock();
try {
  //省略业务相关代码
} finally {
  sl.unlockRead(stamp);
}

// 获取/释放写锁示意代码
long stamp = sl.writeLock();
try {
  //省略业务相关代码
} finally {
  sl.unlockWrite(stamp);
}
```

在加锁后，都会返回一个 long 类型的版本号，解锁的时候需要传递进去。

乐观读是一种无锁实现，在乐观读之后，会检测一下期间是否发生了写操作，如果有，则再升级为悲观读锁，获取最新数据。

StampedLock 读模板：

```java
final StampedLock sl = new StampedLock();

// 乐观读
long stamp = sl.tryOptimisticRead();
// 读入方法局部变量
......
// 校验stamp
if (!sl.validate(stamp)){
  // 升级为悲观读锁
  stamp = sl.readLock();
  try {
    // 读入方法局部变量
    .....
  } finally {
    //释放悲观读锁
    sl.unlockRead(stamp);
  }
}
```

StampedLock 写模板：

```java
long stamp = sl.writeLock();
try {
  // 写共享变量
  ......
} finally {
  sl.unlockWrite(stamp);
}
```

相比起 ReentrantReadWriteLock，StampedLock 在读远远大于写操作的场景下性能更加优秀，但是用的时候需要注意以下事项：

- StampedLock 的功能仅仅是 ReentrantReadWriteLock 的子集
- StampedLock 不支持重入
- StampedLock 不支持 Condition
- StampedLock 阻塞在 readLock() 或者 writeLock() 上时，如果调用 interrupt() 会导致线程所在 CPU 飙升，需要中断功能应使用 readLockInterruptibly() 和写锁 writeLockInterruptibly()
- StampedLock 支持锁升级降级（如有必要会自动释放版本号对应锁），但是要记得将升级后的版本号也进行释放

> NOTE：锁的升级常用于 if-then-update 的场景：即先读，如果读的数据满足条件，就返回，如果读的数据不满足条件，再尝试写。

StampedLock 在写锁阻塞后，如果阻塞在获取读锁，并尝试中断线程时，由于 StampedLock 内部设计问题，在线程处于中断状态下，不会使用 LockSupport.park() 进行等待，而是无限循环，从而占满了 CPU。

> NOTE：线程的中断状态本质上是一种写作状态，例如，当线程被中断抛出 interruptException 时，会将中断状态清除，这时如果不在调用一次中断，那么在 “上层” 代码获取线程的中断状态时，又会发现没有中断状态。