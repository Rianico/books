---
title: 11. Fork/Join
date: 2021-03-27
---

## Fork-Join

对于简单的并行任务，可以通过 **线程池 + Future** 的方案来解决；如果任务之间有聚合关系，无论是 AND 聚合还是 OR 聚合，都可以通过 **CompletableFuture** 来解决；而批量的并行任务，则可以通过 **CompletionService** 来解决。

上面三种方式基本可以覆盖**简单并行、聚合、批量并行**三总任务模型，但还缺少了一种场景：**分治**。

分治：把一个复杂的问题分解成多个相似的子问题，然后再把子问题分解成更小的子问题，直到子问题简单到可以直接求解。

![](https://static001.geekbang.org/resource/image/d2/6a/d2649d8db8e5642703aa5563d76eb86a.png)

分治思想在很多领域都有广泛的应用，例如算法领域有分治算法（归并排序、快速排序都属于分治算法，二分法查找也是一种分治算法）；大数据领域知名的计算框架 MapReduce 背后的思想也是分治。

Fork/Join 本身的目的是为了提高 CPU 利用率，因此对于计算密集型的任务更为有效，而 **I/O 密集型则需要酌情考虑，避免出现线程饥饿的现象**。

Fork/Join 框架中，Fork 对应任务的拆解，Join 对应结果的合并。

Fork/Join 框架主要包含两部分：

- 分治任务的线程池 ForkJoinPool
- 分治任务 ForkJoinTask，有两个实现：
  - RecursiveAction，无返回值
  - RecursiveTask 有返回值

ForkJoinPool 内部有多个（双端）任务队列（取决于指定的并行度），当调用其 invoke() 或者 submit() 方法时，ForkJoinPool 会根据一定的路由规则把任务提交到一个任务队列中。任务执行过程中如果创建出了子任务，则会将子任务提交到工作线程对应的任务队列里。

**任务窃取**：如果某个工作线程对应的任务队列空了，那么允许其线程从其他队列获取任务。

Fork/Join 框架使用时，需要注意 `fork()`、`join()` 方法的使用顺序，当某个工作线程调用 fork() 方法后，其不再执行任务，而是将任务分配给其他的工作线程。

为了避免浪费现成资源，通常会保留一个任务**在前面**继续执行 `compute()` 一直分发任务，其他任务则在后面阻塞等待线程执行返回结果，可以直接调用 `invokeAll()` 方法实现。

```java
    public static void main(String[] args) {
        //创建分治任务线程池
        ForkJoinPool fjp = new ForkJoinPool(16);
        //创建分治任务
        Fibonacci fib = new Fibonacci(6);
        final long start = System.nanoTime();
        //启动分治任务
        Integer result = fjp.invoke(fib);
        //输出结果
        System.out.println(result);
        System.out.println(fjp.getPoolSize());
        System.out.println((System.nanoTime() - start) / 1_000 / 1_000);
    }

    //递归任务
    static class Fibonacci extends RecursiveTask<Integer> {
        final int n;

        Fibonacci(int n) {
            this.n = n;
        }

        @Override
        protected Integer compute() {
            if (n <= 1) {
                return n;
            }
            System.out.println(Thread.currentThread().getName());
            try {
                TimeUnit.MILLISECONDS.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            Fibonacci f1 = new Fibonacci(n - 1);
            Fibonacci f2 = new Fibonacci(n - 2);
            //创建子任务
            invokeAll(f1, f2);
            //等待子任务结果，并合并结果
            return  f2.compute() + f1.join();
        }
    }
```

