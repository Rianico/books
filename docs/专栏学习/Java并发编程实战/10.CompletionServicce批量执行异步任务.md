---
title: 10.CompletionServicce 批量执行异步任务
date: 2021-03-27
---

## 1. 多个异步任务遇到的问题

当需要执行多个异步任务的时候，最大的问题就是返回的 future 属于同步阻塞，如果耗时长的 future 在前面，那么会导致后面耗时短的 future 浪费一部分时间在等待上。

通常可以通过借助阻塞队列来对结果进行一个排序：

```java
// 创建阻塞队列
BlockingQueue<Integer> bq = new LinkedBlockingQueue<>();
//电商S1报价异步进入阻塞队列  
executor.execute(() -> bq.put(f1.get()));
//电商S2报价异步进入阻塞队列  
executor.execute(() -> bq.put(f2.get()));
//电商S3报价异步进入阻塞队列  
executor.execute(() -> bq.put(f3.get()));
//异步保存所有报价  
for (int i=0; i<3; i++) {
  Integer r = bq.take();
  executor.execute(()->save(r));
}  
```

实际上，Java 为上述问题提供了更加优雅的解决方案：CompletionService。

## 2. CompletionService

CompletionService 的实现原理也是内部维护了一个阻塞队列，当任务执行结束就把任务的 future 加入到阻塞队列中.

CompletionService 的实现类为 ExecutorCompletionService ，需要自己传入一个线程池，并可以选择是否传入自己的阻塞队列，否则使用默认的无界阻塞队列：

```java
ExecutorCompletionService(Executor executor)
ExecutorCompletionService(Executor executor, BlockingQueue completionQueue)。
```

CompletionService 可以很方便的等待多个 future 的结果，提供了以下 5 个方法：

```java
Future<V> submit(Callable<V> task);
Future<V> submit(Runnable task, V result);
Future<V> take() throws InterruptedException;
Future<V> poll();
Future<V> poll(long timeout, TimeUnit unit) throws InterruptedException;
```

其中 take 与 poll 的区别为 take() 方法的线程会被阻塞，而 poll() 则是返回一个 null。

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
    ExecutorService executor = Executors
        .newFixedThreadPool(
        10,
        new ThreadFactoryBuilder().setNameFormat("zxk-%d").build()
    );
    CompletionService completionService = new ExecutorCompletionService<String>(executor);
    completionService.submit(() -> "1");
    completionService.submit(() -> "2");
    completionService.submit(() -> "3");
    for (int i = 0; i < 3; i++) {
        System.out.println(completionService.take().get());
    }
    executor.shutdown();
}
```

CompletionService 可以轻松地实现 `Forking Cluster` （N 选 1 场景）的需求，完成后续处理的有序性，避免无谓的等待。

**CompletionService 具体实现**：将传进来的任务封装成一个包装类，包装类 `QueueingFuture` 实现了 FutureTask 接口，并重写了 `done()` 方法。当任务完成时，会调用 `done()` 方法，将结果放入 CompletionService 维护的阻塞队列里。

## 3. 实践

以 [jdk8之CompletableFuture与CompletionService](https://www.cnblogs.com/zhjh256/p/11829397.html) 这篇文章的例子为例：

```java
    // 传统的 future
    public static void testFuture() throws InterruptedException, ExecutionException {
        long beg = System.currentTimeMillis();
        System.out.println("testFuture()开始执行：" + beg);
        ExecutorService executor = Executors.newCachedThreadPool();
        List<Future<String>> result = new ArrayList<Future<String>>();
        for (int i = 5; i > 0; i--) {
            Future<String> submit = executor.submit(new Task(i));
            result.add(submit);
        }
        executor.shutdown();
        for (int i = 0; i < 5; i++) {
            Thread.sleep(500);
            System.out.println("线程" + i + "执行完成:" + result.get(i).get());
        }
        System.out.println("testFuture()执行完成:" + System.currentTimeMillis() + "," + (System.currentTimeMillis() - beg));
    }
```

上述这段代码，一共需要花费 2.5s + 0.5s + 0.5s + 0.5s + 0.5s = 4.5s，如果第一个 future 恰好是最耗时的任务，同时**后续的操作时延较大**，就会出现无谓的等待耗时。

```java
    // 使用 completionService
    private static void testCompletionService() throws InterruptedException, ExecutionException {
        long beg = System.currentTimeMillis();
        System.out.println("testFuture()开始执行：" + beg);
        ExecutorService executor = Executors.newCachedThreadPool();
        ExecutorCompletionService<String> completionService = new ExecutorCompletionService<>(executor);
        for (int i = 5; i > 0; i--) {
            completionService.submit(new Task(i));
        }
        executor.shutdown();
        for (int i = 0; i < 5; i++) {
            Thread.sleep(500);
            Future<String> future = completionService.take();
            System.out.println("线程" + i + "执行完成:" + future.get());
        }
        System.out.println("testCompletionService()执行完成:" + System.currentTimeMillis() + "," + (System.currentTimeMillis() - beg));
    }
```

总结：从上述例子来看，在批量提交异步任务的时候，如果在**获取异步结果后还需要进行一些耗时较久的操作**，则 CompletionService 可以轻松实现最优的等待及处理顺序，减少不必要的等待。