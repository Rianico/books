---
title: 08. 线程池
date: 2021-03-21
---



线程的新建涉及到了内核系统的一系列资源分配操作，属于重量及操作，因此频繁的线程创建、销毁操作会有性能问题。

线程池采用了池化的思想，对线程进行了复用，同时按照生产-消费者模式，实现了任务提交、执行的操作。

Java 的线程池实现为 ThreadPoolExecutor：

```java
ThreadPoolExecutor(
  int corePoolSize,
  int maximumPoolSize,
  long keepAliveTime,
  TimeUnit unit,
  BlockingQueue<Runnable> workQueue,
  ThreadFactory threadFactory,
  RejectedExecutionHandler handler) 
```

各参数含义如下：

- **corePoolSize**：表示线程池保有的最小线程数。
- **maximumPoolSize**：表示线程池创建的最大线程数。
- **keepAliveTime & unit**：一个线程如果在一段时间内，都没有执行任务，空闲了keepAliveTime & unit 指定的时间，而且线程池的线程数大于 corePoolSize ，那么这个空闲的线程就要被回收了。
- **workQueue**：工作队列，用于存储提交的任务。
- **threadFactory**：定义如何创建线程，如名字等。
- **handler**：通过这个参数你可以自定义任务的拒绝策略。如果线程池中所有的线程都在忙碌，并且工作队列也满了（前提是工作队列是有界队列），那么此时提交任务，线程池就会拒绝接收。ThreadPoolExecutor 提供了以下 4 种策略：
  - **CallerRunsPolicy**：提交任务的线程自己去执行该任务。
  - **AbortPolicy**：默认的拒绝策略，会 throws RejectedExecutionException。
  - **DiscardPolicy**：直接丢弃任务，没有任何异常抛出。
  - **DiscardOldestPolicy**：丢弃最老的任务，其实就是把最早进入工作队列的任务丢弃，然后把新任务加入到工作队列。

当外界提交的任务数超过 corePoolSize 时，会根据工作队列是否能够插入任务节点，来决定是先保存任务到队列，还是直接新建线程，这里取决于工作队列的具体实现。Java 通常是先保存到队列中。

线程池会通过 `addWorker(...)` 方新增一个线程到线程队列中，然后循环消费任务队列，执行队列中的任务。

使用线程池的几个注意事项：

1. **使用有界队列**。

2. **拒绝策略慎用**，线程池默认拒绝策略会抛出 RejectedExecutionException 运行时异常，而编译器没有强制捕获这个异常，容易忽略。如果线程池任务十分重要，通常建议自定义拒绝策略。自定义拒绝策略往往配个服务降级使用。

3. 线程池的线程执行任务时**如果发生了运行时异常，会导致线程终止**，此时异常如果处理不当会导致预期之外的问题：

   - 如果使用 execute() 方法执行，则会打印出异常信息，并销毁线程重新创建一个。
   - 如果使用 submit() 方法执行，则直到调用 `Future.get()` 方法的时候才会获取到异常。
   - 通常解决方案为在提交的任务中预先捕获并处理响应的异常（推荐，不会销毁线程），或者在 ThreadFactory 中指定线程的异常处理器（仍会销毁线程并重建）。
   
   ```java
   public class InterruptTest1 {
   
       public static void main(String[] args) throws InterruptedException {
           final LongAdder longAdder = new LongAdder();
        final ThreadPoolExecutor pool = new ThreadPoolExecutor(
                   1,
                   4,
                   10,
                   TimeUnit.HOURS,
                   new LinkedBlockingDeque<>(10),
                   r -> {
                       longAdder.increment();
                       final Thread thread = Executors.defaultThreadFactory().newThread(r);
                       thread.setName("zxk-" + longAdder.intValue());
   /*                    thread.setUncaughtExceptionHandler(
                               (t1, e) -> System.err.println(e.getMessage())
                       );*/
                       return thread;
                   }
           );
           pool.execute(() -> {
               System.out.println(Thread.currentThread().getName());
               throw new RuntimeException("RuntimeException");
           });
           System.out.println("end...");
           System.out.println(pool.getActiveCount());
           System.out.println(pool.getPoolSize());
           pool.execute(() -> {
               System.out.println(Thread.currentThread().getName());
               try {
                   throw new RuntimeException("RuntimeException");
               } catch (RuntimeException e) {
                   e.printStackTrace();
               }
           });
           pool.execute(() -> {
               System.out.println(Thread.currentThread().getName());
           });
           pool.shutdown();
   
       }
   
   }
   ```

线程池 + CountDownLatch 实例：

```java
public class InterruptTest1 {

    public static void main(String[] args) throws InterruptedException {
        final LongAdder longAdder = new LongAdder();
        final ThreadPoolExecutor pool = new ThreadPoolExecutor(
                2,
                4,
                10,
                TimeUnit.HOURS,
                new LinkedBlockingDeque<>(10),
                r -> {
                    longAdder.increment();
                    final Thread thread = Executors.defaultThreadFactory().newThread(r);
                    thread.setName("zxk-" + longAdder.intValue());
                    return thread;
                }
        );
        CountDownLatch countDownLatch = new CountDownLatch(3);
        pool.execute(() -> {
            System.out.println(Thread.currentThread().getName());
            countDownLatch.countDown();
        });
        pool.execute(() -> {
            System.out.println(Thread.currentThread().getName());
            countDownLatch.countDown();
        });
        pool.execute(() -> {
            System.out.println(Thread.currentThread().getName());
            countDownLatch.countDown();
        });
        countDownLatch.await();
        System.out.println("end...");
        // 记得关闭线程池，Hive 有处 bug 就是因为没有关闭线程池导致线程数一直增加
        pool.shutdown();

    }

}
```

