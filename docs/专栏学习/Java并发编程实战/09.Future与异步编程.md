---
title: 09. Future 与异步编程
date: 2021-03-25
---

## 1. Future 接口

线程池提供了 3 个 `submit(...)` 方法和 1 个 FutureTask 工具类来实现获取任务运行结果：

```java
// 提交Runnable任务
Future<?> submit(Runnable task);
// 提交Callable任务
<T> Future<T> submit(Callable<T> task);
// 提交Runnable任务及结果引用  
<T> Future<T> submit(Runnable task, T result);
```

Future 接口有 5 个方法：

- **cancel()**：取消任务
- **isCancelled()**：判断任务是否已取消
- **isDone()**：判断任务是否已完成
- **get() & get(timeout, unit)**：获取任务运行结果

Future 的 `get()` 方法是阻塞的，直到任务完成才会被唤醒。

FutureTask 实现了 Runnable 和 Future 接口，同时拥有两者的性质，提供了两个构造函数：

```java
FutureTask(Callable<V> callable);
// 返回传递进去的 result，可以主线程与子线程之间的数据共享
FutureTask(Runnable runnable, V result);
```

使用 FutureTask 实现案例：

```java
public class FutureTest {

    static class Task1 implements Callable<String> {
        FutureTask t;

        public Task1(FutureTask t) {
            this.t = t;
        }

        @Override
        public String call() throws Exception {
            System.out.println("洗茶壶");
            TimeUnit.SECONDS.sleep(1);
            System.out.println("煮水");
            TimeUnit.SECONDS.sleep(1);
            System.out.println("拿到茶叶");
            return "上茶：" + this.t.get();
        }
    }

    static class Task2 implements Callable<String> {
        @Override
        public String call() throws Exception {
            System.out.println("洗杯子");
            TimeUnit.SECONDS.sleep(1);
            return "龙井";
        }
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        final FutureTask<String> future2 = new FutureTask<>(new Task2());
        new Thread(future2).start();
        final FutureTask<String> future1 = new FutureTask<>(new Task1(future2));
        new Thread(future1).start();
        System.out.println(future1.get());
    }

}
```

## 2. 异步编程 CompletableFuture

从 JDK8 开始，Java 提供了一个异步编程的框架：**CompletableFuture**，可以专注于业务而不需要过多的注意异步编程实现，其及继承关系如下：

![](https://gitee.com/zhxuankun/Image/raw/master/Avator/20210327171514.png)

CompletableFuture 可以试用以下 4 个静态方法构造对象：

```java
//使用默认线程池
static CompletableFuture<Void> runAsync(Runnable runnable)
static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier)
//可以指定线程池  
static CompletableFuture<Void> runAsync(Runnable runnable, Executor executor)
static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier, Executor executor)  
```

默认情况下 CompletableFuture 会使用公共的 ForkJoinPool 线程池，这个线程池默认创建的线程数是 CPU 的核数（也可以通过 JVM option:`-Djava.util.concurrent.ForkJoinPool.common.parallelism` 来设置 ForkJoinPool 线程池的线程数）。

> NOTE：为了避免不同业务之间的相互影响，最好不同业务指定不同的线程池。

CompletableFuture 实现了 CompletionStage 接口，CompletionStage 用于描述任务的各种关系：

![串行](https://static001.geekbang.org/resource/image/e1/9f/e18181998b82718da811ce5807f0ad9f.png)

![并行](https://static001.geekbang.org/resource/image/ea/d2/ea8e1a41a02b0104b421c58b25343bd2.png)

![汇聚](https://static001.geekbang.org/resource/image/3f/3b/3f1a5421333dd6d5c278ffd5299dc33b.png)

### 2.1 描述串行关系

描述串行关系的 API：

- **thenApply**：`Function<T,R>`,接受 T 类型的参数并返回 R 类型的 `CompletionStage<R>`。
- **thenCompose**：同 thenApply，但会创建一个子流程。
- **thenAccept**：`Consumer<T>`，接收 T 类型的参数，返回 `CompletionStage<Void>`。
- **thenRun**：`Runnable`，不接收参数，返回 `CompletionStage<Void>`。

上述这些方法若带了 Async 后缀则表示异步执行，交由其他线程池执行，若不指定线程池则默认交给 JVM 自带的 Fork-Join 线程池：

```java
CompletionStage<R> thenApply(fn);
CompletionStage<R> thenApplyAsync(fn);
CompletionStage<Void> thenAccept(consumer);
CompletionStage<Void> thenAcceptAsync(consumer);
CompletionStage<Void> thenRun(action);
CompletionStage<Void> thenRunAsync(action);
CompletionStage<R> thenCompose(fn);
CompletionStage<R> thenComposeAsync(fn);
```

### 2.2 描述 And 并行汇聚关系

- **thenCombine**：接收另一个 future 及一个 `Function<T,R>`。
- **thenAcceptBoth**：接收另一个 future 及一个 `Consumer<T>`。
- **runAfterBoth**：接收另一个 future 及一个 `Runnable`。

```java
CompletionStage<R> thenCombine(other, fn);
CompletionStage<R> thenCombineAsync(other, fn);
CompletionStage<Void> thenAcceptBoth(other, consumer);
CompletionStage<Void> thenAcceptBothAsync(other, consumer);
CompletionStage<Void> runAfterBoth(other, action);
CompletionStage<Void> runAfterBothAsync(other, action);
```

### 2.3 描述 Or 并行汇聚关系

- applyToEither：同 `thenCombine`。
- acceptEither：同 `thenAcceptBoth`。
- runAfterEither：同 `runAfterBoth`。

```bash
CompletionStage applyToEither(other, fn);
CompletionStage applyToEitherAsync(other, fn);
CompletionStage acceptEither(other, consumer);
CompletionStage acceptEitherAsync(other, consumer);
CompletionStage runAfterEither(other, action);
CompletionStage runAfterEitherAsync(other, action);
```

### 2.4 异常处理

异步编程中可以用 `exceptionally(fn)` 来捕获异常：

```java
CompletableFuture<Integer> 
  f0 = CompletableFuture
    .supplyAsync(()->(7/0))
    .thenApply(r->r*10)
    .exceptionally(e->0);
System.out.println(f0.join());
```

而 whenComplete 和 handle 则用于表示 finally，区别是前者无返回值，后者有返回值。

```java
CompletionStage exceptionally(fn);
CompletionStage<R> whenComplete(consumer);
CompletionStage<R> whenCompleteAsync(consumer);
CompletionStage<R> handle(fn);
CompletionStage<R> handleAsync(fn);
```

### 3. 总结

曾经 Java 的异步编程实现，主要是通过回调方法，但应对复杂的异步任务关系时会产生十分复杂的回调依赖关系。

如果需要在 JDK 8 之前实现异步编程，可以使用 RxJava 项目。

## 4. 实践

实现 And 汇聚：

```java
public class FutureTest {

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        final CompletableFuture<Void> f1 = CompletableFuture.runAsync(() -> {
            try {
                System.out.println("洗茶壶");
                TimeUnit.SECONDS.sleep(1);
                System.out.println("煮水");
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        final CompletableFuture<String> f2 = CompletableFuture.supplyAsync(() -> {
            System.out.println("洗杯子");
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return "龙井";
        });
        final CompletableFuture<String> f3 = f1.thenCombineAsync(f2, (__, tr) -> {
            System.out.println("拿到茶叶");
            return "上茶：" + tr;
        });
        System.out.println(f3.get());
    }

}
```

反例代码：

1. 未处理异常
2. 耗时 I/O 操作，未使用其他线程池，可能导致线程饥饿
3. 如果两个操作都很耗时，考虑使用 生产者-消费者 模式。

```java
//采购订单
PurchersOrder po;
CompletableFuture<Boolean> cf = 
  CompletableFuture.supplyAsync(()->{
    //在数据库中查询规则
    return findRuleByJdbc();
  }).thenApply(r -> {
    //规则校验
    return check(po, r);
});
Boolean isOk = cf.join();
```