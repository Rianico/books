---
title: 05. CountDownLatch 和 CyclicBarrier
date: 2021-03-20
---

## 1. CountDownLatch 和 CyclicBarrier

当一个线程依赖于其他几个线程的结果时，需要对线程间做一个同步，如果是直接新建线程并启动，可以使用线程的 join 方法等待线程执行完：

```java
t1.join();
t2.join();
t3.start
```

当使用线程池的时候，无法使用 join(),通常的实现方案就是定义一个计时器，被依赖线程消耗计时器，依赖线程则监听计时器。

Java 提供了 CountDownLatch 和 CyclicBarrier 来实现这个方式，两者的区别为：

- CountDownLatch 适用于一个（主）线程等待多个（子）线程的场景，倾向于一个线程等待一组线程，计数器不可复用。
- CyclicBarrier 适用于多组线程之间相互等待的场景，更倾向于等待一组动作完成后执行另一个动作，计数器可复用。

CountDownLatch 代码示例如下：

```java
// 创建2个线程的线程池
Executor executor = Executors.newFixedThreadPool(2);
while(存在未对账订单){
  // 计数器初始化为2
  CountDownLatch latch = new CountDownLatch(2);
  // 查询未对账订单
  executor.execute(()-> {
    pos = getPOrders();
    latch.countDown();
  });
  // 查询派送单
  executor.execute(()-> {
    dos = getDOrders();
    latch.countDown();
  });
  
  // 等待两个查询操作结束
  latch.await();
  
  // 执行对账操作
  diff = check(pos, dos);
  // 差异写入差异库
  save(diff);
}
```

由于 CountDownLatch 的计数器不可复用，因此每次循环都需要重新建立一个 CountDownLatch 对象，此时代码的运行流程如下：

![](https://static001.geekbang.org/resource/image/a5/3b/a563c39ece918578ad2ff33ab5f3743b.png)

由于 check()、save() 不依赖于下一次的 getPOrders()、getDOrders() ，因此可以考虑将这个两个方法与下一轮的 getPOrders()、getDOrders() 并发执行：

![](https://static001.geekbang.org/resource/image/e6/8b/e663d90f49d9666e618ac1370ccca58b.png)

CyclicBarrier 结合队列可以实现该优化，代码如下：

```java
// 订单队列
Vector<P> pos;
// 派送单队列
Vector<D> dos;
// 执行回调的线程池 
Executor executor = 
  Executors.newFixedThreadPool(1);
final CyclicBarrier barrier =
  new CyclicBarrier(2, ()->{
    executor.execute(()->check());
  });
  
void check(){
  P p = pos.remove(0);
  D d = dos.remove(0);
  // 执行对账操作
  diff = check(p, d);
  // 差异写入差异库
  save(diff);
}
  
void checkAll(){
  // 循环查询订单库
  Thread T1 = new Thread(()->{
    while(存在未对账订单){
      // 查询订单库
      pos.add(getPOrders());
      // 等待
      barrier.await();
    }
  });
  T1.start();  
  // 循环查询运单库
  Thread T2 = new Thread(()->{
    while(存在未对账订单){
      // 查询运单库
      dos.add(getDOrders());
      // 等待
      barrier.await();
    }
  });
  T2.start();
}
```

CyclicBarrier 可以指定一个回调函数，在计数器归零后**同步方式去执行**，因此通常也会将其交给线程池去处理，避免阻塞，在那之后会重置计数器，进行复用。

## 2. CountDownLatch 详解

CountDownLatch 也是基于 AQS 实现的，通过对 state 变量的控制实现等待指定线程直到任务完成。

首先新建 CountDownLatch 时可以指定需要等待的线程数（state），当主线程提交了几个任务后，便会因为 await() 方法，在等待队列中进入阻塞状态。

其余子线程每调用一次 `countDown()` 方法，便会将 state - 1，当 某个线程将计数器减为 0 的时候，便会去唤醒锁中等待队列的线程，这时，主线程便会被唤醒。

对比 CyclicBarrier，CountDownLatch 在实现上只需要将主线程加入等待队列，并由将 state 减为 0 的子线程去唤醒。

## 3. CyclicBarrier 详解

CyclicBarrier 为了实现计数器复用以及循环执行，使用到了 ReentrantLock 和 Condition。

首先新建 CyclicBarrier 时可以指定需要等待的线程数（count），当子线程调用 await() 后，会让 count - 1 （通过 ReentrantLock 保证线程安全）并对其值进行判断：

- 如果计数器不为 0，则该线程会进入 **trip 变量（Condition 对象）的等待队列**。
- 如果计数器为 0，则执行指定的回调函数，**之后再**唤醒 trip 队列所有的线程，将 count 变量重新还原，继续进行下一轮。