---
title: 01.理论
date: 2021-03-07
---

## 1. 相关概念（微观）

线程不安全的三个源头性问题：

1. **可见性**，一个线程对数据的修改，另一个线程能够立刻看到。
   - 多核以及缓存（工作内存）带来了可见性问题
   
2. **原子性**，一个或者多个操作在 CPU 执行的过程中不被中断。
   - **多线程切换会带来原子性问题**。
   
   - CPU 保证的原子性是一条 CPU 指令，而非一行代码。
   - 原子性是为了保障中间状态不暴露给外界，避免被破坏。
   
3. 有序性，CPU 优化、编译器优化等可能会对指令进行重排序，实际执行顺序可能并非代码所写的那样。

Java 内存模型，在解决上述问题的前提下，通过**按需禁用缓存和编译优化**，以及 happens-before 原则实现了线程安全。

happens-before 是 Java 实现线程安全的理论基础，对**线程之间**指定了以下几个原则：

1. **程序的顺序性**，程序前面的操作先行于后面的操作。
2. **volatile**，对一个 volatile 变量的写操作，先行于后续对这个 volatile 的读操作（禁用缓存，JDK5 增强了语义）。
3. **传递性**，如果 A 先行发生于 B，B 先行发生于 C，那么 A 先行发生于 B。
4. 对一个锁的解锁，先行发生于后续对这个锁的加锁（前面做的操作对后面获取锁的线程可见）。
5. 对象的初始化先行于对象的 finalize()。
6. 线程的开始前的操作（`start()`）先行发生于线程中的动作。
7. 线程中发生的的动作先行于线程的结束。
8. 线程的中断操作，先行于线程检测到中断信号（`Thread.interrupted()`）。
9. 一个线程调用 join 等待另一个线程，另一个线程执行完后，发起调用的线程能看到完成线程的操作。

很多机制的实现，都是基于 happens-before 。

final 关键字避免变量的初始化被重排序到构造函数外，但构造器内还是会重排序的。

## 2. 互斥

互斥，保证某个资源同一时刻只有一个线程占有，通常是使用锁来实现对资源的保护。

通常一个锁与资源的合理关系是 1 : N，一把锁可以保护多个资源。需要注意的是，**两把不同的锁（比如实例对象和类）之间是不互斥的**。

如果一把锁需要保护多个有关联关系的资源，场景通常会较为复杂，对 class 本身进行加锁是最简单的方法（粗粒度，性能差）。

由于对 class 加锁代价较大，因此通常会使用更加细粒度的锁对多个资源加锁，提高并发性能，但往往也容易导致死锁。

死锁指的是，在一个程序中，两个或以上的线程都在等待其他线程释放资源，线程自身不会主动释放资源，资源也无法被其他线程抢占。

死锁在以下几个条件下会出现：

1. **互斥**，一把锁同一时间只能被一个线程持有；
2. **占有且等待**，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不会主动释放共享资源 X；
3. **不可抢占**，其他线程不能强行抢占线程 T1 占有的资源；
4. **循环等待**，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。

### 2.1 破坏占用且等待条件

通过一个协调者，由协调者来进行资源的获取，一旦一个线程向协调者同时申请多个资源成功，则另一个线程需要等待原有的线程向协调者发出释放资源的请求：

```java
class Allocator {
  private List<Object> als =
    new ArrayList<>();
  // 一次性申请所有资源
  synchronized boolean apply(Object from, Object to){
    if(als.contains(from) || als.contains(to)){
      return false;  
    } else {
      als.add(from);
      als.add(to);  
    }
    return true;
  }
  // 归还资源
  synchronized void free(
    Object from, Object to){
    als.remove(from);
    als.remove(to);
  }
}

class Account {
  // actr应该为单例
  private Allocator actr;
  private int balance;
  // 转账
  void transfer(Account target, int amt){
    // 一次性申请转出账户和转入账户，直到成功
    while(!actr.apply(this, target)){
    try{
      // 锁定转出账户
      synchronized(this){              
        // 锁定转入账户
        synchronized(target){           
          if (this.balance > amt){
            this.balance -= amt;
            target.balance += amt;
          }
        }
      }
    } finally {
      actr.free(this, target)
    }
  }
}
```

### 2.2 破坏不可抢占条件

使用可相应中断的方式。

### 2.3 破坏循环等待条件

两个线程相互循环等待，归根结底为资源的获取顺序问题，可以考虑为每个资源加入一个 id 进行排序，每次获取资源时先对资源进行排序：

```java
class Account {
  private int id;
  private int balance;
  // 转账
  void transfer(Account target, int amt){
    Account left = this        ①
    Account right = target;    ②
    if (this.id > target.id) { ③
      left = target;           ④
      right = this;            ⑤
    }                          ⑥
    // 锁定序号小的账户
    synchronized(left){
      // 锁定序号大的账户
      synchronized(right){ 
        if (this.balance > amt){
          this.balance -= amt;
          target.balance += amt;
        }
      }
    }
  } 
}
```

但这种方法会对对象造成入侵，不太可取。

### 2.4 等待-通知机制

假设一个线程通过 while(...) 请求资源，如果资源的操作是较为耗时的，那么这里的 while(...) 会一直空转，无谓的消耗 CPU 资源。

此处更好的做法是引入 等待-通知 机制，获取锁后当线程发现不满足一定条件时，先让自己进入等待队列释放锁，直到收到唤醒的通知。

Java 可以基于 synchronized 实现 通知-等待 机制，当线程发现某些条件不满足时，会进入锁自己独立的等待队列，进入阻塞状态，等待持有锁的线程的唤醒：

![](https://static001.geekbang.org/resource/image/1b/8c/1b3e999c300166a84f2e8cc7a4b8f78c.png)

当需要唤醒其他线程时，可以调用 Java 对象的 `notify()` 以及 `notifyAll()` 方法，告诉等待队列中的线程，它们的**条件曾经满足过**。

> NOTE：线程发起的通知只能保证在发起的那一刻条件是满足的。

通知-等待机制的一个经典范式是：

```java
while (...) {
	try {
		wait();
	} catch (Exception e) {}
}
```

> NOTE：使用 notify() 的一个风险在于，有些线程可能一直不会被唤醒。

## 3. 安全性、活跃性以及性能（宏观）

### 3.1 安全性

**数据竞争**，当多个线程需要访问同一个变量，且变量是可变的。

**竞态条件**，多个线程运行的结果依赖于线程之间的执行顺序，常见于多个线程显示/隐式的依赖于某个条件。

### 3.2 活跃性

除了死锁之外，还有活锁以及解锁：

- **活锁**：当多个线程需要竞争同一份资源时，彼此都让出资源给对方，持续反复的出现这个现象。
  - 解决方法：每个线程都等待一段随机的时间，错开竞争。
- **饥饿锁**：线程因无法申请到所需资源而无法执行下去。
  - 当高优先级的线程一直无法执行时，低优先级的线程基本无法获取 CPU 资源。
  - 解决方法：①保证资源充足；②公平分配资源（公平锁，先来后到）；③避免持有锁的线程长时间运行。

### 3.3 性能

锁会导致串行化，如果锁的粒度过大，会有大范围的串行操作，导致性能退化。

解决方案：

- 线程本地存储（ThreadLocal）
- 乐观锁
- Copy On Write
- 无锁结构的原子类
- 减少持有锁的时间（细粒度的锁）

性能方面常见三个指标：

1. **吞吐量**：指的是单位时间内能处理的请求数量。吞吐量越高，说明性能越好。
2. **延迟**：指的是从发出请求到收到响应的时间。延迟越小，说明性能越好。
3. **并发量**：指的是能同时处理的请求数量，一般来说**随着并发量的增加、延迟也会增加**。所以延迟这个指标，一般都会是基于并发量来说的。例如并发量是 1000 的时候，延迟是 50 毫秒。

## 4. 管程

管程是一种编程模型，指的是**管理共享变量以及对共享变量的操作过程**，让他们支持并发。

Java 参考了 MESA 模型（**条件变量 & 等待队列**）来实现管程，管程主要解决了并发的两个核心问题：**互斥**、**同步**。

### 4.1 互斥

管程解决互斥的方式为将变量以及操作统一封装起来（同步代码块）：

![](https://static001.geekbang.org/resource/image/59/c4/592e33c4339c443728cdf82ab3d318c4.png)

同一时间只允许一个线程进入管程。

### 4.2 同步

管程实现同步较为复杂，MESA 模型规定了以下两点：

- 管程拥有一个等待队列，同一时间只能有一个线程进入管程，其余线程在等待队列中等待；
- 管程内部可以有多个条件变量，每个条件变量也有各自的等待队列。

当一个线程进入管程后，如果满足了某个条件变量，就会进入该条件变量的等待队列，此时是允许其他线程进入管程的。

后面进来的线程可以通知前一个线程，此时线程会**从条件变量的等待队列转移到管程的等待队列**，重新尝试获取锁：

![](https://static001.geekbang.org/resource/image/83/65/839377608f47e7b3b9c79b8fad144065.png)

Java 的管程（synchronized、wait() 等）实现对 MESA 进行了精简，管程内部仅会有一个条件变量。

### 4.3 wait 的正确姿势

使用 while(...) 循环检测条件是 MESA 模型特有的。MESA 模型的特点就是，当一个线程唤醒了其他线程后，可能还会继续运行一段时间而不是立刻就退出运行状态，经过一段时间后，可能此时的条件已无法满足线程要求。

其他的模型如 Hasen、Hoare 都是一个线程通知另一个线程，然后原本的线程就暂停运行了。

### 4.4 notify() 正确用法

在依赖多个条件变量的时候，notify() 可能会导致依赖某个条件的线程不再有机会被唤醒，因此通常提倡使用 notifyAll()。当满足以下三个条件的时候可以使用 notify()：

1. **所有等待线程等待相同的条件**；
2. **所有等待线程唤醒后执行相同操作**；
3. 只需要唤醒一个线程。

## 5. 线程生命周期

通用的线程生命周期可以用 “五态模型” 来描述：

![](https://static001.geekbang.org/resource/image/9b/e5/9bbc6fa7fb4d631484aa953626cf6ae5.png)

1. **初始状态**，线程已经被创建，但还不允许分配 CPU 时间片。这个状态属于**编程语言特有**，仅在编程语言层面创建，操作系统中未创建。
2. **可运行状态**，线程在操作系统中真正被创建，已具备分配 CPU 时间片的条件。
3. **运行状态**，分配到 CPU 时间片的线程处于这种状态。
4. **休眠状态**，如果线程调用了一个阻塞的 API （如 BIO）或者等待某个事件（条件变量），那么线程会释放 CPU 使用权，进入该状态。
5. **终止状态**，系统执行完或者运行异常则会进入该状态，这也意味着线程的生命周期结束了。

Java 中将可运行状态状态与运行状态合并为 RUNNABLE。这两个阶段都是操作系统层面有用，JVM 里并不需要关心这两个状态。

> NOTE：JVM 的线程是调用操作系统提供的线程接口实现的，属于内核线程，交由内核进行调度。

Java 线程的生命周期如下：

![](https://static001.geekbang.org/resource/image/3f/8c/3f6c6bf95a6e8627bdf3cb621bbb7f8c.png)

**Java 中的阻塞状态并不是完全的对应操作系统的阻塞状态的**，如果调用了一个阻塞的 API，那么此时线程可能在 Java 中仍是 RUNNABLE 状态，而在系统属于一个阻塞操作，线程进入休眠状态。

> NOTE：我们常说的 Java 调用了一个阻塞操作，指的是操作系统层面。

RUNNABLE 进入 Blocked 状态，只会发生在 synchronized 临界区。

当需要取消阻塞操作时，Java 可以通过抛出异常，获取 CPU 时间片执行 catch 块中的操作：

- 如果当某个线程 A 处于 RUNNABLE，并且阻塞在 `java.nio.channels.InterruptibleChannel` 时（操作系统上为阻塞状态），当其他线程调用线程 A 的 `interrupt()` 方法，线程 A 会抛出 `java.nio.channels.ClosedByInterruptException` 异常；
- 如果线程 A 阻塞在 `java.nio.channels.Selector` 上，其他线程调用线程 A 的 `interrupt()` 方法，线程 A 的 `java.nio.channels.Selector` 会立即返回。

以上两种情况是通过（检测标志位）抛出异常来检测中断，让线程重新回到 RUNNABLE 状态。

还有一种情况是主动检测，线程处于 RUNNABLE 状态，并且没有阻塞在某个 I/O 操作上，线程可以通过调用 `Thread.isInterrupted()` 方法检测自己是否被中断了。

> NOTE：抛出 InterruptedException 异常后，**中断标志位会被清除，无法被 Thread.isInterrupted() 检测到，如果有需要必须重新调用一次 interrupt() 方法**。

## 6. 创建的线程数

使用线程是为了提高性能，尽可能地提升硬件的利用率。

在单核场景下，多线程主要是为了平衡 CPU 与 I/O，当一个线程执行 CPU 计算时，另一个线程可以执行 I/O 操作。

在多核场景下，多线程是为了充分发挥多核的能力，提高吞吐以及降级延迟时间。

线程数计算需要考虑作业属于 CPU 密集型还是 I/O 密集型：

- CPU 密集型：创建于核数相等的线程，避免线程切换的开销通常能发挥最大性能，但实际工程中往往会增加一个线程，在偶尔内存缺页或其他原因导致阻塞时，额外的线程可以顶上。

- I/O 密集型：需要根据 I/O 耗时来计算，通常取 CPU 执行时间：I/O 执行时间，如果是 1：1，则取两个线程，如果是 1：2，则取 3 个线程，保证某个线程在执行 I/O 操作时，其他线程的 CPU 运行时段能够覆盖 I/O 阶段。

  ![](https://static001.geekbang.org/resource/image/98/cb/98b71b72f01baf5f0968c7c3a2102fcb.png)

  

实际工程中，I/O 与 CPU 执行时间的比例是很难获取的且动态变化的，并且一台服务器也会有多个程序运行，因此在一个界定范围内进行调整即可，还可以考虑从降低修改线程数量成本的方向入手。

