---
titile: 06. 并发容器
date: 2021-03-21
---

## 1. 并发容器及其注意事项

Java 提供了很多并发安全的容器，但在部分场景下使用不当，仍会导致线程不安全，如组合操作隐含竞态条件、容器迭代等。

Java 提供的并发容器主要包含四大类：List、Map、Set 和 Queue：

![](https://static001.geekbang.org/resource/image/a2/1d/a20efe788caf4f07a4ad027639c80b1d.png)

## 2. List

List 只提供了一个 CopyOnWriteArrayList 的并发容器，对 CopyOnWriteArrayList 进行读操作的时候，实际上读取的只是它的一个视图；对 CopyOnWriteArrayList 进行写操作时，则会复制一份数据，对其进行写操作后，再将引用指向新的数组。

CopyOnWriteArrayList 适合读多写少的情况，能够容忍短暂的数据不一致问题，并且其迭代器是不能进行增删改操作的。

## 3. Map

Map 接口的两个实现是 ConcurrentHashMap 和 ConcurrentSkipListMap，前者的 key 是无序的，后者为有序的，且两者 key、value 都不能为 null。

各 Map 实现的容器对 key、value 要求如下：

![](https://static001.geekbang.org/resource/image/6d/be/6da9933b6312acf3445f736262425abe.png)

> NOTE：在 HashMap 冲突严重的情况下，可以考虑使用 SkipListMap（跳表），插入、删除、查询操作的平均时间复杂度为 O(logn)。

## 3. Set

Set 接口的两个实现是 CopyOnWriteArraySet 和 ConcurrentSkipListSet，使用场景可以参考前面讲述的 CopyOnWriteArrayList 和 ConcurrentSkipListMap。

## 4. Queue

Queue 的实现较多，可以从两个维度来区分：

- **阻塞和非阻塞**：当队列已满时，入队操作阻塞；当队列已空时，出队操作阻塞。
- **单端与双端**：单端指的是只能队尾入队，队首出队；而双端指的是队首队尾皆可入队出队。

Java 并发包中**阻塞队列都用 Blocking 关键字标识，单端队列使用 Queue 标识，双端队列使用 Deque 标识**。

因此可以分为四大类：

1. **单端阻塞队列**：其实现有 ArrayBlockingQueue（**有界**、数组）、LinkedBlockingQueue（**有界**、链表）、SynchronousQueue（无队列）、LinkedTransferQueue（性能更好）、PriorityBlockingQueue（优先级） 和 DelayQueue（延时出队）。

2. 双端阻塞队列：LinkedBlockingDeque。
3. 单端非阻塞队列：ConcurrentLinkedQueue。
4. 双端非阻塞队列：ConcurrentLinkedDeque。

实际使用中，通常都是使用有界队列，避免队列长度无限制导致的 OOM。

## 5. 延伸

JDK8 之前，多线程写 HashMap 在扩容时（尾插入）可能会形成循环数组，导致 CPU 100% 的问题。JDK 8 之后，HashMap 扩容时则是将某个节点上的链表/红黑树分为两条队列，一条插入到新数组的原始下标位置，一条插入到新数组**原始下标 + 原始数组长度**的位置。

