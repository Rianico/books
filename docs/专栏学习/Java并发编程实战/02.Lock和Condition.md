---
title: 02.Lock 和 Condition
date: 2021-03-13
---

## 1. 前言

Java SDK 包提供了 Lock 以及 COndition 两个接口实现管程：

- Lock 用于解决互斥问题
- Condition 用于解决同步问题

## 2. Lock 接口

synchronized 由于线程申请不到资源时，就进入阻塞状态了，阻塞状态的线程无法执行任何操作，因此也就无法自主释放资源，从而导致资源不可抢占。

如果要支持资源自主释放，通常有以下几个方案：

1. 能够响应中断，线程响应中断信号，从而释放资源。
2. 支持超时，如果线程在一段时间内没有获取到锁，不是进入阻塞状态，而是返回一个错误，并释放已持有的锁。
3. 非阻塞的获取锁，如果尝试获取锁失败，并不进入阻塞状态，而是直接返回。

Lock 提供了三个方法支持以上特性：

```java
// 支持中断的API
void lockInterruptibly() 
  throws InterruptedException;
// 支持超时的API
boolean tryLock(long time, TimeUnit unit) 
  throws InterruptedException;
// 支持非阻塞获取锁的API
boolean tryLock();
```

**Lock 使用了 Happens-Before 规则里的 volatile 来保障可见性**，通过对一个 volatile 状态变量的使用，让后面获取锁的线程能够看到前一个线程做出的修改。

ReentrantLock 分为公平锁与非公平锁，通过一个有参构造器来控制：

- 非公平锁：性能高，但可能出现某个线程虽然先到但一直分配不到资源的情况。
- 公平锁：按照线程先来后到因此调度，但性能会因此下降。

使用锁有三条最佳实践：

1. 永远只在更新对象时加锁；
2. 永远只在访问可变对象时加锁；
3. 永远不要在调用其他对象方法时加锁（争议，但最好遵守）

第三条虽然较为严苛，但尽量遵守，因为其他对象的方法里，可能里面本身有 sleep 方法，或者有其他的锁，或者有极其耗时的 I/O 操作，这些都可能导致系统出现严重性能下降或者死锁等不可预知的问题。

有段代码如下：

```java
class Account {
  private int balance;
  private final Lock lock
          = new ReentrantLock();
  // 转账
  void transfer(Account tar, int amt){
    while (true) {
      if(this.lock.tryLock()) {
        try {
          if (tar.lock.tryLock()) {
            try {
              this.balance -= amt;
              tar.balance += amt;
            } finally {
              tar.lock.unlock();
            }
          }
        } finally {
          this.lock.unlock();
        }
      }
    }
  }
}
```

如果 A、B 双方相互转账，可能会造成活锁，同时转账结束后也没有退出循环，应当在获取锁的地方添加一个超时时间，并在转账成功后，退出循环。

## 2. Condition 接口

Condition 接口用于实现类似于 synchronized 的**等待-通知**模式，通常与业务结合的比较紧密。

Condition 有 await()、signal()、signalAll() 方法，对应对象的 wait()、notify()、notifyAll() 。

Condition 需要从 Lock 对象中获取，可以对应一个或者多个条件。当调用 Condition 对象的 await() 方法时，会将当前线程作为一个 Node 加入一个等待队列（双向链表结构），至于是否 FIFO，则取决于唤醒时调用的是 signal() 还是 signalAll() 方法。

## 3. 同步与异步

Java 代码中对请求的获取通常默认都是同步的，如果需要支持异步，可以有以下两种方法：

1. 新起一个子线程，将所需执行的任务交给子线程去执行，这种方式称为**异步调用**。
2. 调用一个方法后，方法立刻 return，方法内部会自行处理（通常也是起一个线程处理），这种方式称为异步方法。

在 TCP 层面，发送完 RPC 请求后，线程是不会等待 RPC 响应的，需要我们通过一定的方式去获取 RPC 相应结果。

Dubbo 的方式是将异步转为同步，通常是使用 `DefaultFuture.get()` 方法实现，本质上也是使用 Lock 与 Condition 实现等待-通知机制：

```java
// 创建锁与条件变量
private final Lock lock 
    = new ReentrantLock();
private final Condition done 
    = lock.newCondition();

// 调用方通过该方法等待结果
Object get(int timeout){
  long start = System.nanoTime();
  lock.lock();
  try {
  while (!isDone()) {
    done.await(timeout);
      long cur=System.nanoTime();
    if (isDone() || 
          cur-start > timeout){
      break;
    }
  }
  } finally {
  lock.unlock();
  }
  if (!isDone()) {
  throw new TimeoutException();
  }
  return returnFromResponse();
}
// RPC结果是否已经返回
boolean isDone() {
  return response != null;
}
// RPC结果返回时调用该方法   
private void doReceived(Response res) {
  lock.lock();
  try {
    response = res;
    if (done != null) {
      done.signal();
    }
  } finally {
    lock.unlock();
  }
}
```

