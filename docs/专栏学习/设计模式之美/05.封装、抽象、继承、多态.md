---
title: 05.封装、抽象、继承、多态
date: 2020-07-22 11:29:20
---
# 05 | 理论二：封装、抽象、继承、多态分别可以解决哪些编程问题？

### 1. 关于封装特性\(Encapsulation\)

封装也叫作**信息隐藏**或者**数据访问保护**。类通过暴露有限的访问接口，授权**外部仅能通过类提供的方式来访问内部信息或者数据**。它需要编程语言具有权限访问控制相关的语义，例如 Java 中的 private、protected、public 关键字。封装特性存在的意义，

**能解决什么问题？**

* 保护数据不被随意修改，提高代码的可维护性；
* **仅暴露有限的必要接口，提高类的易用性**，降低使用的复杂度。

下面是一个虚拟电子钱包的代码实现：

```java
public class Wallet {
  private String id;
  private long createTime;
  private BigDecimal balance;
  private long balanceLastModifiedTime;
  // ...省略其他属性...

  public Wallet() {
     this.id = IdGenerator.getInstance().generate();
     this.createTime = System.currentTimeMillis();
     this.balance = BigDecimal.ZERO;
     this.balanceLastModifiedTime = System.currentTimeMillis();
  }

  // 注意：下面对get方法做了代码折叠，是为了减少代码所占文章的篇幅
  public String getId() { return this.id; }
  public long getCreateTime() { return this.createTime; }
  public BigDecimal getBalance() { return this.balance; }
  public long getBalanceLastModifiedTime() { return this.balanceLastModifiedTime;  }

  public void increaseBalance(BigDecimal increasedAmount) {
    if (increasedAmount.compareTo(BigDecimal.ZERO) < 0) {
      throw new InvalidAmountException("...");
    }
    this.balance.add(increasedAmount);
    this.balanceLastModifiedTime = System.currentTimeMillis();
  }

  public void decreaseBalance(BigDecimal decreasedAmount) {
    if (decreasedAmount.compareTo(BigDecimal.ZERO) < 0) {
      throw new InvalidAmountException("...");
    }
    if (decreasedAmount.compareTo(this.balance) > 0) {
      throw new InsufficientAmountException("...");
    }
    this.balance.subtract(decreasedAmount);
    this.balanceLastModifiedTime = System.currentTimeMillis();
  }
}
```

Wallet 类主要有四个属性，id 表示钱包的唯一编号，createTime 表示钱包创建的时间，balance 表示钱包中的余额，balanceLastModifiedTime 表示上次钱包余额变更的时间。

我们参照封装特性，对钱包的这四个属性的访问方式进行了限制，只能通过我们给定的几个方法来访问或修改钱包的数据。

**访问权限控制**是实现封装的基石，需要编程语言支持。

### 2. 关于抽象特性\(Abstraction\)

封装主要讲如何隐藏信息、保护数据，那抽象就是讲**如何隐藏方法的具体实现**，让使用者只需要关心方法提供了哪些功能，不需要知道这些功能是如何实现的，是一种只关注功能点不关注实现的设计思路。

抽象可以通过接口类或者抽象类来实现，但也并不需要特殊的语法机制来支持（存在函数这一级别即可实现抽象，通过函数包裹具体的实现逻辑，这本身就是一种抽象）。

**能解决什么问题？**

* 提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围；
* 处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息，只关注核心部分。

比如我们定义一个图片存储功能：

```java
public interface IPictureStorage {
  void savePicture(Picture picture);
  Image getPicture(String pictureId);
  void deletePicture(String pictureId);
  void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo);
}

public class PictureStorage implements IPictureStorage {
  // ...省略其他属性...
  @Override
  public void savePicture(Picture picture) { ... }
  @Override
  public Image getPicture(String pictureId) { ... }
  @Override
  public void deletePicture(String pictureId) { ... }
  @Override
  public void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo) { ... }
}
```

在定义（或者叫命名）类的方法的时候，也要有抽象思维，不要在方法定义中，暴露太多的实现细节，以保证在某个时间点需要改变方法的实现逻辑的时候，不用去修改其定义。举个简单例子，比如 getAliyunPicture\(\) 就不是一个具有抽象思维的命名，因为某一天如果我们不再把图片存储在阿里云上，而是存储在私有云上，那这个命名也要随之被修改。相反，如果我们定义一个比较抽象的函数，比如叫作 getPicture\(\)，那即便内部存储方式修改了，我们也不需要修改命名。

### 3. 关于继承特性\(Inheritance\)

继承是用来表示类之间的 is-a 关系，分为两种模式：单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类。

为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持。

**能解决什么问题？**

继承主要是用来解决代码复用的问题。

关于复用，除了也可以通过其他方式来解决这个代码复用的问题，比如利用组合关系而不是继承关系。然而过度使用继承，继承层次过深过复杂，就会导致代码可读性、可维护性变差，因此也有人觉得继承是一种反模式，可以通过“多用组合少用继承”这种设计思想，具体情况具体分析。

### 4. 关于多态特性

多态是指子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。多态这种特性也需要编程语言提供特殊的语法机制来实现，比如继承、接口类、duck-typing（动态语言）。

**能解决什么问题？**

多态可以提高代码的扩展性，复用性以及灵活性，是很多设计模式、设计原则、编程技巧的代码实现基础。

下面举一个通过接口类实现多态的例子：

```java
public interface Iterator {
  String hasNext();
  String next();
  String remove();
}

public class Array implements Iterator {
  private String[] data;

  public String hasNext() { ... }
  public String next() { ... }
  public String remove() { ... }
  //...省略其他方法...
}

public class LinkedList implements Iterator {
  private LinkedListNode head;

  public String hasNext() { ... }
  public String next() { ... }
  public String remove() { ... }
  //...省略其他方法...
}

public class Demo {
  private static void print(Iterator iterator) {
    while (iterator.hasNext()) {
      System.out.println(iterator.next());
    }
  }

  public static void main(String[] args) {
    Iterator arrayIterator = new Array();
    print(arrayIterator);

    Iterator linkedListIterator = new LinkedList();
    print(linkedListIterator);
  }
}
```

Iterator 是一个接口类，定义了一个可以遍历集合数据的迭代器。Array 和 LinkedList 都实现了接口类 Iterator。我们通过传递不同类型的实现类（Array、LinkedList）到 print\(Iterator iterator\) 函数中，支持动态的调用不同的 next\(\)、hasNext\(\) 实现。

如果我们不使用多态特性，我们就无法将不同的集合类型（Array、LinkedList）传递给相同的函数（print\(Iterator iterator\) 函数）。我们需要针对每种要遍历打印的集合，分别实现不同的 print\(\) 函数，比如针对 Array，我们要实现 print\(Array array\) 函数，针对 LinkedList，我们要实现 print\(LinkedList linkedList\) 函数。而利用多态特性，我们只需要实现一个 print\(\) 函数的打印逻辑，就能应对各种集合数据的打印操作，这显然提高了代码的复用性。

### 思考总结

**What/How/Why 模型**

```vim
## 封装
What：隐藏信息，保护数据访问。
How：暴露有限接口和属性，需要编程语言提供访问控制的语法。
Why：提高代码可维护性；降低接口复杂度，提高类的易用性。

## 抽象
What: 隐藏具体实现，使用者只需关心功能，无需关心实现。
How: 通过接口类或者抽象类实现，特殊语法机制非必须。
Why: 提高代码的扩展性、维护性；降低复杂度，减少细节负担。

## 继承
What: 表示 is-a 关系，分为单继承和多继承。
How: 需要编程语言提供特殊语法机制。例如 Java 的 “extends”，C++ 的 “:” 。
Why: 解决代码复用问题。

## 多态
What: 子类替换父类，在运行时调用子类的实现。
How: 需要编程语言提供特殊的语法机制。比如继承、接口类、duck-typing。
Why: 提高代码扩展性和复用性。
```

**为什么Java不支持多继承？**

多重继承有副作用：钻石问题\(菱形继承\)，产生二义性。

