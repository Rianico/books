---
title: 14.循环优化
date: 2020-12-06
---

Java 编译器有几项用于循环优化的方法：

- 循环无关代码外提
- 循环展开
- 循环剥离
- 循环判断外提

## 1. 循环无关代码外提

**循环无关代码（Loop-invariant Code）**，指的是循环中值不变的表达式，在不改变语义的前提下，将**循环无关代码**提取到循环体外。

```java
int foo(int x, int y, int[] a) {
  int sum = 0;
  for (int i = 0; i < a.length; i++) {
    sum += x * y + a[i];
  }
  return sum;
}
// 优化为：
int fooManualOpt(int x, int y, int[] a) {
  int sum = 0;
  int t0 = x * y;
  int t1 = a.length;
  for (int i = 0; i < t1; i++) {
    sum += t0 + a[i];
  }
  return sum;
}
```

在借助 IR 图的情况下，循环无关代码的外提并不复杂。

上述代码中 `iaload` 对应加载 `a[]` ，这个指令实际上暗含 null 检测（null check）以及下标范围检测（range check），将其展开伪代码如下：

```java
int foo(int[] a) {
  int sum = 0;
  for (int i = 0; i < a.length; i++) {
    if (a == null) { // null check
      throw new NullPointerException();
    }
    if (i < 0 || i >= a.length) { // range check
      throw new ArrayIndexOutOfBoundsException();
    }
    sum += a[i];
  }
  return sum;
}
```

由于 null 检测设计了控制流一来，无法通过 Sea-of-Nodes IR 转换以及节点调度来完成外提。

C2 中 null 检测的外提是通过额外的编译优化，也就是**循环预测（Loop Prediction，对应虚拟机参数-XX:+UseLoopPredicate）**来实现的。该优化的实际做法是在循环之前插入同样的检测代码，并在命中的时候进行去优化。这样一来，循环中的检测代码便会被归纳并消除掉：

```java
int foo(int[] a) {
  int sum = 0;
  if (a == null) {
    deoptimize(); // never returns
  }
  for (int i = 0; i < a.length; i++) {
    if (a == null) { // now evluate to false
      throw new NullPointerException();
    }
    if (i < 0 || i >= a.length) { // range check
      throw new ArrayIndexOutOfBoundsException();
    }
    sum += a[i];
  }
  return sum;
}
```

除了 null 检测之外，其他**循环无关检测**都能够按照这种方式外提至循环之前。甚至是循环有关的下标范围检测，都能够借助循环预测来外提。

例如变量 i ，是与循环有关的（随着循环次数增加），下标检测外提后，无法再引用到循环变量i，因此，即时编译器需要转换检测条件：

```java
for (int i = INIT; i < LIMIT; i += STRIDE) {
  if (i < 0 || i >= a.length) { // range check
    throw new ArrayIndexOutOfBoundsException();
  }
  sum += a[i];
}
----------
// 经过下标范围检测外提之后：
if (INIT < 0 || IMAX >= a.length) {
  // IMAX是i所能达到的最大值，注意它不一定是LIMIT-1
  detopimize(); // never returns
}
for (int i = INIT; i < LIMIT; i += STRIDE) {
  sum += a[i]; // 不包含下标范围检测
}
```

## 2. 循环展开

**循环展开（Loop Unrolling）**，指的是在循环体中重复多次循环迭代，并减少循环次数的编译优化。

```java
int oo(int[] a) {
  int sum = 0;
  for (int i = 0; i < 64; i++) {
    sum += (i % 2 == 0) ? a[i] : -a[i];
  }
  return sum;
}
// 优化为：
int foo(int[] a) {
  int sum = 0;
  for (int i = 0; i < 64; i += 2) { // 注意这里的步数是2
    sum += (i % 2 == 0) ? a[i] : -a[i];
    sum += ((i + 1) % 2 == 0) ? a[i + 1] : -a[i + 1];
  }
  return sum;
}
```

 C2 中，只有计数循环（Counted Loop）才能被展开：

1. 维护一个循环计数器，并且基于计数器的**循环出口只有一个**（但可以有基于其他判断条件的出口）。
2. 循环计数器的类型为 int、short 或者 char（即不能是 byte、long，更不能是 float 或者 double）。
3. 每个迭代循环计数器的增量为常数。
4. 循环计数器的上限（增量为正数）或下限（增量为负数）是循环无关的数值

```java
for (int i = START; i < LIMIT; i += STRIDE) { .. }
// 等价于
int i = START;
while (i < LIMIT) {
  ..
  i += STRIDE;
}
```

只要 LIMIT 是循环无关的数值，STRIDE 是常数，而且循环中除了 `i < LIMIT` 之外没有其他基于循环变量i的循环出口，那么 C2 便会将该循环识别为计数循环。

循环展开可能会增加代码的冗余度，导致所生成机器码的长度大幅上涨。但随着循环体的增大，优化机会也会不断增加。一旦循环展开能够触发进一步的优化，总体的代码复杂度也将降低：

```java
int foo(int[] a) {
  int sum = 0;
  for (int i = 0; i < 64; i += 2) {
    sum += a[i];
    sum += -a[i + 1];
  }
  return sum;
}
```

循环展开当遇到循环次数为固定值且非常小时，会考虑将其完全展开：

```java
int foo(int[] a) {
  int sum = 0;
  for (int i = 0; i < 4; i++) {
    sum += a[i];
  }
  return sum;
}
// 展开为
int foo(int[] a) {
  int sum = 0;
  sum += a[0];
  sum += a[1];
  sum += a[2];
  sum += a[3];
  return sum;
}
```

## 3. 循环判断外提

**循环判断外提（loop unswitching）**，指的是将循环中的 if 语句外提至循环之前，并且在该 if 语句的两个分支中分别放置一份循环代码。

```java
int foo(int[] a) {
  int sum = 0;
  for (int i = 0; i < a.length; i++) {
    if (a.length > 4) {
      sum += a[i];
    }
  }
  return sum;
}
// 循环外提：

int foo(int[] a) {
  int sum = 0;
  if (a.length > 4) {
    for (int i = 0; i < a.length; i++) {
      sum += a[i];
    }
  } else {
    for (int i = 0; i < a.length; i++) {
    }
  }
  return sum;
}
// 进一步优化为：
int foo(int[] a) {
  int sum = 0;
  if (a.length > 4) {
    for (int i = 0; i < a.length; i++) {
      sum += a[i];
    }
  }
  return sum;
}
```

**循环判断外提**与**循环无关检测外提**针对的代码模式较为类似，都是循环中的 if 语句，但针对的方面不同：

- 前者更加针对通过 if 语句的不同分支执行不同的代码逻辑。
- 后者则在检查失败时会抛出异常，中止当前的正常执行路径。

## 4. 循环剥离

**循环剥离（loop peeling）**指的是将循环的前几个迭代或者后几个迭代剥离出循环的优化方式，主要是讲一些需要特殊对待的首位情况外提，从而更好地针对循环体进行优化。

```java
int foo(int[] a) {
  int j = 0;
  int sum = 0;
  for (int i = 0; i < a.length; i++) {
    sum += a[j];
    j = i;
  }
  return sum;
}
// 优化为：
int foo(int[] a) {
  int sum = 0;
  if (0 < a.length) {
    sum += a[0];
    for (int i = 1; i < a.length; i++) {
      sum += a[i - 1];
    }
  }
  return sum;
}
```

