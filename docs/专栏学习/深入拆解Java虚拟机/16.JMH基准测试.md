---
title: 16.JMH基准测试
date: 2020-12-19
---

JMH 是一个面向 Java 语言或者其他 Java 虚拟机语言的性能基准测试框架。它针对的是纳秒级别（持怀疑态度）、微秒级别、毫秒级别，以及秒级别的性能测试。

JMH 可以帮助开发人员避开编译器优化、操作系统、机器硬件中影响性能测试结果的绝大部分影响，只需要简单的借助注解功能，便可以专注于业务代码的测试。

JMH 可以使用 maven 生成项目模板：

```shell
$ mvn archetype:generate \
          -DinteractiveMode=false \
          -DarchetypeGroupId=org.openjdk.jmh \
          -DarchetypeArtifactId=jmh-java-benchmark-archetype \
          -DgroupId=org.sample \
          -DartifactId=test \
          -Dversion=1.21
$ cd test
```

## 1. 注解功能

JMH 会通过继承的方式，来避免不同测试类中字段 false sharing 的影响（因为继承父类可以避免字段重排序的影响）。

- `@Fork`：指定 fork 多少出个 JVM，可以避免后续测试被先前测试影响的情况（如 profile 被污染）。每个 fork 默认包含 5 轮**预热迭代**以及 5 个**测试迭代**。

  ```java
  @Fork(10)
  public class MyBenchmark {
    ...
  }
  ```

- `@BenchmarkMode`：表示要测试的类型（*Throughput,* *AverageTime,* *SampleTime*, and *SingleShotTime*），比如吞吐量、每个操作平均耗时等。

  ```java
  @BenchmarkMode(Mode.AverageTime)
  public class MyBenchmark {
    ...
  }
  ```

- `@Warmup`：指定预热迭代次数，预热迭代是为了让测试的结果能够在一个较为稳定的状态（如 TLAB 大小已稳定、JIT 优化已完成等）下生成，通常保持在 5 ~ 10 轮即可。

  - `iterations`：指定预热迭代的轮数。
  - `time`：每次迭代持续的时间。
  - `timeUnit`：迭代的时间单位。
  - batchSize：每次操作包含多少次对测试方法的调用。

  ```java
  @Warmup(iterations=10, time=100, timeUnit=TimeUnit.MILLISECONDS, batchSize=10)
  public class MyBenchmark {
    ...
  }
  ```

- `@Measurement`：指定测试迭代次数，子参数同 `@Warmup`。

- `@State`：指定程序的状态，JMH 划分为**整个虚拟机的程序状态**，**线程私有的程序状态**，以及**线程组私有的程序状态**，分别对应 `@State` 注解的参数 `Scope.Benchmark`，`Scope.Thread` 和 `Scope.Group`。要求状态类有无参构造器，以及当状态类为内部类时，该状态类必须是静态的。

  ```java
  public class MyBenchmark {
      @State(Scope.Benchmark)
      public static class MyBenchmarkState {
        String message = "exception";
      }
  
      @Benchmark
      public void testMethod(MyBenchmarkState state) {
          new Exception(state.message);
      }
  }
  ```

- `@Setup` 以及 `@TearDown`：可用于测试前初始化程序状态，在测试后校验程序状态，不限定个数，多个时按照定义顺序执行。可供选择的粒度有**在整个性能测试前后调用**（`Level.Trial`），**在每个迭代前后调用**（`Level.Iteration`），以及**在每次调用测试方法前后调用**（`Level.Invocation`，影响测试数据的精度）。

  ```java
  public class MyBenchmark {
    @State(Scope.Benchmark)
    public static class MyBenchmarkState {
      int count;
  
      @Setup(Level.Invocation)
      public void before() {
        count = 0;
      }
  
      @TearDown(Level.Invocation)
      public void after() {
        // Run with -ea
        assert count == 1 : "ERROR";
      }
    }
  
    @Benchmark
    public void testMethod(MyBenchmarkState state) {
      state.count++;
    }
  }
  ```

## 2. 即时编译相关功能

JMH 还提供了不少控制即时编译的功能：

- `@CompilerControl` ，控制方法内联与否。
- `Blackhole` 类，可以使用 `Blackhole.consume` 避免 JIT 优化掉传入的值（即死代码消除）。

## 3. 参考地址

- [JMH 官方例子](https://github.com/openjdk/jmh/tree/master/jmh-samples/src/main/java/org/openjdk/jmh/samples)