---
title: 15.向量化与SIMD 
date: 2020-12-06
---

数组元素在内存中是连续存在的，当需要对数组内容进行访问时，可以通过**向量化**的方式增大单指令处理的数据量。

X86_64 体系架构上通用寄存器的大小为 64 位（即 8 个字节），无法暂存连续几个 int、long 这类超长的数据，因此会借助长度足够的 **XMM 寄存器**来完成 int 数组与 long 数组的向量化读取和写入操作。

> NOTE： byte 数组的向量化读取、写入操作同样使用了 XMM 寄存器。

XMM 寄存器，是由 SSE（Streaming SIMD Extensions）指令集所引入的，仅有 128 位。CPU 引入 AVX（Advanced Vector Extensions）指令集后（2011 年），XMM 寄存器便升级为 256 位，并更名为 YMM 寄存器。原本的 XMM 寄存器指令，会使用 YMM 的低 128 位。ZMM 为更新的寄存器，有 512位。

![](https://static001.geekbang.org/resource/image/56/f2/56cb8c99ce8a80d1c510ef50122616f2.png)

SSE 指令集以及之后的 AVX 指令集都涉及了一个重要的概念：**单指令流多数据流（Single Instruction Multiple Data，SIMD）**，即通过单条指令操控多组数据的计算操作。

![](https://static001.geekbang.org/resource/image/8a/cf/8ad6be0e44c4f14b45c7c8c4cf6eabcf.png)

SIMD 指令将 XMM 寄存器（或 YMM 寄存器、ZMM 寄存器）中的值看成多个整数或者浮点数组成的**向量**，并且**批量进行计算**。

![](https://static001.geekbang.org/resource/image/d6/40/d61b5f38e3736acf3447412888a32b40.png)

SIMD 指令PADDB、PADDW、PADDD以及PADDQ，将分别实现 byte 值、short 值、int 值或者 long 值的向量加法。

> NOTE：内存右边为高位，寄存器左边为高位，因此相反。

## 1. 使用 SIMD 指令的 HotSpot Intrinsic

使用 SIMD 较为麻烦，需要解决各种问题，首先是不同平台有不同的 SIMD 指令，而由于 Java 字节码是平台无关的，在 JVM 中运行的时候，已经可以知道平台支持的指令了。

但是，Java 字节码的平台无关性却引发了另一个问题，那便是 Java 程序无法像 C++ 程序那样，直接使用由 Intel 提供的直接替换为具体 SIMD 指令的 intrinsic 方法。

HotSpot 虚拟机提供的替代方案是 **Java 层面的 intrinsic 方法**，比起单个 SIMD 复杂得多。

HotSpot intrinsic 是虚拟机开发人员根据其语义定制的一套高效实现，调用了 SIMD ，维护成本较高，且覆盖面也较少，只能实现点的覆盖。

> NOTE： 常见的 Java intrinsic 有 Math 库的函数，以及 System 库。

在不少情况下，应用程序并不会用到这些 intrinsic 的语义，却又存在向量化优化的机会，这时候，需要借助 JIT 中的**自动向量化（auto vectorization）**。

## 2. 自动向量化

JIT 的自动向量化将针对**能够展开的计数循环**，进行向量化优化：

```java
void foo(int[] a, int[] b, int[] c) {
  for (int i = 0; i < c.length; i++) {
    c[i] = a[i] + b[i];
  }
}
```

自动向量化需要满足几个条件：

1. 循环变量的增量应为 1，即能够遍历整个数组。
2. 必须为计数循环。
3. 循环迭代之间最好不要有数据依赖，例如出现类似于 `a[i] = a[i-1]` 的语句。当循环展开之后，循环体内存在数据依赖，那么 C2 无法进行自动向量化。
4. 循环体内不要有分支跳转。
5. **不要手工进行循环展开**。如果 C2 无法自动展开，那么它也将无法进行自动向量化。

