---
title: 07.Java内存模型
date: 2020-10-31
---



由于存在 **编译器 重排序**，**处理器的乱序执行**以及**内存系统的重排序**，Java 代码代码往往不是按照我们的直觉顺序执行的，并且单线程与多线程之间的执行也不一样。

## 1. 单线程

在单线程场景中，JIT 编译器遵循 as-if-serial 原则，即**经过重排序的结果要与顺序执行的结果一致**：如果变量之间存在依赖，那么重排序不能调整两者之间的顺序。

重排序往往是为了提高程序运行效率：

```java
/**
** 此处编译器可以选择先不执行a赋值擦作，而是等到要用到a的时候再执行，这样可以节省一个寄存器
*/

int a=0, b=0;
public void method1() {
  int r2 = a;
  b = 1;
  .. // Code uses b
  if (r2 == 2) {
    .. 
  }
}

/**
** 这段代码循环与b无关，编译器可以选择将b提取出来先不执行
*/
int a=0, b=0;
public void method1() {
  for (..) {
    int r2 = a;
    b = 1;
    .. // Code uses r2 and rewrites a
  }
}
```

由于有了 `as-if-serial`  的保证，单线程场景下重排序并不会造成什么影响，但在多线程场景下，就会出现**数据竞争（data race）**从而导致预期外的结果发生。

## 2. 多线程 & happens-before

Java 5 引入了明确定义的 Java 内存模型，最重要的一个概念便是  happens-before 原则。

happens-before 关系是用来描述**两个操作的内存可见性**的。如果操作 X happens-before 操作 Y，那么 X 的结果对于 Y 可见。

> Java 采用的是共享内存方式，因此 Java 内存模型描述了如何从内存中获取正确的值。

线程内的 happens-before 关系：

- 在同一个线程中，字节码的先后顺序（program order）也暗含了 happens-before 关系：在程序控制流路径中靠前的字节码 happens-before 靠后的字节码。但如果相互之间没有依赖关系，仍可能会被重排序。

线程间的 happens-before 关系：

1. 解锁操作 happens-before 之后（这里指时钟顺序先后）对**同一把锁**的加锁操作。
2. volatile 字段的写操作 happens-before 之后（这里指时钟顺序先后）对同一字段的读操作。
3. 线程的启动操作（即 `Thread.starts()`） happens-before 该线程的第一个操作。
4. 线程的最后一个操作 happens-before 它的终止事件（即其他线程可以通过 `Thread.isAlive()` 或 `Thread.join()` 判断该线程是否中止）。
5. 线程对其他线程的中断操作 happens-before 被中断线程所收到的中断事件（即被中断线程的 InterruptedException 异常，或者第三个线程针对被中断线程的 Thread.interrupted 或者 Thread.isInterrupted 调用）。
6. 构造器中的最后一个操作 happens-before 析构器的第一个操作。


happens-before 关系还具备传递性。如果操作 X happens-before 操作 Y，而操作 Y happens-before 操作 Z，那么操作 X happens-before 操作 Z。

## 3. Java 内存模型的底层实现

Java 内存模型是通过**内存屏障（memory barrier）**来禁止重排序的。

JIT 会根据 happens-before 关系，向正在编译的目标方法插入相应的读读、读写、写读以及写写内存屏障，以此来限制重排序操作。

### 3.1 volatile

以 volatile 字段访问为例，所插入的内存屏障将不允许 **volatile 字段写操作之前的内存访问被重排序至其之后**；也将**不允许 volatile 字段读操作之后的内存访问被重排序至其之前**。

除了内存屏障外，JIT 不会将 volatile 字段分配到寄存器里，**volatile 字段的每次访问均需要直接从内存中读写**。

> NOTE：JIT 会根据具体的底层体系架构，将内存屏障替换为具体的 CPU 指令。在 x86 架构中，读读、读写以及写写内存屏障是空操作（no-op），只有写读内存屏障会被替换成具体指令。

volatile 的写读内存屏障，会强制将写缓存的值刷新到主存中，这样一来，其他处理器/线程的缓存行对应的值就失效了，需要重新从主存中获取。

### 3.2 final

当一个对象包含 final 实例字段时，即时编译器会在 final 字段的写操作后插入一个 StoreStore 屏障，**以防止某些优化将新建对象的发布（即将实例对象写入一个共享引用中）重排序至 final 字段的写操作之前**。

### 3.3 锁

Java 可以通过  synchronized 关键字来对程序进行加锁，编译而成的字节码将包含 `monitorenter` 和 `monitorexit` 指令。

这两种指令均会消耗操作数栈上的一个引用类型的元素（也就是 synchronized 关键字括号里的引用），作为所要加锁解锁的锁对象。

```java
  public void foo(Object lock) {
    synchronized (lock) {
      lock.hashCode();
    }
  }
  // 上面的Java代码将编译为下面的字节码
  public void foo(java.lang.Object);
    Code:
       0: aload_1
       1: dup
       2: astore_2
       3: monitorenter
       4: aload_1
       5: invokevirtual java/lang/Object.hashCode:()I
       8: pop
       9: aload_2
      10: monitorexit
      11: goto          19
      14: astore_3
      15: aload_2
      16: monitorexit
      17: aload_3
      18: athrow
      19: return
    Exception table:
       from    to  target type
           4    11    14   any
          14    17    14   any

```

解锁操作（`monitorexit` 指令）需要确保每一条执行路径（包括异常路径）都有覆盖，因此可以看到一个 `monitorenter` 以及多条 `monitorexit` 指令。

在解锁的时候，JVM 需要强制刷新缓存，使得当前线程所修改的内存对其他线程可见。

> NOTE：如果编译器能够（通过逃逸分析）证明某把锁仅被同一线程持有，那么它可以移除相应的加锁解锁操作。

monitorenter 和 monitorexit 操作的锁对象是隐式的，实例方法中为 this，静态方法则是 Class 实例。

每个锁对象可以看做持有一个锁计数器以及指向持有锁对象的线程的指针：

- 当执行 monitorenter 时：
  - 如果目标锁对象的计数器为 0，那么说明它没有被其他线程所持有。
  - 如果目标锁对象的计数器不为 0，如果是当前线程已持有锁，则计数器 + 1，否则等待获取锁。
- 当 monitorexit 时，Java 虚拟机则需将锁对象的计数器减 1。当计数器减为 0 时，那便代表该锁已经被释放掉了。

上述采用计数的方式，可以很容易的实现锁的重入，而不用重新进行获取锁的操作。

Java 按照代价从小到大，分别使用了偏向锁、轻量锁以及重量级锁的实现，并结合对象的 mark word 使用：

![](https://raw.githubusercontent.com/Rianico/Image/master/ARTS_Tips/Snipaste_2020-11-01_15-47-48.png)

其中 00 代表轻量级锁，01 代表无锁（或偏向锁），10 代表重量级锁，11 则跟垃圾回收算法的标记有关。

#### 3.3.1 偏向锁

偏向锁是一种乐观锁，假设了从头到尾只有一个线程访问同步代码块，线程在加锁的时候，只需要简单的在对象的 mark word 中添加自己的线程 ID，后面就不在需要通过 CAS 来进行加锁以及解锁。

线程在添加偏向锁的时候，还需要判断 mark word 最后 3 位是否为 101，是否包含当前线程的地址，以及 epoch 值是否和锁对象的类的 epoch 值相同。

> NOTE： 每个 Class 都会维护一个 epoch 记录偏向锁的失效次数，设置偏向锁时，JVM 需要将该 epoch 值复制到锁对象的 mark word 中。

如果某一个类的偏向锁总撤销数超过了阈值（`-XX:BiasedLockingBulkRebiasThreshold`，默认 20），那么会触发**批量重偏向**，20 之后的锁对象会偏向新的加锁线程（20 之前的则膨胀为轻量级锁）。

如果某一个类的偏向锁总撤销数超过了阈值（`-XX:BiasedLockingBulkRevokeThreshold`，默认 40），那么 JVM 会触发**批量撤销**，将这个类标记为不再适合偏向锁（1 -> 0），之后锁对象不再重偏向，而是膨胀为轻量级锁，且之后新生成的对象不再添加偏向锁。

> NOTE：撤销偏向锁时，为了保证当前持有偏向锁并且已加锁的线程不丢锁，Java 虚拟机需要遍历所有线程的 Java 栈，找出该类已加锁的实例，并且将它们标记字段中的 epoch 值加 1。该操作需要所有线程处于安全点状态，之后再替换为轻量级锁。

> NOTE：JVM 启动时，偏向锁会有个延迟（`-XX:BiasedLockingStartupDelay`，默认 4000，单位 ms ）后才生效。在 Java10 后被修改为 0，原因是早期的 JVM 启动时会因为偏向锁而产生更多的 safe point，当前的 JVM 已不存在该问题，并且延迟启动只会导致依赖于 mark word 的 GC 算法需要特殊处理偏向锁生效之前生成的对象。详见 [**Change default value of BiasedLockingStartupDelay to 0**](https://bugs.openjdk.java.net/browse/JDK-8181778) & [**JDK-8180421 : Change default value of BiasedLockingStartupDelay to 0**](https://bugs.java.com/bugdatabase/view_bug.do?bug_id=JDK-8180421)。

- 关闭偏向锁：`-XX:-UseBiasedLocking`
- C1 打印各类锁的个数：`-XX:+PrintBiasedLockingStatistics`
- C2 打印各类锁的个数：`-XX:+PrintPreciseBiasedLockingStatistics`
- 只使用 C1 即时编译：`-XX:TieredStopAtLevel=1`

偏向锁升级到轻量级锁的时候，会先暂停原线程，清空锁对象头的线程 ID，再恢复原线程。

#### 3.3.2 轻量级锁

轻量级锁是一种乐观锁，它的假设场景是虽然有多个线程会获取锁，但时间上是错开的，一旦有多个线程竞争锁，那么会立刻膨胀为重量级锁。

当进行加锁操作时，JVM 会先判断是否为重量级锁：

- 如果不是，加锁的线程则会在当前栈帧划分一块区域作为锁记录，并复制需要加锁对象的 mark word 到锁记录里（Displaced Mark Word），然后再将锁对象的 mark word 通过 CAS 替换为指向锁记录的指针。
- 如果是，则进入正常的重量级锁获取过程（自旋、阻塞）。

线程使用 CAS 替换 mark word 时，若发现锁对象的锁标志不为 01，那么有两种情况：

- 该线程重复获取锁，此时会将 0 入栈，表示锁被重复获取。
- 其他线程持有该锁，此时 JVM 会将这把锁膨胀为重量级锁，并阻塞当前线程。

当释放锁时，持有锁的线程会通过 CAS 比较锁对象的标记字段是否为指向自己锁记录的指针：

- 如果是，则将 Displaced Mark Word 替换回锁对象的 mark word 中；
- 如果不是，表示当前锁对象已膨胀为重量级锁，当前线程会执行重量级锁的释放过程，并唤醒阻塞的线程。

#### 3.3.3 重量级锁

在锁被某个线程持有的情况下，重量级锁会直接阻塞申请锁的其他线程，而 Java 线程的阻塞以及唤醒依赖于操作系统，通过 **pthread** 的**互斥锁（mutex）**来实现，涉及系统调用，会产生**用户态-内核态**的切换，因此开销非常高。

为了避免昂贵的线程阻塞、唤醒操作，JVM 会在进入阻塞状态之前，先进行动态自旋（特指空转）轮询尝试获取锁，会消耗部分处理器资源。

自旋状态带来的另一个副作用，就是不公平锁，处于阻塞状态的线程无法立刻竞争释放的锁，而自旋状态的线程则很可能优先获得这把锁。

