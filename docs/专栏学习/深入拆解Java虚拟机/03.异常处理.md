---
title: 03.异常处理
date: 2020-10-04
---

Java 的异常处理涉及了如下三种代码块：

- try：用来标记需要监控的代码。
- catch：捕获 try 中出发的某种类型的异常，可自上而下捕获多种异常，且前面的异常类型不能覆盖后面的异常类型（由小到大）。
- finally：用来声明一段必定运行的代码，运行顺序遵守以下规则：
  - 程序运行正常，则在 try 之后必定运行
  - 程序运行异常，且没有使用 catch 捕获，则运行 finally 后再抛出异常
  - 程序运行异常，进入 catch 代码块捕获，之后必定运行 finally；如果 catch 也抛出异常，则 finally 运行后跑出 catch 块的异常。
  - finally 块抛出异常，则会中断 finally 代码块，并往外抛异常。

所有异常都是 Throwable 类或者其子类的实例：

1. Error：表示异常无法恢复，需要终止线程甚至虚拟机。
2. Expection：程序可能需要捕获并处理。
   - RuntimeException：较为特殊的异常，表示程序无法运行，但仍能尝试处理下。

![](https://static001.geekbang.org/resource/image/47/93/47c8429fc30aec201286b47f3c1a5993.png)

RuntimeException 和 Error 属于 Java 里的**非检查异常（unchecked exception）**。其他异常则属于检查异常（checked exception），需要显示地捕获，或者在方发声明中用 throws 关键字标注。

> NOTE：尽可能使用检查异常，以便最大化利用 Java 编译器的编译时检查。

异常实例的构造十分昂贵，在构造异常实例时，Java 虚拟机便需要生成该异常的**栈轨迹（stack trace）**。该操作会逐一访问当前线程的 Java 栈帧，并且记录下各种调试信息，包括栈帧所指向方法的名字，方法所在的类名、文件名，以及在代码中的第几行触发该异常。

在生成栈轨迹时，Java 虚拟机会**忽略掉异常构造器以及填充栈帧的 Java 方法（Throwable.fillInStackTrace）**，直接从新建异常位置开始算起，同时也不会记录被标记为隐藏的 Java 方法栈帧（e.g. Lambda 表达式）。

**Java 依靠异常表来捕获异常**，编译生成的字节码中，每个方法都附带一个异常表。

异常表中的每一个条目代表一个异常处理器，并且由 **from 指针**、**to 指针**、**target 指针**以及**所捕获的异常类型 type**构成。这些指针的值是**字节码索引（bytecode index，bci）**，用以定位字节码：

- from：监控的字节码起始位置。
- to：监控的字节码结束位置。
- target：发生异常时跳转的目标字节码位置。
- type：监控的异常类型。

```java
public class Foo {
  public Foo();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public void test();
    Code:
       0: aload_0
       1: iconst_0
       2: putfield      #2                  // Field tryBlock:I
       5: aload_0
       6: iconst_2
       7: putfield      #3                  // Field finallyBlock:I
      10: goto          35
      13: astore_1
      14: aload_0
      15: iconst_1
      16: putfield      #5                  // Field catchBlock:I
      19: aload_0
      20: iconst_2
      21: putfield      #3                  // Field finallyBlock:I
      24: goto          35
      27: astore_2
      28: aload_0
      29: iconst_2
      30: putfield      #3                  // Field finallyBlock:I
      33: aload_2
      34: athrow
      35: aload_0
      36: iconst_3
      37: putfield      #6                  // Field methodExit:I
      40: return
    Exception table:
       from    to  target type
           0     5    13   Class java/lang/Exception
           0     5    27   any
          13    19    27   any
}
```

当发生异常时，如果遍历完所有异常类型仍未匹配到，那么它会弹出当前方法对应的 Java 栈帧，并且在调用者（caller）中重复上述操作。**在最坏情况下，Java 虚拟机需要遍历当前线程 Java 栈上所有方法的异常表**。

finally 代码块的编译，是通过复制内容，分别放在 **try-catch 代码块所有正常/异常执行路径上来实现的**。

![](https://static001.geekbang.org/resource/image/17/06/17e2a3053b06b0a4383884f106e31c06.png)

**如果 try/catch 块抛出了异常，finally 也抛出了异常，那么 finally 的异常将会覆盖前面的异常**，避免异常被吞掉的方式就是使用 **Suppressed** 异常，或者 Java 7 引入的 **try-with-resource**。

> NOTE：Suppressed 异常使用起来较为繁琐，推荐使用 try-with-resource，对应的类只需要实现 *java.lang.AutoCloseable* 接口即可。详见 [Java Suppressed Exceptions](https://www.baeldung.com/java-suppressed-exceptions)。





