---
title: 04.反射
date: 2020-10-05
---

Java 中的反射允许正在运行的 Java 程序观测，甚至是修改程序的动态行为，是实现其动态性的一个重要特性。

许多框架往往借助这个特性，从而实现根据配置文件加载不同的类，比如 Spring 的 IOC。

## 1. 反射的实现

```java
public final class Method extends Executable {
  ...
  public Object invoke(Object obj, Object... args) throws ... {
    ... // 权限检查
    MethodAccessor ma = methodAccessor;
    if (ma == null) {
      ma = acquireMethodAccessor();
    }
    return ma.invoke(obj, args);
  }
}
```

`Method.invoke` 会交给 MethodAccessor 进行处理，MethodAccessor 是一个接口，会根据一定的调用阈值（`-Dsun.reflect.inflationThreshold`，默认值 15）来委派给两种不同的实现：

1. 本地实现：通过本地方法来实现反射调用，需要经过 Java 代码 -> C++ 代码 -> Java 代码 的转化，性能较差。
   - Method.invoke -> DelegatingMethodAccessorImpl -> NativeMethodAccessorImpl -> 目标方法。
   - Method 实例拥有具体方法的地址，准备好所需参数，调用进入目标方法。

2. 动态实现：通过动态生成字节码直接使用 invoke 指令来调用目标方法，但生成字节码较为耗时，调用次数较少时本地实现更有优势。
   - 当达到 15 时，便开始动态生成字节码，并将委派实现的委派对象切换至动态实现，这个过程称之为 `Inflation`。

```java
// v1
import java.lang.reflect.Method;

public class Test {
  public static void target(int i) {
    new Exception("#" + i).printStackTrace();
  }

  public static void main(String[] args) throws Exception {
    Class<?> klass = Class.forName("Test");
    Method method = klass.getMethod("target", int.class);
    for (int i = 0; i < 20; i++) {
      method.invoke(null, i);
    }
  }
}

# 使用-verbose:class打印加载的类
$ java -verbose:class Test
...
java.lang.Exception: #0
        at Test.target(Test.java:7)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at Test.main(Test.java:14)
java.lang.Exception: #1
        at Test.target(Test.java:7)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at Test.main(Test.java:14)
...
[Loaded sun.reflect.GeneratedMethodAccessor1 from __JVM_DefineClass__]
java.lang.Exception: #15
        at Test.target(Test.java:7)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at Test.main(Test.java:14)
...
```

可以看到，从第 15 开始，反射便开始使用动态实现。如果要一开始就是用动态实现，则可以通过设置 `-Dsun.reflect.noInflation=true`，关闭委派以及本地实现。

## 2. 反射的开销

`Class.forName`会调用本地方法`Class.getMethod` 会遍历类的公有方法，若没找到，则会在父类中找，反射中这些操作的开销都是比较耗时的。

`getMethod` 为代表的查找方法操作，会**返回查找得到结果的一份拷贝**，通常将其进行缓存，避免浪费堆空间。

### 2.1 Object[] 数组以及自动装拆箱

```java
// v1 代码，开销约为直接调用的 2.7 倍
import java.lang.reflect.Method;

public class Test {
  public static void target(int i) {
    // 空方法
  }

  public static void main(String[] args) throws Exception {
    Class<?> klass = Class.forName("Test");
    Method method = klass.getMethod("target", int.class);

    long current = System.currentTimeMillis();
    for (int i = 1; i <= 2_000_000_000; i++) {
      if (i % 100_000_000 == 0) {
        long temp = System.currentTimeMillis();
        System.out.println(temp - current);
        current = temp;
      }

      method.invoke(null, 128);
    }
  }
}

```

```java
   59: aload_2                         // 加载Method对象
   60: aconst_null                     // 反射调用的第一个参数null
   61: iconst_1
   62: anewarray Object                // 生成一个长度为1的Object数组
   65: dup
   66: iconst_0
   67: sipush 128
   70: invokestatic Integer.valueOf    // 将128自动装箱成Integer
   73: aastore                         // 存入Object数组中
   74: invokevirtual Method.invoke     // 反射调用
```

1. Method.invoke 接收一个可变长参数，因此会生成一个 Object[] 数组。
2. 由于是一个 Object[] 数组，因此需要对传入的 int 类型进行自动装箱，并存入数组中。

这两个操作除了带来性能开销，还会占用堆内存，其中传入的 128 可以通过设置 `-Djava.lang.Integer.IntegerCache.high=128` 来缓解，这时性能开销约为直接调用的 1.8 倍。

### 2.2 逃逸分析

```java
// v2 代码，性能开销约为直接调用的 2.9 倍
import java.lang.reflect.Method;

public class Test {
  public static void target(int i) {
    // 空方法
  }

  public static void main(String[] args) throws Exception {
    Class<?> klass = Class.forName("Test");
    Method method = klass.getMethod("target", int.class);

    Object[] arg = new Object[1]; // 在循环外构造参数数组
    arg[0] = 128;

    long current = System.currentTimeMillis();
    for (int i = 1; i <= 2_000_000_000; i++) {
      if (i % 100_000_000 == 0)  {
        long temp = System.currentTimeMillis();
        System.out.println(temp - current);
        current = temp;
      }

      method.invoke(null, arg);
    }
  }
}
```

对比上一节的代码，手动新建 Object[] 数组并赋值 128，不会占用多余堆空间，GC 上更好，但性能上反而更糟糕了。

在循环体外新建数组，会导致 JIT 无法判断数组是否会被更改，从而无法将其判断为不逃逸。

> NOTE：如果一个对象被判断为不逃逸，那么 JIT 可以选择栈分配甚至是虚拟分配，也就是不占用堆空间。

### 2.3 权限检查及 Inflation

```java
// v3 代码，性能开销约为直接调用的 1.3 倍
import java.lang.reflect.Method;

// 在运行指令中添加如下两个虚拟机参数：
// -Djava.lang.Integer.IntegerCache.high=128
// -Dsun.reflect.noInflation=true
public class Test {
  public static void target(int i) {
    // 空方法
  }

  public static void main(String[] args) throws Exception {
    Class<?> klass = Class.forName("Test");
    Method method = klass.getMethod("target", int.class);
    method.setAccessible(true);  // 关闭权限检查

    long current = System.currentTimeMillis();
    for (int i = 1; i <= 2_000_000_000; i++) {
      if (i % 100_000_000 == 0) {
        long temp = System.currentTimeMillis();
        System.out.println(temp - current);
        current = temp;
      }

      method.invoke(null, 128);
    }
  }
}

```

反射调用方法时会检查目标方法的权限，可以通过关闭权限检查减少开销，同时关闭 Inflation。

### 2.4 方法内联

经过 对象不逃逸、避免自动装拆箱、关闭权限检查、关闭 Inflation 后，反射调用的开销约为直接调用的 1.3 倍，此时的主要瓶颈在于 `Method.invoke` 方法中对 `MethodAccessor.invoke` 方法的调用。

![](https://static001.geekbang.org/resource/image/93/b5/93dec45b7af7951a2b6daeb01941b9b5.png)

在生产环境中，我们往往拥有多个不同的反射调用，对应多个 GeneratedMethodAccessor，也就是动态实现。

JVM 对调用点的**类型 profile** 通常最多保存 2 个（由 `-XX:TypeProfileWidth` 决定，默认值 2），后续的方法类型将不会被内联，同时逃逸分析也不再生效。

> NOTE：于 invokevirtual 或者 invokeinterface，Java 虚拟机会记录下调用者的具体类型，我们称之为类型 profile

```java
// v5版本，性能开销约为直接调用的 6.7 倍
import java.lang.reflect.Method;

public class Test {
  public static void target(int i) {
    // 空方法
  }

  public static void main(String[] args) throws Exception {
    Class<?> klass = Class.forName("Test");
    Method method = klass.getMethod("target", int.class);
    method.setAccessible(true);  // 关闭权限检查
    polluteProfile();

    long current = System.currentTimeMillis();
    for (int i = 1; i <= 2_000_000_000; i++) {
      if (i % 100_000_000 == 0) {
        long temp = System.currentTimeMillis();
        System.out.println(temp - current);
        current = temp;
      }

      method.invoke(null, 128);
    }
  }

  public static void polluteProfile() throws Exception {
    Method method1 = Test.class.getMethod("target1", int.class);
    Method method2 = Test.class.getMethod("target2", int.class);
    for (int i = 0; i < 2000; i++) {
      method1.invoke(null, 0);
      method2.invoke(null, 0);
    }
  }
  public static void target1(int i) { }
  public static void target2(int i) { }
}
```

一旦无法被类型 profile 保存，方法内联与逃逸分析会同时失效，这是导致性能急剧下降的最主要原因。

