---
title: 05.Java对象的内存布局
date: 2020-10-14
---



## 1. 对象的创建

新建对象的几种方式：

- new 和 反射：调用类的构造器。
- Object.clone 和反序列化：复制已有数据。
- Unsafe.allocateInstance：申请一段内存分配对象，但没有初始化实例字段。

Java 对类的构造器限制：

- 如果一个类没有定义任何构造器，Java 编译器会默认添加一个空的构造器。
- 子类的构造器需要调用父类的构造器：
  - 如果父类存在无参构造器，子类会**隐式调用**。
  - 如果父类没有无参构造器，子类必须**显式调用父类带参构造器**。
- 调用一个构造器时，会优先调用父类构造器，直至 Object。
- 子类即使无法访问父类私有非静态字段，仍会为父类私有字段分配内存。

> NOTE：子类即使无法访问父类私有非静态字段，仍需为其分配内存，这是因为**非静态字段**是绑定到类实例的，一个新的实例应该保存一份。

## 2. 对象头及指针压缩

每个 Java 对象都有一个对象头（Object Header），包含以下两点：

- 标记字段（mark word）：存储 JVM 有关该对象的运行数据，如哈希码、GC 信息以及锁信息。
- 类型指针：指向该对象的类。

在 64 位 JVM 中，标记字段占 64 bit，类型指针占 64 bit，其中类型指针可以通过**指针压缩（ -XX:+UseCompressedOops，默认开启）**来减少内存消耗，类型指针会被压缩成 32 位。

指针压缩结合内存对齐（`-XX:ObjectAlignmentInBytes`，默认值 8），每个 Java 对象都会被要求从 8N 的内存地址开始分配，压缩指针时，将其右移三位，解压缩时，将其左移三位，再加上一个固定偏移量（JVM 堆内存的起始地址），便能实现 32 bit 寻址 32GB 地址空间的伪 64 位指针了。 

> NOTE：指针压缩只在 4GB 以上，32G 以下生效。

> NOTE：可以通过增加 `-XX:ObjectAlignmentInBytes` 来提升寻址范围，但同时也会增加对象间填充，达不到节省内存的目的。

> NOTE：当一个对象用不到 8N 的内存空间时，会**填充（padding）**到 8N。如果字段不填充，那么就会出现一个对象横跨两个缓存行的现象，导致伪共享。

## 3. 字段重排序

JVM 会重新分配字段的先后顺序，已达到内存对齐的效果，有三种排列方法（`-XX:FieldsAllocationStyle`，默认值为 1，将会在 JDK14 移除，并以 1 为固定方式），但都遵循如下两个原则：

1. 如果规定一个字段 C 个字节，那么该字段的偏移量需要对齐至 NC。这里偏移量指的是字段地址与对象的起始地址差值。
2. 子类所继承字段的偏移量，需要与父类对应字段的偏移量保持一致。

- 开启指针压缩：子类第一个字段需要对齐至 4N；
- 关闭指针压缩：子类第一个字段则需要对齐至 8N。

```java
class A {
  long l;
  int i；
}

class B extends A {
  long l;
  int i;
}

// 启用压缩指针时，B类的字段分布
B object internals:
 OFFSET  SIZE   TYPE DESCRIPTION
      0     4        (object header)
      4     4        (object header)
      8     4        (object header)
     12     4    int A.i                                       0
     16     8   long A.l                                       0
     24     8   long B.l                                       0
     32     4    int B.i                                       0
     36     4        (loss due to the next object alignment)
     
// 关闭压缩指针时，B类的字段分布
B object internals:
 OFFSET  SIZE   TYPE DESCRIPTION
      0     4        (object header)
      4     4        (object header)
      8     4        (object header)
     12     4        (object header)
     16     8   long A.l
     24     4    int A.i
     28     4        (alignment/padding gap)                  
     32     8   long B.l
     40     4    int B.i
     44     4        (loss due to the next object alignment)
```

> NOTE：字段重排序 mode 1 的排序方式为先父类后子类，先基本类型，再引用类型。