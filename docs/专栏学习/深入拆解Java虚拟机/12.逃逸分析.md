---
title: 12.逃逸分析
date: 2020-11-29
---

逃逸分析：一种确定指针动态范围的静态分析，它可以分析在程序的哪些地方可以访问到指针。

JVM 的 JIT 语境下，逃逸分析会判断**新建**的对象是否**逃逸**，判断的依据有二：

1. 对象是否被存入堆中（静态字段或者堆中对象的实例字段）。
2. 对象是否被传入未知代码中。

一旦满足其中一个条件，则判断对象逃逸。

对于第一点，一旦对象被传入堆中，那么其他线程便能获得该对象的引用，JIT 也因此无法确定该对象的使用范围。

对于第二点，方法中未被内联的方法调用，JIT 会将其当做位置代码，因为无法确定对象传入后会被未知方法存储到堆中。

可以认为，方法调用的调用者以及参数是逃逸的。

通常来说，**即时编译器里的逃逸分析是放在方法内联之后的**，以便消除这些“未知代码”入口。

## 基于逃逸分析的优化

即时编译器可以根据逃逸分析的结果进行以下优化：

- 锁消除（少见）。
- 栈上分配。
- **标量替换**。

关于锁消除，如果 JIT 能够证明锁对象不逃逸，那么对该对象进行加锁是无意义的，从而消除无谓的加锁、解锁操作。

如果逃逸分析能够证明某些新建对象不逃逸，那么 JVM 可以将其分配至栈上，并且在 new 语句所在的方法退出时，弹出栈帧自动回收分配的内存空间。

**HotSpot 虚拟机出于历史原因并没有采用栈上分配**，而是使用了标量替换这么一项技术：

- 标量，仅能存储一个值的变量，比如 Java 代码中的局部变量。
- 聚合量，可能同时存储多个值，比如 Java 对象。

标量替换这项优化技术，可以看成将原本对对象的字段的访问，替换为一个个局部变量的访问。

以 Java 中的 `foreach` 语法糖为例，标量替换优化结果如下：

```java
public void forEach(ArrayList<Object> list, Consumer<Object> f) {
  // Itr iter = new Itr; // 经过标量替换后该分配无意义，可以被优化掉
  // iter.cursor = 0;
  // iter.lastRet = -1;
  // iter.expectedModCount = list.modCount;
  int cursor = 0;     // 标量替换
  int lastRet = -1;   // 标量替换
  int expectedModCount = list.modCount; // 标量替换
  while (cursor < list.size) {
    if (list.modCount != expectedModCount)
      throw new ConcurrentModificationException();
    int i = cursor;
    if (i >= list.size)
      throw new NoSuchElementException();
    Object[] elementData = list.elementData;
    if (i >= elementData.length)
      throw new ConcurrentModificationException();
    cursor = i + 1;
    lastRet = i;
    Object obj = elementData[i];
    f.accept(obj);
  }
}
```

原本需要在堆内存上连续分布的对象，现在只需要一个个单独的 int 字段即可，这些字段可以直接在栈上分配，也可以直接存储在寄存器中，并且省去了对象头信息。

## Graal 中的部分逃逸分析

C2 的逃逸分析与控制流无关，Graal 则引入了一个与控制流有关的逃逸分析，名为**部分逃逸分析（partial escape analysis）**，用于解决**新建的实例仅在部分程序路径中逃逸的情况**。

下面这段代码中，新建实例只会在进入 if-then 分支时逃逸：

```java
public static void bar(boolean cond) {
  Object foo = new Object();
  if (cond) {
    // 对hashCode方法的调用是一个 HotSpot intrinsic，将被替换为一个无法内联的本地方法调用
    foo.hashCode();
  }
}
// 可以手工优化为：
public static void bar(boolean cond) {
  if (cond) {
    Object foo = new Object();
    foo.hashCode();
  }
}
```

如果 `cond` 条件基本不成立，那么大部分场景下不需要 `new Object()`，部分逃逸分析会将其操作推迟到对象逃逸的分支中。

Graal 所使用的部分逃逸分析能够优化更多的情况，不过它编译时间也更长一些。