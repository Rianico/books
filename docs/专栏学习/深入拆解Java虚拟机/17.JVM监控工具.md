---
title: 17.JVM监控和工具
date: 2020-12-20
---

## 1. jps

[jps](https://docs.oracle.com/en/java/javase/11/tools/jps.html#GUID-6EB65B96-F9DD-4356-B825-6146E9EEC81E)：打印所有正在运行的 Java 进程的相关信息。

```shell
$ jps -mlv
18331 org.example.Foo Hello World
18332 jdk.jcmd/sun.tools.jps.Jps -mlv -Dapplication.home=/Library/Java/JavaVirtualMachines/jdk-11.jdk/Contents/Home -Xms8m -Djdk.module.main=jdk.jcmd
```

- -q：输出本地 JVM 进程的 class name, JAR file name 以及传递给 main 方法的参数。
- -m：打印传递给 main 方法的参数。
- -l：打印 main 方法完整的包名，或者 JAR  的完整路径。
- -v：打印传递给 JVM 的参数。
- -V：同 -q。

jps 还可以查看远端机器上的 Java 进程：

```shell
jps -l remote.domain
3002 /opt/jdk1.7.0/demo/jfc/Java2D/Java2Demo.JAR
2857 sun.tools.jstatd.jstatd
```

如果 JVM 关闭了默认开启的 `UserPerData` （-XX:-UsePerfData），则 jps 将无法探测到该 JVM。

## 2. jstat

[jstat](https://docs.oracle.com/en/java/javase/11/tools/jstat.html#GUID-5F72A7F9-5D5A-4486-8201-E1D1BA8ACCB5)：打印目标 Java 进程的性能数据。

```shell
jstat outputOptions [-t] [-h lines] vmid [interval [count] ]
```

- -t：在首列打印出目标 Java 进程的启动时间，单位为 s
- -h：每过 n 行打印一次 header，默认为 0，仅在首行打印一次

其中的 outputOptions 如下：

- -class：打印类加载器的行为统计信息。
- -compiler：打印 JIT 编译器的行为统计信息。
- -gc
- -gccapacity
- -gccause
- -gcmetacapacity
- -gcnew
- -gcnewcapacity
- -gcold
- -gcoldcapacity
- -gcutil
- -printcompilation：打印 JVM 编译方法的统计信息。

```shell
# Usage: jstat -outputOptions [-t] [-hlines] VMID [interval [count]]
$ jstat -gc 22126 1s 4
S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT   
17472,0 17472,0  0,0    0,0   139904,0 47146,4   349568,0   21321,0   30020,0 28001,8 4864,0 4673,4     22    0,080   3      0,270   0      0,000    0,350
17472,0 17472,0 420,6   0,0   139904,0 11178,4   349568,0   21321,0   30020,0 28090,1 4864,0 4674,2     28    0,084   3      0,270   0      0,000    0,354
17472,0 17472,0  0,0   403,9  139904,0 139538,4  349568,0   21323,4   30020,0 28137,2 4864,0 4674,2     34    0,088   4      0,359   0      0,000    0,446
17472,0 17472,0  0,0    0,0   139904,0   0,0     349568,0   21326,1   30020,0 28093,6 4864,0 4673,4     38    0,091   5      0,445   0      0,000    0,536
```

jstat 还可以用于判断是否出现了内存泄漏，每隔一段时间，通过 jstat 获取 OU 的情况，取其最小值，如果这些值随着时间呈上涨趋势，那么意味着无法回收的对象在不断增加，因此很可能出现了内存泄漏。

使用 G1 GC 时，jstat 的输出会存在一些特征：

```shell
$ jstat -gc 22208 1s
S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT    CGC    CGCT     GCT   
0.0   16384.0  0.0   16384.0 210944.0 192512.0  133120.0    5332.5   28848.0 26886.4 4864.0 4620.5     19    0.067   1      0.016   2      0.002    0.084
0.0   16384.0  0.0   16384.0 210944.0 83968.0   133120.0    5749.9   29104.0 27132.8 4864.0 4621.0     21    0.078   1      0.016   2      0.002    0.095
0.0    0.0    0.0    0.0   71680.0  18432.0   45056.0    20285.1   29872.0 27952.4 4864.0 4671.6     23    0.089   2      0.063   2      0.002    0.153
0.0   2048.0  0.0   2048.0 69632.0  28672.0   45056.0    18608.1   30128.0 28030.4 4864.0 4672.4     32    0.093   2      0.063   2      0.002    0.158
...
```

可以看到 S0C、S0U 始终为 0 ，而 S1C、S10 有时会变为 0。

- S0 区域：由于 G1 中不再设置 Eden、Survivor、Old 区的内存边界，而是将对划分为若干个等长内存区域，因此也就没有以前 GC 算法中 FROM、TO 之间的划分了。
- S1 区域：G1 GC 时，可能会出现 Survivor 区内的所有对象都被回收或者晋升的对象，此时内存中完全没有 Survivor 区域。
-  CGC & CGCT：分别代表并发 GC Stop-The-World 的次数和时间。

## 3. jmap

[jmap](https://docs.oracle.com/en/java/javase/11/tools/jmap.html#GUID-D2340719-82BA-4077-B0F3-2803269B7F41)：可以用于分析 Java 虚拟机堆中的对象。

```shell
jmap [options] pid
```

options 如下：

- -clstats，该子命令将打印被加载类的信息。
- -finalizerinfo，该子命令将打印所有待 finalize 的对象。
- -histo，该子命令将统计各个类的实例数目以及占用内存，并按照内存使用量从多至少的顺序排列。此外，-histo:live 只统计堆中的存活对象。
- -dump，该子命令将导出 Java 虚拟机堆的快照。同样，-dump:live只保存堆中的存活对象。

通常使用 `jmap -dump:live,format=b,file=filename.bin` 命令将堆中存活的对象导出到一个文件中。

```shell
$ jmap -histo 22574
 num     #instances         #bytes  class name (module)
-------------------------------------------------------
   1:        500004       20000160  org.python.core.PyComplex
   2:        570866       18267712  org.python.core.PyFloat
   3:        360295       18027024  [B (java.base@11)
   4:        339394       11429680  [Lorg.python.core.PyObject;
   5:        308637       11194264  [Ljava.lang.Object; (java.base@11)
   6:        301378        9291664  [I (java.base@11)
   7:        225103        9004120  java.math.BigInteger (java.base@11)
   8:        507362        8117792  org.python.core.PySequence$1
   9:        285009        6840216  org.python.core.PyLong
  10:        282908        6789792  java.lang.String (java.base@11)
  ...
2281:             1             16  traceback$py
2282:             1             16  unicodedata$py
Total       5151277      167944400
```

jmap 将会访问堆中所有的对象，为了保证此过程不会受到应用程序线程干扰，jmap 需要借助安全点机制，让所有线程停留在不改变堆中数据的状态。

> 如果某个线程长时间无法跑到安全点，jmap将一直等下去。与 jstat 不同，垃圾回收器会主动将jstat所需要的摘要数据保存至固定位置之中，而jstat只需直接读取即可。

## 4. jstack

[jstack](https://docs.oracle.com/en/java/javase/11/tools/jstack.html#GUID-721096FC-237B-473C-A461-DBBBB79E4F6A)：打印目标 Java 进程中各个线程的栈轨迹，以及这些线程所持有的锁。

jstack的其中一个应用场景便是死锁检测：

```shell
$ jstack 31634
...

"Thread-0" #12 prio=5 os_prio=31 cpu=1.32ms elapsed=34.24s tid=0x00007fb08601c800 nid=0x5d03 waiting for monitor entry  [0x000070000bc7e000]
   java.lang.Thread.State: BLOCKED (on object monitor)
 at DeadLock.foo(DeadLock.java:18)
 - waiting to lock <0x000000061ff904c0> (a java.lang.Object)
 - locked <0x000000061ff904b0> (a java.lang.Object)
 at DeadLock$$Lambda$1/0x0000000800060840.run(Unknown Source)
 at java.lang.Thread.run(java.base@11/Thread.java:834)

"Thread-1" #13 prio=5 os_prio=31 cpu=1.43ms elapsed=34.24s tid=0x00007fb08601f800 nid=0x5f03 waiting for monitor entry  [0x000070000bd81000]
   java.lang.Thread.State: BLOCKED (on object monitor)
 at DeadLock.bar(DeadLock.java:33)
 - waiting to lock <0x000000061ff904b0> (a java.lang.Object)
 - locked <0x000000061ff904c0> (a java.lang.Object)
 at DeadLock$$Lambda$2/0x0000000800063040.run(Unknown Source)
 at java.lang.Thread.run(java.base@11/Thread.java:834)

...

JNI global refs: 6, weak refs: 0


Found one Java-level deadlock:
=============================
"Thread-0":
  waiting to lock monitor 0x00007fb083015900 (object 0x000000061ff904c0, a java.lang.Object),
  which is held by "Thread-1"
"Thread-1":
  waiting to lock monitor 0x00007fb083015800 (object 0x000000061ff904b0, a java.lang.Object),
  which is held by "Thread-0"

Java stack information for the threads listed above:
===================================================
"Thread-0":
 at DeadLock.foo(DeadLock.java:18)
 - waiting to lock <0x000000061ff904c0> (a java.lang.Object)
 - locked <0x000000061ff904b0> (a java.lang.Object)
 at DeadLock$$Lambda$1/0x0000000800060840.run(Unknown Source)
 at java.lang.Thread.run(java.base@11/Thread.java:834)
"Thread-1":
 at DeadLock.bar(DeadLock.java:33)
 - waiting to lock <0x000000061ff904b0> (a java.lang.Object)
 - locked <0x000000061ff904c0> (a java.lang.Object)
 at DeadLock$$Lambda$2/0x0000000800063040.run(Unknown Source)
 at java.lang.Thread.run(java.base@11/Thread.java:834)

Found 1 deadlock.
```

可以看到，jstack不仅会打印线程的栈轨迹、线程状态（BLOCKED）、持有的锁（locked …）以及正在请求的锁（waiting to lock …），而且还会分析出具体的死锁。

## 5. jinfo

[jinfo](https://docs.oracle.com/en/java/javase/11/tools/jinfo.html#GUID-69246B58-28C4-477D-B375-278F5F9830A5)：可用来查看目标 Java 进程的参数，如传递给 Java 虚拟机的-X（即输出中的 jvm_args）、-XX参数（即输出中的 VM Flags），以及可在 Java 层面通过System.getProperty获取的-D参数（即输出中的 System Properties）。

```shell
$ jinfo 31185
Java System Properties:

gopherProxySet=false
awt.toolkit=sun.lwawt.macosx.LWCToolkit
java.specification.version=11
sun.cpu.isalist=
sun.jnu.encoding=UTF-8
...

VM Flags:
-XX:CICompilerCount=4 -XX:ConcGCThreads=3 -XX:G1ConcRefinementThreads=10 -XX:G1HeapRegionSize=2097152 -XX:GCDrainStackTargetSize=64 -XX:InitialHeapSize=536870912 -XX:MarkStackSize=4194304 -XX:MaxHeapSize=8589934592 -XX:MaxNewSize=5152702464 -XX:MinHeapDeltaBytes=2097152 -XX:NonNMethodCodeHeapSize=5835340 -XX:NonProfiledCodeHeapSize=122911450 -XX:ProfiledCodeHeapSize=122911450 -XX:ReservedCodeCacheSize=251658240 -XX:+SegmentedCodeCache -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GC

VM Arguments:
jvm_args: -Xlog:gc -Xmx1024m
java_command: org.example.Foo
java_class_path (initial): .
Launcher Type: SUN_STANDARD
```

jinfo还可以用来修改目标 Java 进程的 “manageable” 虚拟机参数（如 HeapDumpAfterFullGC）：

```shell
# 查看 manageable 参数
$ java -XX:+PrintFlagsFinal -version | grep manageable   
     intx CMSAbortablePrecleanWaitMillis           = 100                                    {manageable} {default}
     intx CMSTriggerInterval                       = -1                                     {manageable} {default}
     intx CMSWaitDuration                          = 2000                                   {manageable} {default}
     bool HeapDumpAfterFullGC                      = false                                  {manageable} {default}
     bool HeapDumpBeforeFullGC                     = false                                  {manageable} {default}
     bool HeapDumpOnOutOfMemoryError               = false                                  {manageable} {default}
    ccstr HeapDumpPath                             =                                        {manageable} {default}
    uintx MaxHeapFreeRatio                         = 70                                     {manageable} {default}
    uintx MinHeapFreeRatio                         = 40                                     {manageable} {default}
     bool PrintClassHistogram                      = false                                  {manageable} {default}
     bool PrintConcurrentLocks                     = false                                  {manageable} {default}
java version "11" 2018-09-25
Java(TM) SE Runtime Environment 18.9 (build 11+28)
Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11+28, mixed mode)
```

## 6. jcmd（瑞士军刀）

[jcmd](https://docs.oracle.com/en/java/javase/11/tools/jcmd.html)：可以用于替代前面除了jstat之外的所有命令。

```shell
jcmd [pid | main-class] command...|PerfCounter.print| 
-f filename
```

- pid，Java 进程的 id。
- main-class，jcmd 会将命令发送给所有匹配到该 main 方法类的 Java 进程。
- command，传递给 JVM 的命令才行，可以通过 `jcmd pid help` 查看有效命令。如果 pid 为 0，则命令将会被发送给所有 Java 进程。
- -f，从指定的文件读取并执行命令。

监控项如下：

```shell
# example： jcmd <pid> Compiler.CodeHeap_Analytics
Compiler.CodeHeap_Analytics
Compiler.codecache
Compiler.codelist
Compiler.directives_add
Compiler.directives_clear
Compiler.directives_print
Compiler.directives_remove
Compiler.queue
GC.class_histogram
GC.class_stats
GC.finalizer_info
GC.heap_dump
GC.heap_info
GC.run
GC.run_finalization
VM.class_hierarchy
VM.classloader_stats
VM.classloaders
VM.command_line
VM.dynlibs
VM.flags
VM.info
VM.log
VM.metaspace
VM.native_memory
VM.print_touched_methods
VM.set_flag
VM.stringtable
VM.symboltable
VM.system_properties
VM.systemdictionary
VM.unlock_commercial_features
VM.uptime
VM.version
```

## 7. JMC 与 JFR

[Java Mission Control（JMC)](http://jdk.java.net/jmc/) 是 Java 虚拟机平台上的性能监控工具。它包含一个 GUI 客户端，以及众多用来收集 Java 虚拟机性能数据的插件，如 JMX Console（能够访问用来存放虚拟机各个子系统运行数据的 [MXBeans](https://en.wikipedia.org/wiki/Java_Management_Extensions#Managed_beans)），以及虚拟机内置的高效 profiling 工具 **Java Flight Recorder（JFR）**。

JFR 的性能开销很小，在默认配置下平均低于 1%。与其他工具相比，JFR 能够直接访问虚拟机内的数据，并且不会影响虚拟机的优化，适用于生产环境下满负荷运行的 Java 程序。

当启用时，JFR 将记录运行过程中发生的一系列事件。其中包括 Java 层面的事件，如线程事件、锁事件，以及 Java 虚拟机内部的事件，如新建对象、垃圾回收和即时编译事件：

1. 瞬时事件（Instant Event），用户关心的是它们发生与否，例如异常、线程启动事件。
2. 持续事件（Duration Event），用户关心的是它们的持续时间，例如垃圾回收事件。
3. 计时事件（Timed Event），是时长超出指定阈值的持续事件。
4. 取样事件（Sample Event），是周期性取样的事件。取样事件的其中一个常见例子便是方法抽样（Method Sampling），即每隔一段时间统计各个线程的栈轨迹。如果在这些抽样取得的栈轨迹中存在一个反复出现的方法，那么我们可以推测该方法是热点方法。

开启 JFR 的几种方式：

1. 启动 JVM 时添加 `-XX:StartFlightRecording=xxx` 参数，如下：

   ```shell
   # Time fixed
   # JFR 将会在 Java 虚拟机启动 5s 后（对应delay=5s）收集数据，持续 20s（对应duration=20s）。当收集完毕后，JFR 会将收集得到的数据保存至指定的文件中。
   $ java -XX:StartFlightRecording=delay=5s,duration=20s,filename=myrecording.jfr,settings=profile MyApp
   
   
   # Continuous, dump on exit
   # dumponexit=true 指定 JVM 在退出时保存 JFR 的数据到制定的文件
   $ java -XX:StartFlightRecording=dumponexit=true,filename=myrecording.jfr MyApp
   
   
   # Continuous, dump on demand
   $ java -XX:StartFlightRecording=maxage=10m,maxsize=100m,name=SomeLabel MyApp
   Started recording 1.
   # 上述 JVM 不会在退出时主动保存 JFR 信息，需要使用 jcmd 输出到文件中。
   # Use jcmd 38502 JFR.dump name=SomeLabel filename=FILEPATH to copy recording data to file.
   ...
   ```

   > settings=profile 指定了 JFR 所收集的事件类型。默认情况下，JFR 将加载配置文件*JDK/lib/jfr/default.jfc*，并识别其中所包含的事件类型。当使用了 settings=profile 配置时，JFR 将加载配置文件 *JDK/lib/jfr/profile.jfc*。该配置文件所包含的事件类型要多于默认的 default.jfc，因此性能开销也要大一些（约为 2%）。default.jfc以及profile.jfc均为 XML 文件。

2. 使用 jcmd 开启 JFR，有 JFR.start、JFR.dump 和 JFR.stop 三种命令：

   ```shell
   
   $ jcmd <PID> JFR.start settings=profile maxage=10m maxsize=150m name=SomeLabel
   
   $ jcmd <PID> JFR.dump name=SomeLabel filename=myrecording.jfr
   
   $ jcmd <PID> JFR.stop name=SomeLabel
   ```

   更详细的方法见 [帮助文档](https://docs.oracle.com/javacomponents/jmc-5-5/jfr-runtime-guide/comline.htm#JFRRT185)。

3. 使用 JMC 中的 JFR 插件，在图形界面中连接上 Java 进程后，便可以通过图形界面开启 JFR。

   ![](https://static001.geekbang.org/resource/image/39/16/395900f606fd93570196a6dcbac75e16.png)

   

   ![](https://static001.geekbang.org/resource/image/31/6a/31f86bc1cafc569f51e0364d716cab6a.png)