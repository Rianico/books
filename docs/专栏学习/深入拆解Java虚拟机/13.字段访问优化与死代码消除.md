---
title: 13.字段访问优化与死代码消除
date: 2020-12-05
---

逃逸分析的标量替换并不是银弹，当方法因为一些原因无法彻底内联，或者 Java 对象本身是逃逸的，针对字段访问的优化便很重要。

因此，Java 还采取了以下几种优化：

- 字段读取优化
- 字段存储优化
- 死代码消除

## 1. 字段读取优化

JIT 会优化实例字段以及静态字段访问，沿着控制流，缓存各个**字段存储节点**将要存储的值，或者**字段读取节**点所得到的值，减少字段访问，以减少字段读取（总的内存访问）数目次数。

### 1.1 字段读取节点

```java
static int bar(Foo o, int x) {
  int y = o.a + x;
  return o.a + y;
}
// 缓存字段读取节点的字段，减少内存访问：
static int bar(Foo o, int x) {
  int t = o.a;
  int y = t + x;
  return t + y;
}
```

当即时编译器遇到对同一字段的读取节点时，如果缓存值还没有失效，那么它会将读取节点替换为该缓存值。

### 1.2 字段存储节点

```java
static int bar(Foo o, int x) {
  o.a = x;
  return o.a;
}
// 缓存字段存储节点将要存储的值，直接返回缓存值，减少一次内存访问：
static int bar(Foo o, int x) {
  o.a = x;
  return x;
}
```

当 JIT 遇到对同一字段的存储节点时，它会更新所缓存的值。当即时编译器遇到可能更新字段的节点时（方法调用、内存屏障、加锁解锁等），那么会采取保守策略，直接舍弃所有缓存值。

volatile 的内存屏障，会阻止编译器将内存屏障之前缓存的值，用于内存屏障之后的读取节点之上，这是因为语义上需要重新去主存获取最新值，造成了需要更新字段的情况。

同样的，加锁、解锁操作也同样会阻止即时编译器的字段读取优化。

## 2. 字段存储优化

JIT 还能消除冗余的存储节点，如果一个字段先后被存储了两次，且两次存储之间没有对第一次存储值的使用，那么编译器可以消除第一次存储：

```java
void bar() {
  a = 1;
  a = 2;
}
// 优化为：
void bar() {
  a = 2;
}
```

即便是在这两个字段存储操作之间读取该字段，即时编译器还是有可能在字段读取优化的帮助下，将第一个存储操作当成冗余存储给消除掉：

```java
class Foo {
  int a = 0;
  void bar() {
    a = 1;
    int t = a;
    a = t + 2;
  }
}
// 优化为
class Foo {
  int a = 0;
  void bar() {
    a = 1;
    int t = 1;
    a = t + 2;
  }
}
// 进一步优化为
class Foo {
  int a = 0;
  void bar() {
    a = 3;
  }
}
```

> NOTE：如果存储字段被标记为 volatile，那么便无法消除冗余存储。

这种场景虽然看似不会犯，但是实际场景中并不少见，比如说两个存储之间隔着许多其他代码，或者因为方法内联的缘故，将两个存储操作（如构造器中字段的初始化以及随后的更新）纳入同一个编译单元里。

## 3. 死代码消除

除了字段存储优化之外，**局部变量的死存储（dead store）**同样也涉及了冗余存储，但借助 Sea-of-Nodes IR 的特性，死存储的优化无须额外代价：

```java
int bar(int x, int y) {
  int t = x*y;
  t = x+y;
  return t;
}
// 优化为：
int bar(int x, int y) {
  return x+y;
}
```

由于 `int t = x*y` 并没有被依赖，因此 IR 图会直接将其消除。

死存储的另一种变体，即在**部分程序路径上有冗余存储**：

```java
int bar(boolean f, int x, int y) {
  int t = x*y;
  if (f)
    t = x+y;
  return t;
}
// 优化为：
int bar(boolean f, int x, int y) {
  int t;
  if (f)
    t = x+y;
  else
    t = x*y;
  return t;
}
```

当 f 为 true 时， `x*y` 便是冗余的，经过 Sea-of-Nodes IR 转换之后，返回节点所依赖的值是一个 phi 节点，将优化为根据程序路径选择x+y或者x*y。

还有一种死代码消除则是不可达分支消除：

```java
int bar(int x) {
  if (false)
    return x;
  else
    return -x;
}
// 优化为：
int bar(int x) {
  return -x;
}
```

### 4. 总结

JIT 将沿着控制流缓存字段存储、读取的值，并在接下来的字段读取操作时直接使用该缓存值，但要求存储缓存值与使用缓存值之间没有**方法调用**、**内存屏障**，或者**其他可能存储该字段的节点**。

JIT 还会优化冗余的字段存储操作。如果一个字段的**两次存储之间没有对该字段的读取操作**、**方法调用**以及**内存屏障**，那么即时编译器可以将第一个冗余的存储操作给消除掉。

死代码消除主要借助 IR 图的特性：

- **局部变量死存储**消除以及**部分死存储**消除。
- 不可达分支消除，可以精简数据流，并且减少编译时间以及最终生成机器码的大小。

