---
title: 11.HotSpot的intrinsic
date: 2020-11-28
---

intrinsic 从 JDK 9 开始正式引入（JDK 8 只有少量），通过 `@HotSpotIntrinsicCandidate` 标记。

HotSpot 虚拟机将为 `@HotSpotIntrinsicCandidate` 注解的方法额外维护了一套高效实现。

intrinsic  主要是直接利用处理器的指令来实现比源码更高效的运行方式，当处理器有对应的指令支持时，会忽略 JDK 源码，转而使用高效实现。

比如查看 int 相加是否溢出，intrinsic  会直接访问寄存器的溢出标识位（overflow flag）来判断是否溢出，伪代码如下：

```java
public static int addExact(int x, int y) {
    int r = x + y;
    jo LABEL_OVERFLOW; // jump if overflow flag set
    return r;
    LABEL_OVERFLOW:
      throw new ArithmeticException("integer overflow");
      // or deoptimize
}
```

## intrinsic 与方法内联

HotSpot 虚拟机中，intrinsic 的实现方式分为两种：

- 独立的程序桩，可以被解释执行器利用，直接替换对原方法的调用；也可以被即时编译器所利用，它把代表对原方法的调用的 IR 节点，替换为对这些桩程序的调用的 IR 节点。以这种形式实现的 intrinsic 比较少，主要包括 Math 类中的一些方法。

- 特殊的编译器 IR 节点，只能够被 JIT 利用，JIT 会对将原方法的 IR 节点替换成特殊的 IR 节点，并参与接下来的优化过程。最终，即时编译器的后端将根据这些特殊的 IR 节点，生成指定的 CPU 指令。

大部分的 intrinsic 都是通过第二种方式实现的。这个替换过程是在方法内联时进行的。当即时编译器碰到方法调用节点时，它将查询目标方法是不是 intrinsic，**如果是，则插入特殊的 IR 节点，否则进行原本的内联工作**。

**不少被标记为 intrinsic 的方法都是 native 方法**。原本对这些 native 方法的调用需要经过 JNI（Java Native Interface），其性能开销十分巨大。但是，经过即时编译器的 intrinsic 优化之后，这部分 JNI 开销便直接消失不见，并且最终的结果也十分高效。

但与此同时，这部分代码对于内联来说属于未知代码，此时**并不会对齐进行内联操作**。

