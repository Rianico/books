---
title: 08.即时编译
date: 2020-11-15
---

HotSpot 虚拟机包含多个即时编译器 C1、C2 和 Graal（实验性质，用于替换 C2，介绍见 [Introduction to Graal](https://zhengyudi.github.io/2018/03/20/graal-intro/)）。

## 1. 分层编译

Java 7 之前，需要根据场景要求选择编译器：对于执行时间较短的，或者对启动性能有要求的程序，选择编译效率较快的 C1，对应参数 -client；对于程序性能峰值有要求的，则采用生成的代码执行效率较快的 C2，对应参数 -server。

Java 7 开始引入**分层编译**（`-XX:+TieredCompilation`），综合使用了 C1 以及 C2。

分层编译将 JVM 的执行状态分为了 5 层：

- level 0：interpreter 解释执行，会进行 profiling。
- level 1：执行不带 profiling 的 C1 代码（最终状态）。
- level 2：执行仅带**方法调用次数**及**循环回边次数**（`back-edge`）的 profiling。
- level 3：执行带所有 profiling 的 C1 代码。
- level 4：C2编译（最终状态）。

> NOTE：level 2 的 profiling 除了包含 level 1 的 profiling 之外，还包括 branch（针对分支跳转字节码）及receiver type（针对成员方法调用或类检测，如 checkcast，instnaceof，aastore 字节码）的 profiling。

通常情况下，C2 代码的执行效率要比 C1 代码的高出 30% 以上；C1 代码中的 level 1 性能比 level 2 略高，而 level 2 则比 level 2 高出 30%。

> NOTE：profiling 是指在程序执行过程中，收集能够反映程序执行状态的数据，如代码执行次数，循环次数等。

以下面代码编译路径为例：

![](https://static001.geekbang.org/resource/image/c5/e5/c503010c157b7db7596893633b624fe5.png)

- 通常情况下，热点方法会被 level 3 的 C1 编译，然后再被 4 层的 C2 编译。

- 如果方法字节码数目较少（如 `getter/setter`），而且 level 3 没有可收集的 profiling，JVM 则会在 C1 的第 level 3 编译后，直接选用 C1 的 level 1 编译。

- C1 无法编译的时候，会在解释执行收集所有的 profiling，然后使用 level 4 的 C2 编译。
- C2 忙碌的时候，会先经过 C1 的 level2、level 3 编译，之后 C2 编译的时候可以节省时间。

> NOTE：Java 8 默认开启了分层编译，client/server 不再生效，如果想要使用 client 方式，则需要强制指定编译层数：-XX:TieredStopAtLevel=1。

## 2. 即时编译的触发

JVM 会根据**方法的调用次数**以及**循环回边的执行次数**来触发即时编译。

循环回边是一个控制流图中的概念，以下面代码为例：

```java
public static void foo(Object obj) {
  int sum = 0;
  for (int i = 0; i < 200; i++) {
    sum += i;
  }
}

// 生成的字节码
public static void foo(java.lang.Object);
  Code:
     0: iconst_0
     1: istore_1
     2: iconst_0
     3: istore_2
     4: goto 14
     7: iload_1
     8: iload_2
     9: iadd
    10: istore_1
    11: iinc 2, 1
    14: iload_2
    15: sipush 200
    18: if_icmplt 7
    21: return
```

上面字节码中，**循环头**是偏移量 14 的字节码，**循环尾部**为偏移量 11 的字节码。

**循环尾部到循环头部的控制流边就是真正意义上的循环回边**，C1 会在这个位置插入增加循环回边计数器的代码。

不启用分层编译时，当方法的调用次数和循环回边的次数的和，超过由参数 `-XX:CompileThreshold` 指定的阈值时（使用 C1 时，该值为 1500；使用 C2 时，该值为 10000），便会触发即时编译。

启用分层编译时，即时编译的触发阈值则是动态调整的，JVM 会将阈值与某个系数 s 相乘。该系数与当前待编译的方法数目成正相关，与编译线程的数目成负相关：

系数的计算方法为：`s = queue_size_X / (TierXLoadFeedback * compiler_count_X) + 1`。

- X 是执行层次，可取3或者4；
- `queue_size_X` 是执行层次为 X 的待编译方法的数目；
- `TierXLoadFeedback` 是预设好的参数，其中 `Tier3LoadFeedback` 为 5，`Tier4LoadFeedback` 为 3；
- `compiler_count_X` 是层次 X 的编译线程数目。

在 64 位 Java 虚拟机中，默认情况下编译线程的总数目是根据处理器数量来调整的（`-XX:+CICompilerCountPerCPU`，默认为 true）：

```java
// 对于四核及以上的机器，总的编译线程如下，N 为 CPU 核心数目。
n = log2(N) * log2(log2(N)) * 3 / 2
```

可通过 `-XX:+CICompilerCount=N` 强制指定线程数目；C1 与 C2 会按照 1:2 的比例分配线程。

启用分层编译时，JIT 的触发需要满足以下其中一个条件：

- 方法调用次数大于 `-XX:TierXInvocationThreshold` * 系数；
- 方法调用次数大于  `-XX:TierXMINInvocationThreshold` * 系数，并且方法调用次数和循环回边次数之和大于 `-XX:TierXCompileThreshold` * 系数，便会触发 X 层的即时编译。

即 `i > TierXInvocationThreshold * s || (i > TierXMinInvocationThreshold * s && i + b > TierXCompileThreshold * s)`。

其中 i 为调用次数，b 为循环回边次数，可以看出，决定一个热点方法有两个因素：①方法的调用次数；②循环回边的执行次数。

**Q：为什么要维护两种计数器？**

JVM 中除了以方法为单位的即时编译外，还存在以循环为单位的即时编译 **OSR**，用于在程序的执行过程中，动态地替换掉 Java 方法栈桢，从而使得程序**能够在非方法入口处进行解释执行和编译后的代码之间的切换**。去优化使用的也是这种技术。

> NOTE：OSR 在正常程序较少见，一般只存在于基准测试，以及用来解决单次调用方法包含热循环的性能优化问题。

当发生去优化时，之前出现过的编译会被标记 “made not entrant"，表示该方法不能再被进入，但所有线程都退出该编译后的 “made not entrant” 是，改方法会被标记为 “made zombie”，此时这块代码就可以回收了。

## 3. 详解 profiling

分层编译中的 0 层、2 层和 3 层都会进行 profiling，收集能够反映程序执行状态的数据。

0 层和 3 层还会收集用于 4 层 C2 编译的数据，比如说分支跳转字节码的分支 profile（branch profile），包括跳转次数和不跳转次数，以及非私有实例方法调用指令、强制类型转换 checkcast 指令、类型测试 instanceof 指令，和引用类型的数组存储 aastore 指令的类型 profile（receiver type profile）。

> NOTE：分支 profile 和类型 profile 的收集会带来不少的性能开销，这也是 C1 第 3 层的代码比第 2 层低 30% 的原因。

解释执行通常不会收集分支 profile 和类型 profile，除非 C1 待编译的代码数目太多。

通常来说，C1 编译后的代码，JVM 认为该代码有可能被 C2 编译，才会开始在 C1 中开始收集 profile。

C2 会根据这些收集的 profile 进行假设，从而做出比较激进的优化。

### 3.1 基于分支 profile 的优化

以下面分支为例：

![](https://static001.geekbang.org/resource/image/53/0e/53d57c8c7645d8e2292a08ee97557b0e.png)

如果收集的 profile 信息是一直是走 true 分支，那么 C2 可以根据这个做出假设，基于这个假设，C2 便不再编译这两个分支条件的 false 分支了，一旦第一个分支通过，则立即返回 0：

![](https://static001.geekbang.org/resource/image/d9/9a/d997a7ea02b7f85136974a54dce7589a.png)

根据条件跳转指令的分支 profile，JIT 可以将从未执行过的分支剪掉，以避免编译这些很有可能不会用到的代码，从而节省编译时间以及部署代码所要消耗的内存空间，同时，精简过后的数据流还可以因此进一步做出更多优化。

### 3.2 基于类型 profile 的优化

类型 profile 涉及了 instanceof 以及方法调用的参数类型。

在 JVM 中，如果 instanceof 的目标类型是 **final 类型**，那么 JVM 仅需要比较测试对象的动态类型是否为该 final 类型（Java 对象的对象头会存储其动态类型，获取对象的动态类型仅为单一的内存读指令）；否则需要自下而上，依次测试该类，该类的父类、祖先类，该类所直接实现或者间接实现的接口是否与目标类型一致。

如下代码：

```java
public static int hash(Object in) {
  if (in instanceof Exception) {
    return System.identityHashCode(in);
  } else {
    return in.hashCode();
  }
}
// 编译而成的字节码：
public static int hash(java.lang.Object);
  Code:
     0: aload_0
     1: instanceof java/lang/Exception
     4: ifeq          12
     7: aload_0
     8: invokestatic java/lang/System.identityHashCode:(Ljava/lang/Object;)I
    11: ireturn
    12: aload_0
    13: invokevirtual java/lang/Object.hashCode:()I
    16: ireturn
```

分支如下：

![](https://static001.geekbang.org/resource/image/2c/77/2c13a1af8632a2bbf77338e57c957b77.png)

如果收集的类型 profile 一直为 Integer 类型，那么编译器会假设接下来的类型都为 Inetger，执行接下来的代码（Graal 的优化），之后会 JIT 会采用针对分支 profile 的优化，以及对方法调用的条件去**虚化内联**，直接返回 Integer 的 value：

![](https://static001.geekbang.org/resource/image/ef/b6/ef02474d3474e96c6f55b07493652fb6.png)

=》

![](https://static001.geekbang.org/resource/image/53/be/53e470037dd49d3d27695a5174fc3dbe.png)

基于类型 profile 的优化同样也是作出假设，从而精简控制流以及数据流。这两者的核心都是假设。

对于分支 profile，JIT 假设的是仅执行某一分支；对于类型 profile，JIT 假设的是对象的动态类型仅为类型 profile 中的那几个。

### 3.3 去优化

当前面的优化假设失败的时候，JVM 会执行去优化，从 JIT 生成的机器码切换回解释执行。

JIT 在生成的机器码中，会在假设失败的位置插入一个 trap，trap 是一条 call 指令，会调用 JVM 中专门用于去优化的方法，去优化方法将更改栈上的返回地址，并不再返回即时编译器生成的机器码中。

去优化的过程相当复杂，**需要将当前机器码的执行状态转换至某一字节码之前的执行状态，并从该字节码开始执行**。这便要求即时编译器在编译过程中记录好这两种执行状态的映射。

> NOTE：以逃逸分析为例，机器码可能并没有实际分配对象，而是在各个寄存器中存储该对象的各个字段（标量替换）。去优化时，JVM 需要还原出这个对象，以便解释执行时能够使用该对象。

建立好映射后，JVM 便会使用 OSR 技术，动态替换栈上的内容，并在目标字节码处开始解释执行。

去优化后 ，JIT 生成的机器码会根据原因来决定是否保留这一份机器码以及何时重新编译对应的 Java 方法：

- 如果去优化的原因与优化无关，即使重新编译也不会改变生成的机器码，那么生成的机器码可以在调用去优化方法时传入 `Action_None`，表示保留这一份机器码，在下一次调用该方法时重新进入这一份机器码。
- 如果去优化的原因与静态分析的结果有关，例如类层次分析，那么生成的机器码可以在调用去优化方法时传入 Action_Recompile，表示不保留这一份机器码，但是可以不经过重新 profile，直接重新编译。
- 如果去优化的原因与基于 profile 的激进优化有关，那么生成的机器码需要在调用去优化方法时传入 Action_Reinterpret，表示不保留这一份机器码，而且需要重新收集程序的 profile。

## 4. JIT 的中间表达形式

编译器通常分为前端和后端：

- 前端：对所输入的程序进行词法分析、语法分析、语义分析，然后生成中间表达形式 IR（Intermediate Representation ）。
- 后端：对 IR 进行优化，然后生成目标代码。

JVM 略有不同，Java 代码到机器码的实际上经过了两轮编译：Java 编译器编译为字节码；JIT 将字节码编译为机器码。

Java 字节码剥离了很多高级的 Java 语法，而且其采用的基于栈的计算模型非常容易建模，因此 Java 字节码可以看成一种 IR。

Java 字节码并不适合直接作为可供优化的 IR，这是因为现代编译器一般采用静态单赋值（Static Single  Assignment，SSA）IR。这种 IR 的特点是每个变量只能被赋值一次，而且只有当变量被赋值之后才能使用。

因此 JIT 还会将 Java 字节码转换成 SSA IR，可以看成是一张包含控制流和数据流的 IR 图，每个字节码对应其中的若干个节点（注意，有些字节码并没有对应的 IR 节点）。之后 JIT 在 IR 图上面进行优化。

> NOTE：SSA IR 可以用于冗余赋值、常量折叠（constant folding）、常量传播（constant propagation）、强度削减（strength reduction）以及死代码删除（dead code elimination）等。

### 4.1  Sea-of-nodes

HotSpot 里的 C2 采用的是一种名为 Sea-of-Nodes 的 SSA IR，其最大特点为去除了变量的概念，直接采用变量所指向的值，来进行运算。