---
title: 09.Java字节码
date: 2020-11-21
---

Java 字节码是 JVM 所用的指令集，与 JVM 基于栈的计算机模型密不可分。

## 1. 基础指令

解释执行过程中，JVM 为方法分配栈帧时，会做以下两个操作：

- 开辟一块内存空间作为操作数栈，存放计算的操作数以及结果。
- 局部变量表。

### 1.1 操作数栈

不同的指令会消耗操作数栈不同数目的栈顶，有些指令还可以直接作用在操作数栈。

**dup** ：复制栈顶元素，常用于**复制 new 指令所生成的未经初始化的引用**：

```java
  public void foo() {
    Object o = new Object();
  }
  // 对应的字节码如下：
  public void foo();
    0  new java.lang.Object [3]
    3  dup
    4  invokespecial java.lang.Object() [8]
    7  astore_1 [o]
    8  return
```

dup 出来的元素通过 invokespecial 调用了构造器（同时作为调用者以及传入的参数）， 会消耗操作数栈上的元素。

> NOTE：构造器是没有返回值的。

**pop**：舍弃栈顶元素，该指令用于舍弃调用指令的返回结果：

```java
  public static boolean bar() {
    return false;
  }

  public void foo() {
    bar();
  }
  // foo方法对应的字节码如下：
  public void foo();
    0  invokestatic FooTest.bar() : boolean [24]
    3  pop
    4  return
```

pop 只能处理非 long 或者 double 类型的值，这是由于 long 与 double 占用了两个栈帧。这两个类型的元素可以使用 dup2 以及 pop2 处理。

**swap**：用于交换栈顶两个元素。

----

Java 字节码中，有一部分指令可以直接将常量加载到操作数栈上。

以 int 类型为例：

- iconst ：加载 -1 至 5 之间的 int 值。
- bipush：加载一个字节所能代表的 int 值。
- sipush ：加载两个字节所能代表的 int 值。

JVM 还可以通过 ldc 直接加载常量到操作数栈上，如 ldc #18 将加载常量池中的第 18 项。

各个类型的指令如下：

![](https://static001.geekbang.org/resource/image/0d/8f/0dfbecf954660bcdc76eac65beac1e8f.jpg)

### 1.2 局部变量表

Java 方法栈桢的另外一个重要组成部分则是局部变量区，字节码程序可以将计算的结果缓存在局部变量区之中。

JVM 会将局部变量表当做数组，依次存放 this 指针（仅非静态方法），所传入的参数，以及字节码中的局部变量。

> NOTE：long 类型以及 double 类型的值将占据两个单元，其余类型占据一个单元。

```java
public void foo(long l, float f) {
  {
    int i = 0;
  }
  {
    String s = "Hello, World";
  }
}
```

局部变量表存放如下：

![](https://static001.geekbang.org/resource/image/22/d9/228d0f5f2d6437e7aca87c6df2d01bd9.png)

其中 i、s 两个变量的生命周期没有重合之处，因此，Java 编译器可以将其编排至同一单元中，可能为两者之一。

### 1.3 操作数栈与局部变量表

局部变量表的加载、存储都需要指定下标，例如，`aload 0` 指的是加载第 0 个单元所存储的引用，在构造函数中就是 this 指针。

不同数据类型的加载、存储指令如下：

![](https://static001.geekbang.org/resource/image/83/f9/83ece83ecd260c2eda282747467e49f9.jpg)

> NOTE：Java 字节码中唯一能**直接作用**于局部变量表的指令只有 **iinc M N**，将第 M 个单元中的 int 值增加 N，常用与 for 循环中自增量的更新。

## 2. 高级指令

### 2.1 高层语义

- new：后跟目标类，生成该类的未初始化的对象。
- instanceof：后跟目标类，判断栈顶元素是否为目标类 / 接口的实例。是则压入 1，否则压入 0。
- checkcast：后跟目标类，判断栈顶元素是否为目标类 / 接口的实例。如果不是便抛出异常。
- athrow：将栈顶异常抛出。
- monitorenter/monitorexit：为栈顶对象加锁/解锁。

---

- getstatic、putstatic：静态字段访问指令。
- getfield、putfield：实例字段访问指令。

> NOTE：字段访问指令均附带用以定位目标字段的信息，但所消耗的操作数栈元素皆不同。

---

方法调用指令：invokestatic，invokespecial，invokevirtual，invokeinterface 以及 invokedynamic。

除 invokedynamic 外，其他的方法调用指令所消耗的操作数栈元素是根据**调用类型**以及**目标方法描述符**来确定的。

进行方法调用前，程序需要先压入调用者（invokestatic 不需要）以及各个参数：

```java
  public int neg(int i) {
    return -i;
  }

  public int foo(int i) {
    return neg(neg(i));
  }
  // foo方法对应的字节码如下：foo方法对应的字节码如下：
  public int foo(int i);
    0  aload_0 [this]
    1  aload_0 [this]
    2  iload_1 [i]
    3  invokevirtual FooTest.neg(int) : int [25]
    6  invokevirtual FooTest.neg(int) : int [25]
    9  ireturn
```

### 2.2 数组相关指令

- newarray：新建基本类型数组。
- anewarray：新建引用类型数组。
- multianewarray：生成多维数组。
- arraylength：获取数组长度。
- 数组加载/存储指令，区分类型：

![](https://static001.geekbang.org/resource/image/5d/1f/5d935dcdd55e9f8461a6e5b0ac22001f.jpg)

> NOTE：int 数组的加载指令为 iaload，图中有误。

### 2.3 控制流指令

- goto：无条件调整指令。

- 条件跳转指令。

- tableswitch、lookupswtich：密集、稀疏 cases。

- return：返回指令，区分类型：

  ![](https://static001.geekbang.org/resource/image/f5/f0/f5195b5425a9547af9ce8371aef5c4f0.jpg)

## 3. 总结

Java 方法的栈帧分为操作数栈以及局部变量表。大部分情况下，操作数栈需要从局部变量表获取变量，进行一番计算后再存储回局部变量表。

不同类型的指令有所区别。

指令查阅：[Chapter 6. The Java Virtual Machine Instruction Set](https://docs.oracle.com/javase/specs/jvms/se10/html/jvms-6.html#jvms-6.5)。