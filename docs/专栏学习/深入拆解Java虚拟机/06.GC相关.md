---
title: 06.GC相关
date: 2020-10-18
---



Java 采用**可达性分析算法**来标记垃圾，这个算法将一系列 GC Roots 作为初始的**存活对象集合（live set）**，然后从该集合出发，探索该集合的引用链，并将链上的对象都加入该集合，这个过程也称为**标记（mark）**。未被标记的集合将会被当做垃圾回收。

GC Roots：

- Java 方法栈帧中的局部变量；
- 已加载类的静态变量；
- JNI handles；
- 已启动且未停止的 Java 线程（多线程下容易出现内存泄漏的场景之一）。

![](https://static001.geekbang.org/resource/image/85/b9/8546a9b3c6660a31ae24bef0ef0a35b9.png)

可达性分析算法在实践中需要解决一些问题，在多线程环境下，标记可能存在：

- 误报：某个被引用的对象在标记过后，又被其他线程将其引用修改为 null。
- 漏报：某个对象被标记为垃圾后，又被其他线程引用了。

误报尚可接收，只不过失去了一次回收的机会，而漏报则会导致实质上引用的对象被回收，造成不可预期的错误。

## 1. Stop-the-world 以及安全点

传统的 GC 算法采用一种简单粗暴的算法：Stop-the-world，停止其他非垃圾回收线程的工作，直到 GC 完成。

Stop-the-world 是通过**安全点（safepoint）**机制来实现的，当需要 GC 时，会等待所有线程到达安全点，然后才允许 GC 线程执行一些独占的操作。

> NOTE：安全点本身的目的并不是让其他线程停止，而是找到一个稳定的执行状态，这个状态下，JVM 的堆栈不会发生变化。

比如 Java 通过 JNI 的 API 执行本地代码，这段本地代码不访问 Java 对象、调用  Java 代码或者返回至原 Java 代码，那么这段本地代码就可以作为一个安全点，同时这个 API 的入口处也可以进行安全点监测（safepoint poll），测试是否有其他线程请求停留在安全点里，可以在必要的时候挂起该线程。

除了**执行 JNI 本地代码**外，Java 线程还有其他几种状态：

- **线程阻塞**：此时处于 JVM 线程调度器的掌控下，因此属于安全点。
- **解释执行字节码**：字节码与字节码之间皆可以作为安全点，当有安全点请求时，执行一条字节码便进行一次安全点检测。
- **执行即时编译器生成的机器码**：由于 JIT 生成的机器码是直接在底层硬件执行，不受 JVM 掌控，因此 JVM 采取的做法是在**生成代码的方法出口**以及**非计数循环回边（back-edge）处**插入安全点检测。

不每条机器码都插入安全点的原因：

1. 安全点本身也有一定的开销，JVM 中已经将机器码中安全点检测简化为一个内存访问操作。当有安全点请求时，JVM 会将安全点对应的内存设置为不可读，并设置一个 segfault 处理器，截获访问该不可读内存的的线程并挂起。
2. 即时编译器生成的机器码打乱了原本栈桢上的对象分布状况。在进入安全点时，机器码还需提供一些额外的信息，来表明哪些寄存器，或者当前栈帧上的哪些内存空间存放着指向对象的引用，以便垃圾回收器能够枚举 GC Roots。

避免机器码长时间不进入安全点的情况，可以减少垃圾回收的暂停时间。

**计数循环默认没有安全点**，当需要 GC 时，如果循环体需要耗费较长时间，那么第一次 GC 时就会迟迟不进入安全点，从而导致莫名的长时间停顿。

GC 日志是不会打印出进入安全点耗时，可以通过 `-XX:+PrintGCApplicationStoppedTime`  将 JVM 的停顿时间（包括 GC 以及 进入安全点等）打印出来：

```java
Total time for which application threads were stopped: 6.1575928 seconds, Stopping threads took: 6.1519059 seconds
```

同时还可以通过 `-XX:+PrintSafepointStatistics -XX:PrintSafepointStatisticsCount=1` 打印安全点耗时统计：

```java
         vmop                    [threads: total initially_running wait_to_block]    [time: spin block sync cleanup vmop] page_trap_count
0.458: ParallelGCFailedAllocation       [      12          1              1    ]      [  6151     0  6151     0     2    ]  0
```

- 0.458：JVM 启动后经过的时间；
- vmop：JVM 的操作类型，此处为 GC；
- threads：
  - total：JVM 内的线程数；
  - initially_running：发起进入安全点信号时，还处于 RUNNING 状态的线程；
  - wait_to_block：所有线程都不Running时，仍不是Block状态的线程数
- time：
  - spin：VMOP 线程自旋等待直到所有线程都不处于 RUNNING 的耗时；
  - block：VMOP   线程基于锁，等待所有线程处于 BLOCK 的耗时；
  - sync：spin + block，进入安全点的总耗时；
  - cleanup：退出清理所用时间；
  - vmop：真正执行 vmop 的耗时。

有时候打印日志的开销可能比短暂的停顿还大，Hotspot 有提供 API 但没有挂到 JMX 上，可以考虑从应用内吐出：

```java
import sun.management.*

private static HotspotRuntimeMBean mbean = (HotspotRuntimeMBean)ManagementFactoryHelper.getHotspotRuntimeMBean();
long count = mbean.getSafepointCount();
long time = mbean.getTotalSafepointTime();
long syncTime = mbean.getSafepointSyncTime()
```

或者利用 PerfData，详见 《围绕JVM的各种外挂技术》 以及 github 的一个项目 [VJTools](https://github.com/vipshop/vjtools)。

如果通过日志发现存在由于计数循环导致的长时间停顿（比如 GC 毛刺），可以通过增加 `-XX:+UseCountedLoopSafepoints` 参数，强制每个循环都设置安全点，但这个可能会降低应用的吞吐量。

## 2. 基于分代思想的 GC 算法

大部分场景下， Java 对象生命周期分布如下：

![](https://static001.geekbang.org/resource/image/e2/89/e235d25ca15b60a511a2d90317eb9589.png)

基于这个现象，出现了按照生命周期划分内存区域的 GC 算法：将堆空间划分为两代，分别叫做新生代和老年代。

新生代用来存储新建的对象，并使用 Minor GC 来回收垃圾：

- 年轻代：Eden 以及两个大小相同的 Survivor 区。

  - 动态分配：`-XX:+UsePSAdaptiveSurvivorSizePolicy`，根据生成对象的速率，以及 Survivor 区的使用情况动态调整 Eden 区和 Survivor 区的比例。

  - 固定比例：`-XX:SurvivorRatio`，Eden : Survivor 的比例，比例越低，Survivor 越大，浪费的空间越多。

  - Eden 区域新建对象，每个线程使用 `TLAB（ThreadLocal Allocation Buffer）`，申请自己的私有内存空间：

    - 维护最主要的两个指针，一个指向 TLAB 起始位置，一个指向结束位置；
    - 使用指针加法（bump the pointer）实现 new 指令；
    - 加法后指向空闲位置的指针如果小于结束位置，则表示分配成功，否则申请新的 TLAB。

    - **Eden 区内存耗尽时，则触发 Minor GC**，收集存活的对象，并送往 Survivor 区。

  - Survivor 区域分为 from 与 to：

    - Minor GC 时将 Eden 以及 from 区的对象复制到 to 区域，并交换 from 与 to 的指针。
    - 对象生命周期（对象复制次数）到达一定阈值（`-XX:+MaxTenuringThreshold`，默认 15，动态变化）时，会**晋升（promote）**到老年代。
    - 单个 Survivor 区占用较高（`-XX:TargetSurvivorRatio`，默认 50%）以上时，较高复制次数的对象也会被晋升至老年代。

Minor GC 以对象的年龄分布为前提，避免了整个堆进行扫描，但无法解决跨代引用的问题（老年代对象有新生代的引用），而将老年代作为 GC ROOT 又等于几乎扫描了真个堆。

## 3. 卡表

HotSpot 对于跨代引用的解决方案是**卡表（Card Table）**，将整个堆划分为一个个 512 byte 的卡，并维护一个卡表，用来存储每张卡的一个标识位，标识位代表对应的卡是否**可能**存在跨代引用，如果可能存在，就认为是脏卡。

Minor GC 时，会将卡表中的脏卡加入 GC ROOT 里，完成所有脏卡扫描后，脏卡的标识位便会被清零。

Minor GC 在移动存活对象的时候，又会重新设置引用所在卡的标识位，这时，可以确保脏卡中必定存在指向新生代对象的引用。

> NOTE：在 Minor GC 之前，无法确保脏卡中必定包含指向新生代对象的引用，这与 JVM 设置脏卡的策略有关。

为了保证每个指向新生代对象的引用都能被标记为脏卡，JVM 需要截获每个引用型实例变量的写操作，并作出对应的写标识位操作：

- 解释执行器中容易实现；
- JIT 生成的机器码则需要插入额外的逻辑，即写屏障（`write barrier`，与 volatile 字段的写屏障不同）。

为了保持简洁，而不是在每条引用型实例变量的写指令后面注入一大串指令，**写屏障并不会判断更新后的引用是否指向新生代中的对象，而是一律当成可能指向新生代对象的引用**，这也是为什么脏卡只是可能持有指向新生代对象的引用。

精简后的写屏障：

```c
# 9 对应着 512 byte
CARD_TABLE [this address >> 9] = DIRTY;
```

写屏障不可避免地带来一些开销，但是它能够加大 Minor GC 的吞吐率（ 应用运行时间 /(应用运行时间 + 垃圾回收时间) ）。

卡表由于频繁的写，会带来**伪共享**问题，在 HotSpot 中，卡表是通过 byte 数组来实现的。对于一个 64 字节的缓存行来说，如果用它来加载部分卡表，那么它将对应 64 张卡，也就是 32KB 的内存，如果其中一张卡表被修改了，则会导致其他卡表的回写，无效化或者同步操作，间接影响程序性能，可以通过 `-XX:+UseCondCardMark` 尽量减少卡表的操作，伪代码如下：

```c
if (CARD_TABLE [this address >> 9] != DIRTY) 
  CARD_TABLE [this address >> 9] = DIRTY;
```

## 4. GC 算法

新生代：Serial，Parallel Scavenge 和 Parallel New，都采用 **标记-复制** 算法：

- Serial：单线程。

- Parallel New： Serial 的多线程版本。

- Parallel Scavenge：与 Parallel New 类似，更加注重吞吐率，不能与 CMS 一起使用。


老年代：Serial Old、Parallel Old、CMS 以及 G1：

- Serial Old：单线程，**标记-压缩** 算法。
- Parallel Old：多线程，**标记-压缩** 算法。
- CMS：多线程，**标记-清除** 算法，除了少数操作需要 STW，可以在应用程序运行过程中进行 GC。在并发收集失败时，JVM会使用其他两个垃圾回收期进行一次 GC，Java 9 开始被 G1 替代。
- G1：横跨新生代和老年代，不再按照分代思想固定划分内存区域，而是将内存划分为多个块。每个块都可以充当 Eden 区、Survivor 区或者老年代中的一个，采用 标记 - 压缩算法，可以在应用程序运行过程中进行 GC。G1 能够针对每个细分的区域来进行垃圾回收，在选择进行垃圾回收的区域时，优先回收死亡对象较多的区域。
- ZGC：[ZGC 原理是什么，它为什么能做到低延时？](https://www.zhihu.com/question/287945354/answer/458761494)



