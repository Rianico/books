---
title: 10.方法内联
date: 2020-11-28
---


方法内联，在编译过程中遇到方法调用时，将目标方法的方法体纳入编译范围之中，并**取代原方法调用**的优化手段。

方法内联不仅可以消除调用的开销，还可以进一步触发更多的优化。

例如 getter/setter ，在方法内联后，仅剩下字段访问的开销。

C2/Graal 中，方法内联是在解析字节码的过程中完成的。

对于 JIT 来说，内联越多，编译时间也就越长，而程序达到峰值性能的时刻也将被推迟，编译生成的机器码会被部署到 Code Cache （由 Java 虚拟机参数 `-XX:ReservedCodeCacheSize` 控制，默认 2000）之中，Code Cache 是独立于 JVM 堆内存之外的。

> NOTE：当 Code Cache 已满，即时编译已被关闭的警告信息（CodeCache is full. Compiler has been disabled）。

查看 Code Cache：`jinfo -flagReservedCodeCacheSize`。

使用 `-XX:+PrintCodeCache` 在 JVM 停止时打印出 Code Cache 使用情况。

## 1. 内联规则

1. 由 `-XX:CompileCommand` 中的 inline 指令指定的方法，以及由 `@ForceInline` 注解的方法（仅限于 JDK 内部方法），会被强制内联。 而由 `-XX:CompileCommand` 中的 `dontinline` 指令或 exclude 指令（表示不编译）指定的方法，以及由 `@DontInline` 注解的方法（仅限于 JDK 内部方法），则始终不会被内联。
2. 如果调用字节码对应的**符号引用未被解析**、目标方法所在的**类未被初始化**，或者**目标方法是 native 方法**，都将导致方法调用无法内联。
3. C2 不支持内联超过 9 层的调用（可以通过虚拟机参数 `-XX:MaxInlineLevel` 调整），以及 1 层的直接递归调用（可以通过虚拟机参数 `-XX:MaxRecursiveInlineLevel` 调整）。

![](https://static001.geekbang.org/resource/image/49/c3/49fb3a3849e82ddcc74bd982a5e4eac3.jpg)

即时编译器中的内联算法更青睐于小方法。

> NOTE：内联情况可以通过 ` -XX:+UnlockDiagnosticVMOptions   -XX:+PrintInlining` 打印。

## 2. 方法内联

方法内联很关键的一点是，编译器能够确定唯一的目标方法，因此 private、final、static 在一定程度上可以帮助编译器确定方法。

静态绑定可以很轻易地进行方法内联，而**需要动态绑定的虚方法调用**，JIT 需要先对虚方法调用进行**去虚化（devirtualize）**，即转换为一个或多个直接调用，然后才能进行方法内联。

即时编译器的去虚化方式可分为两大类：

- **完全去虚化**：通过**类型推导**或者**类层次分析（class hierarchy analysis）**，识别虚方法调用的唯一目标方法，从而将其转换为直接调用。关键在于**证明虚方法调用的目标方法是唯一的**。
- **条件去虚化（guarded devirtualization）**：将虚方法调用**转换为若干个类型测试以及直接调用**，关键在于找出需要进行比较的类型（结合 profile）。

### 2.1 完全去虚化

#### 2.1.1 类型推导的去虚化

**基于类型推导的完全去虚化将通过数据流分析推导出调用者的动态类型，从而确定具体的目标方法**。

```java
public static int foo() {
  BinaryOp op = new Add();
  return op.apply(2, 1);
}

public static int bar(BinaryOp op) {
  op = (Add) op;
  return op.apply(2, 1);
}
```

上述方法编译器可以确定调用者的动态类型，因此可以触发类型推导的去虚化。

下述方法则不会触发基于类型推导的去虚化：

```java
public static int notInlined(BinaryOp op) {
  if (op instanceof Add) {
    return op.apply(2, 1);
  }
  return 0;
}
```

虽然上述代码编译器理论上能够推导出调用的动态类型的 Add，但是**类型推导属于全局优化，开销较大**。

> NOTE：C2 和 Graal 决定，如果生成 Sea-of-Nodes IR 后还需要额外的数据流才能确定调用者的动态类型，则不做基于类型推导的全局优化。

对于这类代码，通常使用基于类层次分析的去虚化，以及条件去虚化兜底，来覆盖大部分的代码情况。

#### 2.1.2 类层次的去虚化

基于类层次分析的完全去虚化通过**分析 JVM 中所有已被加载的类，判断某个抽象方法或者接口方法是否仅有一个实现**。如果是，那么对这些方法的调用将只能调用至该具体实现中。

JVM 无法保证后续不会有新的实现的子类被加载进来，因此会为当前编译结果注册若干个假设（assumption）：

- 假定某抽象类只有一个子类
- 某抽象方法只有一个具体实现
- 某类没有子类等。

之后，每当新的类被加载，JVM 便会重新验证这些假设，如果假设不成立，则会去优化。

```java
  public static int test(BinaryOp op) {
    return op.apply(2, 1);
  }
```

如上代码，如果 JVM 只加载了一个 Add 子类，那么即时编译器可以注册一个假设，假定抽象方法 BinaryOp.apply 有且仅有 Add.apply 这个具体实现，之后便可去虚化。

如果后面 JVM 又加载了 Sub 类，那么该假设失效，JVM 会触发 test 的去优化。

即便调用者的声明类型为 Add，即时编译器仍需为之添加假设。这是因为 Java 虚拟机不能保证没有重写了 apply 方法的 Add 类的子类。

JIT 并不要求目标方法使用 final 修饰符，只要目标方法事实上是 final 的（effective final），便可以进行相应的去虚化以及内联。因此可以使用 final 修饰符，JIT 可以减少生成假设的开销。

> NOTE：对于接口方法调用，该去虚化手段则不能移除动态类型检测。这是因为在执行 invokeinterface 指令时，Java 虚拟机必须对调用者的动态类型进行测试，看它是否实现了目标接口方法所在的接口。这一类测试无法避免，因此对于接口方法，会使用条件去虚化。

### 2.2 条件去虚化

条件去虚化通过向代码中添加若干个类型比较，将虚方法调用转换为若干个直接调用。

同条件去虚化将调用者的动态类型，依次与 Java 虚拟机所收集的类型 Profile 中记录的类型相比较。如果匹配，则直接调用该记录类型所对应的目标方法：

```java
  public static int test(BinaryOp op) {
    if (op.getClass() == Sub.class) {
      return 2 - 1; // inlined Sub.apply
    } else if (op.getClass() == Add.class) {
      return 2 + 1; // inlined Add.apply
    } else {
      ... // 当匹配不到类型Profile中的类型怎么办？
    }
  }
```

如果遍历完类型 Profile 中的所有记录，仍无法匹配到调用者的类型，则编译器有两种选择：

1. 如果类型 Profile 是完整的，也就是说，所有出现过的动态类型都被记录至类型 Profile 之中，那么即时编译器可以让程序进行去优化，重新收集类型 Profile。
2. 如果类型 Profile 是不完整的，JIT 会执行虚调用，通过内联缓存进行调用，或者通过方法表进行动态绑定。

> NOTE：当 Profile 超过一个类可以记录的数量时，便说这个 Profile 是不完整的。

> NOTE：C2 一旦遇到 Profile 不完整时，则会直接执行虚调用，Graal 则是会尝试进行条件去虚化。

## 3. 实践

```java
// Run with java -XX:CompileCommand='dontinline JITTest.test' -XX:+PrintCompilation JITTest
public class JITTest {
  static abstract class BinaryOp {
      public abstract int apply(int a, int b);
  }

  static class Add extends BinaryOp {
      public int apply(int a, int b) {
          return a + b;
      }
  }

  static class Sub extends BinaryOp {
      public int apply(int a, int b) {
          return a - b;
      }
  }

  public static int test(BinaryOp op) {
    return op.apply(2, 1);
  }

  public static void main(String[] args) throws Exception {
    Add add = new Add();
    for (int i = 0; i < 400_000; i++) {
      test(add);
    }

    Thread.sleep(2000);
    System.out.println("Loading Sub");
    Sub[] array = new Sub[0]; // Load class Sub
    // Expect output: "JITTest::test (7 bytes)   made not entrant"
    Thread.sleep(2000);
  }
}
```

输入如下：

```
......
    167   19       3       JITTest::test (7 bytes)
    169   20       2       JITTest$Add::apply (4 bytes)
    170   21       4       JITTest::test (7 bytes)
    171   22       1       JITTest$Add::apply (4 bytes)
    172   19       3       JITTest::test (7 bytes)   made not entrant
    173   20       2       JITTest$Add::apply (4 bytes)   made not entrant
    174   23 %     3       JITTest::main @ 10 (39 bytes)
    176   24 %     4       JITTest::main @ 10 (39 bytes)
    177   25       3       java.lang.System::getSecurityManager (4 bytes)
    180   23 %     3       JITTest::main @ -2 (39 bytes)   made not entrant
   2178   26       3       java.lang.String::startsWith (7 bytes)
   2181   24 %     4       JITTest::main @ -2 (39 bytes)   made not entrant
   2185   21       4       JITTest::test (7 bytes)   made not entrant
   2186   27       3       java.lang.String::getChars (62 bytes)
```

`made not entrant` 往往表示方法属于 Zombie 状态，一旦 GC 发生便会被回收。

当一个方法被内联后，原来的机器码便会被回收：

```
    167   19       3       JITTest::test (7 bytes)
    169   20       2       JITTest$Add::apply (4 bytes)
    170   21       4       JITTest::test (7 bytes)
    171   22       1       JITTest$Add::apply (4 bytes)
```

可以看到，167、169 分别属于 C1 中第三、二层，之后的 170、171 被内联且进入了终态，之后便会回收原来第三、二层的机器码：

```
    172   19       3       JITTest::test (7 bytes)   made not entrant
    173   20       2       JITTest$Add::apply (4 bytes)   made not entrant
```

在之后，加载了 Sub 子类，则会导致原来的基于类层次分析的去虚化失效：

```
    177   25       3       java.lang.System::getSecurityManager (4 bytes)
   2178   26       3       java.lang.String::startsWith (7 bytes)
```

