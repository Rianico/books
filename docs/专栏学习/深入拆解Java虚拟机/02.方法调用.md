---
1title: 02.方法调用
date: 2020-10-03
---

[toc]

## 1. 重载与重写

如果一个类中同一个方法名出现多次，并且入参的**声明类型**（**注意与实际类型区分**）不同，那么就称之为重载。

对于重载的方法，Java 按照以下规则选取：

1. 不考虑**基本类型自动装拆箱**（auto-boxing，auto-unboxing）以及**可变长参数**；
2. 如果 1 中未匹配到，则考虑**基本类型自动装拆箱（auto-boxing，auto-unboxing）**，但不考虑可变长参数；
3. 如果 2 中未匹配到，则考虑**基本类型自动装拆箱**（auto-boxing，auto-unboxing）以及**可变长参数**。

如果 Java 编译器在同一个阶段找到了多个适配的方法，那就根据**形参的实际类型**进行选择。

```java

void invoke(Object obj, Object... args) { ... }
void invoke(String s, Object obj, Object... args) { ... }

invoke(null, 1);    // 调用第二个invoke方法
invoke(null, 1, 2); // 调用第二个invoke方法
invoke(null, new Object[]{1}); // 只有手动绕开可变长参数的语法糖，才能调用第一个invoke方法
```

通常都**不推荐对可变长参数进行重载**，会很容易导致误用。

与重载相对的还有重写，且要与其他一些情形区分开来：

1. 如果子类定义了与父类中非私有方法同名的方法，而且这两个方法的参数类型不同，那么在子类中，这两个方法同样构成了重载。
2. 如果子类定义了与父类中**非私有静态方法**相同名的方法，而且入参相同，则**子类隐藏了父类的方法**。
3. 如果子类定义了与父类中**非私有非静态方法**相同名的方法，而且入参相同，则**子类重写了父类的方法**。

## 2. JVM 的静态绑定和动态绑定

JVM 与 Java 识别方法的方式机制略有不同：

- JVM：根据类的**类名、方法名以及方法描述符（method descriptor，由方法的参数类型以及返回类型所构成）**。
- Java：根据累的类名、方法名以及入参。

在 JVM 中，当子类的类名、方法名以及方法描述符与父类相同时，JVM 才判断为重写。

**为了应对 JVM 中非重写而 Java 中重写的场景，Java 通过编译器生成桥接方法解决。**

可以认为，JVM 中不存在重载这一概念，在 JVM 的语境下，某个类中的重载方法可能会被其子类所重写，因此**Java 编译器会将所有对非私有实例方法的调用编译为需要动态绑定的类型**。

确切地说，Java 虚拟机中的绑定分为两种：

- **静态绑定**：在**解析阶段**时便能够直接识别目标方法；
- **动态绑定**：需要在**运行时根据调用者的实际类型**来识别目标方法。

Java 字节码调用的指令共有五种：

1. **invokestatic**：用于调用静态方法。
2. **invokespecial**：用于调用私有实例方法、构造器，以及使用 super 关键字调用父类的实例方法或构造器，和所实现接口的默认方法。
3. **invokevirtual**：用于调用非私有实例方法。
4. **invokeinterface**：用于调用接口方法。
5. **invokedynamic**：用于调用动态方法。

```java
interface 客户 {
  boolean isVIP();
}

class 商户 {
  public double 折后价格(double 原价, 客户 某客户) {
    return 原价 * 0.8d;
  }
}

class 奸商 extends 商户 {
  @Override
  public double 折后价格(double 原价, 客户 某客户) {
    if (某客户.isVIP()) {                         // invokeinterface      
      return 原价 * 价格歧视();                    // invokestatic
    } else {
      return super.折后价格(原价, 某客户);          // invokespecial
    }
  }
  public static double 价格歧视() {
    return new Random()                          // invokespecial
           .nextDouble()                         // invokevirtual
           + 0.8d;
  }
}
```

对于 invokestatic 以及 invokespecial 而言，Java 虚拟机能够在解析时直接识别具体的目标方法。

对于 invokevirtual 以及 invokeinterface 而言，在绝大部分情况下（**目标方法只有一个且被标记为 final 除外**），虚拟机需要在执行过程中，根据调用者的动态类型，来确定具体的目标方法。

**Q：为什么多态调用方法在运行时才能确定？**

在 Java 中，有时候需要根据一些运行时信息，才能确定具体的类型，例如反射，动态字节码，动态类型转换等，并且 JVM 也不是一开始就将所有类都解析好的，而是在需要执行相关字节码时，再执行加载-链接-初始化三个步骤的。

### 2.1 调用指令的符号引用

在编译过程中并不知道目标方法的具体内存地址，Java 编译器会暂时用符号引用来表示该目标方法。这一符号引用包括目标方法所在的**类或接口的名字，以及目标方法的方法名和方法描述符**。

符号引用存储在 class 文件的常量池中，根据目标方法是否为接口方法，这些引用可分为**接口符号引用**和**非接口符号引用**。

```java
$ javap -v xxx
// 在常量池中，#16为接口符号引用，指向接口方法"客户.isVIP()"。而#22为非接口符号引用，指向静态方法"奸商.价格歧视()"。
$ javap -v 奸商.class ...
Constant pool:
...
  #16 = InterfaceMethodref #27.#29        // 客户.isVIP:()Z
...
  #22 = Methodref          #1.#33         // 奸商.价格歧视:()D
...
```

非接口符号引用（从下而上搜索方法），假定该符号引用所指向的类为 C：

1. 在 C 中查找符合名字及描述符的方法。
2. 如果没有找到，在 C 的父类中继续搜索，直至 Object 类。
3. 如果没有找到，在 C 所直接实现或间接实现的接口中搜索，这一步搜索得到的目标方法必须是**非私有**、**非静态**的，如果目标方法在间接实现的接口中，则需满足 C 与该接口之间没有其他符合条件的目标方法。如果有多个符合条件的目标方法，则任意返回其中一个。

接口符号引用（从上而下搜索方法），假定该符号引用所指向的接口为 I：

1. 在 I 中查找符合名字及描述符的方法。
2. 如果没有找到，在 Object 类中的公有实例方法中搜索。
3. 如果没有找到，则在 I 的超接口中搜索。这一步的搜索结果的要求与非接口符号引用步骤 3 的要求一致。

经过上述步骤后，符号引用会被解析为实际引用，对于静态绑定的方法而言，实际引用是一个指向方法的指针；对于动态绑定的方法而言，**实际引用是一个方法表中的索引**。

桥接方法的生成例子可查看 [Java 桥接方法（Bridge Method）](https://blog.csdn.net/jiaobuchong/article/details/83722193) ，本质上是由编译器生成一个与父类返回类型一样的重写方法，再调用子类的具体实现，以确保在 JVM 的语境下能够调用到预期的方法。

### 2.2 虚方法调用

虚方法调用包括 `invokevirtual` 指令和 `invokeinterface` 指令。如果这两种指令所声明的目标方法被标记为 final，那么 Java 虚拟机会采用静态绑定。

JVM 需要根据调用者的动态类型，来确定虚方法调用的目标方法，这种称为动态绑定，相对于静态绑定的非虚方法调用，动态绑定更加耗时。

为了减少动态绑定的性能损耗，JVM 采取空间换时间的策略，为每个类生成一张方法表（在类的链接-准备阶段生成）。

invokevirtual 对应的是**虚方法表（virtual method table，vtable）**，方法表本质上是一个数组，**每个数组元素指向一个当前类及其祖先类中非私有的实例方法**。

方发表需要满足以下两个特质：

1. 子类方法表包含父类方法表的所有方法。
2. 子类方法表与父类方法表中的索引值一致。

![](https://static001.geekbang.org/resource/image/f1/c3/f1ff9dcb297a458981bd1d189a5b04c3.png)

其中的 `toString` 为所有对象的父类 `Object` 的方法，其他父类方法先忽略。

使用方法表的动态绑定与静态绑定相比，仅仅多出了几个操作：

1. 访问栈上的调用者，并获取其动态类型；
2. 根据动态类型切换要查询的方法表；
3. 根据索引值访问对应的方法。

对比创建栈帧的操作，这些开销几乎可以忽略不计，但是这种方式仅存在于解释执行中，或者即时编译代码的最坏情况中。即时编译中还有两种更加强大的优化手段：**内联缓存（inlining cache）和方法内联（method inlining）**。

#### 2.2.1 内联缓存

**内联缓存能够缓存虚方法调用中调用者的动态类型，以及该类型所对应的目标方法**。

JVM 采用**单态内联缓存**以节省空间，如果之后碰到未缓存的方法，直接放弃优化机会，退化到基于方法表的动态调用。

> NOTE：如果采用替换缓存的方式，当出现方法反复切换调用的时候，不但无法利用缓存，反而增加了写入缓存的开销。

> NOTE：内联缓存并没有内联方法，任何方法调用除非被内联，否则都会有固定开销，这些**开销来源于保存程序在该方法中的执行位置，以及新建、压入和弹出新方法所使用的栈帧**。因此，对于极其简单的方法而言，比如说 getter/setter，这部分固定开销占据的 CPU 时间甚至超过了方法本身。

#### 2.2.2 方法内联

方法内联是通过去虚化，确定唯一的调用方法后，将目标方法展开至调用方法中，省去调用的步骤。

### 2.3 invokedynamic

Java 7 引入了一条新的指令 `invokedynamic`。该指令的调用机制**抽象出调用点（CallSite）这一个概念，并允许应用程序将调用点链接至任意符合条件的方法上**。

invokedynamic 指令底层实现为**方法句柄（MethodHandle）**，一个强类型的，能够被直接执行的引用，以指向常规的静态方法或者实例方法，也可以指向构造器或者字段。

方法句柄的**类型（MethodType）**是由所指向方法的**参数类型以及返回类型**组成的，用来确认方法句柄是否适配的唯一关键，不关注具体的类名以及方法名。

> NOTE：这也是实现鸭子类型的方式。如果兔子的“赛跑”方法和“睡觉”方法的参数类型以及返回类型一致，那么对于兔子递过来的一个方法句柄，我们并不知道会是哪一个方法。

调用方法句柄，**和原本对应的调用指令是一致的**：

- invokestatic： Lookup.findStatic
- invokevirtual/invokeinterface： findVirtual
- invokespecial： findSpecial

#### 2.3.1 方法句柄的权限

方法句柄的权限检查是在句柄的创建阶段完成的，其**权限取决于Lookup 对象（而不是句柄）创建的位置**：

```java
class Foo {
  private static void bar(Object o) {
    ..
  }
  public static Lookup lookup() {
    return MethodHandles.lookup();
  }
}

// 获取方法句柄的不同方式
MethodHandles.Lookup l = Foo.lookup(); // 具备Foo类的访问权限
Method m = Foo.class.getDeclaredMethod("bar", Object.class);
MethodHandle mh0 = l.unreflect(m);

MethodType t = MethodType.methodType(void.class, Object.class);
MethodHandle mh1 = l.findStatic(Foo.class, "bar", t);
```

> NOTE：由于方法句柄没有运行时权限检查，因此，应用程序需要负责方法句柄的管理。一旦它发布了某些指向私有方法的方法句柄，那么这些私有方法便被暴露出去了。

#### 2.3.2 方法句柄的操作

方法句柄的调用分为两种：

1.  `invoke`：非严格匹配参数类型，会自动进行类型转化及匹配。

2. `invokeExact`：严格匹配参数类型 ，被  `@PolymorphicSignature` 修饰的方法，编译器会**根据传入参数的声明类型以及返回类型来生成方法描述符**，而不是采用目标方法所声明的描述符。

```java
  public void test(MethodHandle mh, String s) throws Throwable {
    mh.invokeExact(s);
    mh.invokeExact((Object) s);
  }

  // 对应的Java字节码
  public void test(MethodHandle, String) throws java.lang.Throwable;
    Code:
       0: aload_1
       1: aload_2
       2: invokevirtual MethodHandle.invokeExact:(Ljava/lang/String;)V
       5: aload_1
       6: aload_2
       7: invokevirtual MethodHandle.invokeExact:(Ljava/lang/Object;)V
      10: return
```

 `invokeExact` 是根据传入参数的声明类型以及返回类型来生成描述符的，如果方法接收一个 Object ，却传入了 String，在不匹配的情况下，便会在运行时抛出异常。

`invoke` 则会调用 `MethodHandle.asType` 方法，生成一个适配器方法句柄，对传入的参数进行适配，再调用原方法句柄。

#### 2.3.3 方法句柄的实现

Java 虚拟机会对 `invokeExact` 以及 `invoke` 调用做特殊处理，调用至一个共享的、与方法句柄类型相关的特殊适配器 **LambdaForm** 中。

```java
import java.lang.invoke.*;

public class Foo {
  public static void bar(Object o) {
    new Exception().printStackTrace();
  }

  public static void main(String[] args) throws Throwable {
    MethodHandles.Lookup l = MethodHandles.lookup();
    MethodType t = MethodType.methodType(void.class, Object.class);
    MethodHandle mh = l.findStatic(Foo.class, "bar", t);
    mh.invokeExact(new Object());
  }
}

// LambdaForm会被隐藏，添加对应的参数进行显示
$ java -XX:+UnlockDiagnosticVMOptions -XX:+ShowHiddenFrames Foo
java.lang.Exception
        at Foo.bar(Foo.java:5)
        at java.base/java.lang.invoke.DirectMethodHandle$Holder. invokeStatic(DirectMethodHandle$Holder:1000010)
        at java.base/java.lang.invoke.LambdaForm$MH000/766572210. invokeExact_MT000_LLL_V(LambdaForm$MH000:1000019)
        at Foo.main(Foo.java:12)
```

添加 `-Djava.lang.invoke.MethodHandle.DUMP_CLASS_FILES=true` 将 LambdaForm 导出为 class 文件，查看反编译内容：

```java
final class java.lang.invoke.LambdaForm$MH012 {
  static void invoke_000_MT(java.lang.Object, java.lang.Object, java.lang.Object);
    Code:
      stack=2, locals=3, args_size=3
         0: aload_0
         1: aload_2
         2: invokestatic  #16                 // Method java/lang/invoke/Invokers.checkExactType:(Ljava/lang/Object;Ljava/lang/Object;)V
         5: aload_0
         6: invokestatic  #20                 // Method java/lang/invoke/Invokers.checkCustomized:(Ljava/lang/Object;)V
         9: aload_0
        10: checkcast     #22                 // class java/lang/invoke/MethodHandle
        13: dup
        14: astore_0
        15: aload_1
        16: invokevirtual #25                 // Method java/lang/invoke/MethodHandle.invokeBasic:(Ljava/lang/Object;)V
        19: return
}
```

可以看到分别调用了几个方法：

- **Invokers.checkExactType**：检查参数类型。

- **Invokers.checkCustomized**：在方法句柄的执行次数超过一个阈值（`-Djava.lang.invoke.MethodHandle.CUSTOMIZE_THRESHOLD`，默认值为 127）时进行优化，会**将方法句柄作为常量，从常量池获取其 MemberName 类型的字段**，并继续后面的 linkToStatic 调用。

- **invokeBasic**：JVM 会对 invokeBasic 调用做特殊处理，调用方法句柄所持有的 LambdaForm 适配器：

  ```java
  // 该方法句柄持有的LambdaForm实例的toString()结果
  DMH.invokeStatic_L_V=Lambda(a0:L,a1:L)=>{
    t2:L=DirectMethodHandle.internalMemberName(a0:L);
    t3:V=MethodHandle.linkToStatic(a1:L,t2:L);void}
  ```

  **这个适配器会获取方法句柄中的 `MemberName` 类型的字段**，并且以它为参数调用 `linkToStatic` 方法，JVM 也会对 `linkToStatic` 方法做特殊处理，将根据传入的 MemberName 参数所存储的方法地址或者方法表索引，直接跳转至目标方法：

  ```java
  final class MemberName implements Member, Cloneable {
  ...
      //@Injected JVM_Method* vmtarget;
      //@Injected int         vmindex;
  ...
  ```

> NOTE：与反射调用不同的是，**方法句柄的内联瓶颈在于 JIT 能否将该方法句柄识别为常量以及方法内联**。

如果一个句柄被多次调用，通常的优化手段有：

1. 将方法句柄定义为一个常量（重要）；
2. 预先使用 `bindTo` 绑定到一个实例上；
3. 减少循环体内新建对象；
4. 修改 `-Djava.lang.invoke.MethodHandle.CUSTOMIZE_THRESHOLD`。
5. 调用的方法修改为静态绑定。

#### 2.3.4 invokedynamic 指令

Java 7 引入了 invokedynamic 指令，这个指令将调用点（CallSite）抽象成一个类，将原本应该**由 JVM 控制的方法调用以及方法链接暴露给应用程序**。

第一次执行 invokedynamic 指令时会调用该指令对应的启动方法（Bootstrap Method），**生成调用点，并将其绑定到该 invokedynamic 指令中**，在之后会直接**调用调用点所链接的方法句柄**。

启动方法可以接收三个参数来生成调用点：

- Lookup 类实例
- 指代目标方法的字符串
- 调用点链接的方法句柄类型

```java
import java.lang.invoke.*;
public static CallSite bootstrap(MethodHandles.Lookup l, String name, MethodType callSiteType) throws Throwable {
	MethodHandle mh = l.findVirtual(Horse.class, name, MethodType.methodType(void.class));
    return new ConstantCallSite(mh.asType(callSiteType));
}
```

> NOTE： ConstantCallSite 是一种不可以更改链接对象的调用点。除此之外，Java 核心类库还提供多种可以更改链接对象的调用点，比如 MutableCallSite 和 VolatileCallSite。

> NOTE：除了这三个必需参数之外，启动方法还可以接收若干个其他的参数，用来辅助生成调用点，或者定位所要链接的目标方法。

#### 2.3.5 Lambda 表达式

Java 8 中的 Lambda 表达式是借助 invokedynamic 来实现的，**Java 编译器利用 invokedynamic 指令来生成实现了函数式接口（仅包括一个非 default 接口方法的接口，通常使用 @FunctionalInterface 注解）的适配器**。

```java
int x = ..
IntStream.of(1, 2, 3).map(i -> i * 2).map(i -> i * x);
```

上述代码中的 `i -> i * 2` 以及 `i -> i * x` 需要转化为 IntUnaryOperator 的实例，这种转化正是借由 invokedynamic 实现的。

Java 编译器会对 Lambda 进行解语法糖（desugar），**生成方法来保存 Lambda 表达式的内容**：

```java
  // i -> i * 2
  private static int lambda$0(int);
    Code:
       0: iload_0
       1: iconst_2
       2: imul
       3: ireturn

  // i -> i * x，所引用的变量也会作为参数传递进去
  private static int lambda$1(int, int);
    Code:
       0: iload_1
       1: iload_0
       2: imul
       3: ireturn
```

第一次执行 invokedynamic 指令时，它所对应的启动方法会通过 ASM 来生成一个保存了 Lambda 表达式内容的适配器类（这里就是 `IntUnaryOperator`），**启动方法会返回一个链接着这个适配器类的方法句柄的调用点**。

根据 Lambda 表达式是否引用其他变量（是否上下文无关），生成适配器类的方式又有所不同：

- 如果上下文无关，启动方法将新建一个适配器类的实例，并且生成一个特殊的方法句柄，始终返回该实例。
- 如果上下文相关，启动方法生成的适配器类将包含一个额外的静态方法，来构造适配器类的实例。该方法将接收这些捕获的参数，并且将它们保存为适配器类实例的实例字段，目的是为了线程安全以及能够读取到正确的变量。

```java
// i->i*2 对应的适配器类，上下文无关
final class LambdaTest$$Lambda$1 implements IntUnaryOperator {
 private LambdaTest$$Lambda$1();
  Code:
    0: aload_0
    1: invokespecial java/lang/Object."<init>":()V
    4: return

 public int applyAsInt(int);
  Code:
    0: iload_1
    1: invokestatic LambdaTest.lambda$0:(I)I
    4: ireturn
}

// i->i*x 对应的适配器类，上下文相关
final class LambdaTest$$Lambda$2 implements IntUnaryOperator {
 private final int arg$1;

 private LambdaTest$$Lambda$2(int);
  Code:
    0: aload_0
    1: invokespecial java/lang/Object."<init>":()V
    4: aload_0
    5: iload_1
    6: putfield arg$1:I
    9: return

 private static java.util.function.IntUnaryOperator get$Lambda(int);
  Code:
    0: new LambdaTest$$Lambda$2
    3: dup
    4: iload_0
    5: invokespecial "<init>":(I)V
    8: areturn

 public int applyAsInt(int);
  Code:
    0: aload_0
    1: getfield arg$1:I
    4: iload_1
    5: invokestatic LambdaTest.lambda$1:(II)I
    8: ireturn
}
```

也就是说，生成的调用点会始终指向同个适配器类，适配器类则会根据具体情况返回相同/不同的实例。

#### 2.3.6 Lambda 以及方法句柄的性能分析

```java
import java.util.function.IntConsumer;

public class Test {
  public static void target(int i) { }

  public static void main(String[] args) throws Exception {
    long current = System.currentTimeMillis();
    for (int i = 1; i <= 2_000_000_000; i++) {
      if (i % 100_000_000 == 0) {
        long temp = System.currentTimeMillis();
        System.out.println(temp - current);
        current = temp;
      }

      ((IntConsumer) j -> Test.target(j)).accept(128);
      // ((IntConsumer) Test::target.accept(128);
    }
  }
}
```

使用 Lambda 表达式的这段代码与直接调用性能并无太大区别，主要原因如下：

- 对于上下文无关的 Lambda 表达式而言，会一直返回同个适配器实例，因此可以作为常量。
- Lambda 表达式所使用的 invokedynamic 将绑定一个 ConstantCallSite，其链接的目标方法无法改变，因此可以进行方法内联。

也就是说，即时编译器能够将转换 Lambda 表达式所使用的 invokedynamic，以及对 IntConsumer.accept 方法的调用统统内联进来，最终优化为空操作。

```java
// 上下文相关
import java.util.function.IntConsumer;

public class Test {
  public static void target(int i) { }

  public static void main(String[] args) throws Exception {
    int x = 2;

    long current = System.currentTimeMillis();
    for (int i = 1; i <= 2_000_000_000; i++) {
      if (i % 100_000_000 == 0) {
        long temp = System.currentTimeMillis();
        System.out.println(temp - current);
        current = temp;
      }

      ((IntConsumer) j -> Test.target(x + j)).accept(128);
    }
  }
}
```

此处的捕获型 Lambda 表达式引用了外部变量，本应每次调用都生成一个适配器实例，但实际性能是差不多的，究其原因是因为被**逃逸分析**给优化掉了。

> NOTE： **Lambda 表达式需要注意必须使用 final 变量以求达到逃逸分析的效果**，Java 8 之后，局部变量在不做改变的时候，编译器会自动添加上 final ，称之为 effectively final。

逃逸分析并不总是生效的，需要同时满足两个条件：

1. invokedynamic 指令所执行的方法句柄能够内联。
2. accept 方法的调用也能内联。