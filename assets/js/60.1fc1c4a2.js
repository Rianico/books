(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{782:function(t,a,e){"use strict";e.r(a);var r=e(70),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"总体概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总体概念"}},[t._v("#")]),t._v(" 总体概念")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://static001.geekbang.org/resource/image/b5/eb/b53099170df81c6dfb629254f5bf82eb.jpg",alt:""}})]),t._v(" "),e("p",[t._v("函数式编程的原则之一就是尽可能地在函数体中避免副作用（Side effect），副作用指的是函数对于状态的修改和变更。比如在一个函数式循环中，不停地对外部一个 List 进行追加产生副作用。")]),t._v(" "),e("p",[t._v("调优的本质需要根据"),e("strong",[t._v("木桶原理")]),t._v("，需要明白其本质：")]),t._v(" "),e("ol",[e("li",[t._v("性能调优不是一锤子买卖，补齐一个短板，其他板子可能会成为新的短板。因此，它是一个动态、持续不断的过程。")]),t._v(" "),e("li",[t._v("性能调优的手段和方法是否高效，取决于它针对的是木桶的长板还是瓶颈。针对瓶颈，事半功倍；针对长板，事倍功半。")]),t._v(" "),e("li",[t._v("性能调优的方法和技巧，没有一定之规，也不是一成不变，随着木桶短板的此消彼长需要相应的动态切换。")]),t._v(" "),e("li",[t._v("性能调优的过程收敛于一种所有木板齐平、没有瓶颈的状态。")])]),t._v(" "),e("p",[t._v("从上面几点，我们也可以得出，其实程序调优的最终目的，"),e("strong",[t._v("是在所有参与计算的硬件资源之间寻求协同与平衡")]),t._v("。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://static001.geekbang.org/resource/image/33/07/338518a9afaa820e4517868f03aae507.jpeg",alt:""}})]),t._v(" "),e("p",[t._v("Spark UI 提供了丰富的可视化面板，来展示 DAG、Stages 划分、执行计划、Executor 负载均衡情况、GC 时间、内存缓存消耗等等详尽的运行时状态数据；对于硬件资源消耗，开发者可以利用 Ganglia 或者系统级监控工具，如 top、vmstat、iostat、iftop 等等来实时监测硬件的资源利用率；特别地，针对 GC 开销，开发者可以将 GC log 导入到 JVM 可视化工具，从而一览任务执行过程中 GC 的频率和幅度。")]),t._v(" "),e("p",[t._v("Spark 的性能调优可以从应用代码和 Spark 配置项这 2 个层面展开：")]),t._v(" "),e("ul",[e("li",[t._v("开发阶段都有哪些常规操作、常见误区，从而尽量避免在代码中留下性能隐患。")]),t._v(" "),e("li",[t._v("Spark 官网上罗列了近百个配置项，但并不是所有的配置项都和性能调优息息相关，需要对它们进行甄别、归类。")])])])}),[],!1,null,null,null);a.default=s.exports}}]);