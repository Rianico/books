(window.webpackJsonp=window.webpackJsonp||[]).push([[127],{849:function(_,t,v){"use strict";v.r(t);var e=v(70),a=Object(e.a)({},(function(){var _=this,t=_.$createElement,v=_._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"_1-周期"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-周期"}},[_._v("#")]),_._v(" 1. 周期")]),_._v(" "),v("p",[_._v("一个指令周期是由 “"),v("strong",[_._v("Fetch - Decode - Execute")]),_._v("” 组成的：")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("Fetch")]),_._v("（取得指令）：从PC 寄存器里找到对应的指令地址，根据指令地址从内存里把具体的指令，加载到指令寄存器中，然后把 PC 寄存器自增。")]),_._v(" "),v("li",[v("strong",[_._v("Decode")]),_._v("（指令译码）： 根据指令寄存器里面的指令，解析成要进行什么样的操作，是 R、I、J 中的哪一种指令，具体要操作哪些寄存器、数据或者内存地址。")]),_._v(" "),v("li",[v("strong",[_._v("Execute")]),_._v("（执行指令）：实际运行指令的地方，进行算术逻辑操作、数据传输或者直接的地址跳转。")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://static001.geekbang.org/resource/image/18/a7/1840bead02cfbe5d8f70e2f0a7b962a7.jpg",alt:""}})]),_._v(" "),v("p",[_._v("在取出指令的阶段，指令是放在"),v("strong",[_._v("存储器")]),_._v("里的。")]),_._v(" "),v("p",[_._v("通过 PC 寄存器和指令寄存器取出指令，指令解码都是由"),v("strong",[_._v("控制器")]),_._v("（Control Unit）完成的。")]),_._v(" "),v("p",[_._v("执行指令阶段，无论是进行算术操作、逻辑操作的 R 型指令，还是进行数据传输、条件分支的 I 型指令，都是由"),v("strong",[_._v("算术逻辑单元")]),_._v("（ALU），也就是运算器完成的。")]),_._v(" "),v("p",[_._v("简单的指令跳转可以由"),v("strong",[_._v("控制器")]),_._v("完成。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://static001.geekbang.org/resource/image/bd/67/bde3548a4789ba49cab74c8c1ab02a67.jpeg",alt:""}})]),_._v(" "),v("p",[_._v("除了指令周期，常见的两种周期为"),v("strong",[_._v("机器周期（Machine Cycle，CPU 周期）"),v("strong",[_._v("以及")]),_._v("时钟周期（Clock Cycle）")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("CPU周期：CPU 内部的操作速度很快，但是访问内存的速度却要慢很多。每一条指令都需要从内存里面加载而来，一般把"),v("strong",[_._v("从内存里面读取一条指令的最短时间，称为 CPU 周期")]),_._v("。")]),_._v(" "),v("li",[_._v("时钟周期：一个 CPU 周期通常由几个时钟周期累积起来。")])]),_._v(" "),v("p",[v("strong",[_._v("一个指令周期，包含多个 CPU 周期，而一个 CPU 周期包含多个时钟周期")]),_._v("。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://static001.geekbang.org/resource/image/1a/48/1a7d2d6cf7cb78a8f48775268f452e48.jpeg",alt:""}})]),_._v(" "),v("p",[_._v("对于一个指令周期来说，取出一条指令并执行，至少需要两个 CPU 周期。取出指令至少需要一个 CPU 周期，执行至少也需要一个 CPU 周期，复杂的指令则需要更多的 CPU 周期。")]),_._v(" "),v("h2",{attrs:{id:"_2-数据通路"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-数据通路"}},[_._v("#")]),_._v(" 2. 数据通路")]),_._v(" "),v("p",[_._v("一般可以认为，数据通路就是处理单元，通常由两类元件组成：")]),_._v(" "),v("ol",[v("li",[v("p",[v("strong",[_._v("操作元件")]),_._v("，也叫"),v("strong",[_._v("组合逻辑元件")]),_._v("（Combinational Element），通常是 ALU，属于无状态的，在特定的输入下，根据一定的组合电路，生成特定的输出。")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("存储元件")]),_._v("，也有叫"),v("strong",[_._v("状态元件")]),_._v("（State Element）的。无论是通用寄存器还是状态寄存器，其实都是存储元件。")])])]),_._v(" "),v("p",[_._v("通过数据总线的方式，把它们连接起来，就可以完成数据的存储、处理和传输了，这就是所谓的建立数据通路。")]),_._v(" "),v("p",[_._v("运算器里的 ALU 和各种组合逻辑电路，可以认为是一个固定功能的电路。控制器“翻译”出来的，就是不同的控制信号。这些控制信号，告诉 ALU 去做不同的计算。可以说正是控制器的存在，才可以通过“编程”来实现功能，真正实现“存储程序型计算机”。")]),_._v(" "),v("blockquote",[v("p",[_._v("NOTE：实际上，控制器的电路特别复杂，一方面，所有 CPU 支持的指令，都会在控制器里面，被解析成不同的输出信号。现在的 Intel CPU 支持 2000 个以上的指令。这意味着，控制器输出的控制信号，至少有 2000 种不同的组合。")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://static001.geekbang.org/resource/image/46/6f/46087a894b4ac182fab83ac3786cad6f.jpeg",alt:""}})]),_._v(" "),v("h2",{attrs:{id:"_3-cpu-所需要的硬件电路"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-cpu-所需要的硬件电路"}},[_._v("#")]),_._v(" 3. CPU 所需要的硬件电路")]),_._v(" "),v("ol",[v("li",[v("strong",[_._v("ALU")]),_._v("，实际就是一个没有状态的，根据输入计算输出结果的第一个电路。")]),_._v(" "),v("li",[v("strong",[_._v("寄存器")]),_._v("，能够进行状态读写的电路元件，常见的能够进行状态读写的电路，就有"),v("strong",[_._v("锁存器")]),_._v("（Latch），以及 "),v("strong",[_._v("D 触发器")]),_._v("（Data/Delay Flip-flop）。")]),_._v(" "),v("li",[v("strong",[_._v("PC 寄存器")]),_._v("，也叫程序计数器，能够按照固定的周期，不停地实现 PC 寄存器自增，自动地去执行“Fetch - Decode - Execute“的步骤。我们时间编写程序，就是去修改这个寄存器里的地址。")]),_._v(" "),v("li",[v("strong",[_._v("译码器")]),_._v("，能够根据 decode 的指令以及内存地址去获取对应的数据或者指令。")])]),_._v(" "),v("h2",{attrs:{id:"_4-时钟信号"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-时钟信号"}},[_._v("#")]),_._v(" 4. 时钟信号")]),_._v(" "),v("p",[_._v("在 CPU 需要的电路中，有一些电路只需要给定输入，就能得到固定的输出。这样的电路称之为"),v("strong",[_._v("组合逻辑电路（Combinational Logic Circuit）")]),_._v("。")]),_._v(" "),v("p",[_._v("只有组合逻辑电路还无法实现自动化，需要手动去输入，因此引入了第二类的电路："),v("strong",[_._v("时序逻辑电路（Sequential Logic Circuit）")]),_._v("。")]),_._v(" "),v("p",[_._v("时序逻辑电路解决了以下几个问题：")]),_._v(" "),v("ol",[v("li",[v("strong",[_._v("自动运行")]),_._v("，时序电路接通之后可以不停地开启和关闭开关，进入一个"),v("strong",[_._v("自动运行")]),_._v("的状态。")]),_._v(" "),v("li",[v("strong",[_._v("存储")]),_._v("，通过时序电路实现的触发器，能把计算结果存储在特定的电路里面。")]),_._v(" "),v("li",[v("strong",[_._v("时序协调")]),_._v("，使得不同的事件（指令）按照时间顺序发生。")])]),_._v(" "),v("h3",{attrs:{id:"_4-1-自动运行"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-自动运行"}},[_._v("#")]),_._v(" 4.1 自动运行")]),_._v(" "),v("p",[_._v("自动化是通过在硬件层面实现时钟信号来解决的，以下面的电路为例：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://static001.geekbang.org/resource/image/57/c0/57684c12e7bf8ef429220405b0e3bdc0.jpeg",alt:""}})]),_._v(" "),v("p",[_._v("初始状态下，B 处于合上的状态，A 处于断开的状态，一旦 A 合上，那么电路接通，导致 B 被磁力吸引，处于断开状态，整个电路断开，这时候由于电路断开，磁力消失，B 又重新处于合上的状态，电路接通，如此一来，整个电路就会不断地在开启、关闭这两个状态中切换。")]),_._v(" "),v("p",[_._v("按照固定的周期不断在 0 和 1 之间切换的信号，就是"),v("strong",[_._v("时钟信号（Clock Signal）")]),_._v("。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://static001.geekbang.org/resource/image/6d/93/6dd534a167513c865dfe1921ebb6ae93.jpeg",alt:""}})]),_._v(" "),v("p",[_._v("这类电路，其实就相当于将自己的输出信号作为自己的输入信号，这种构造方式称之为"),v("strong",[_._v("反馈电路（Feedback Circuit）")]),_._v("。")]),_._v(" "),v("p",[_._v("前面的电路可以用一个非门实现，称之为反相器：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://static001.geekbang.org/resource/image/d2/ca/d205493f6ff1aeba7a849575285bbeca.jpg",alt:""}})]),_._v(" "),v("h3",{attrs:{id:"_4-2-d-触发器及存储功能"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-d-触发器及存储功能"}},[_._v("#")]),_._v(" 4.2 D 触发器及存储功能")]),_._v(" "),v("p",[_._v("D 触发器本质上是一个有记忆功能的电路，通常用于实现在 CPU 中存储计算结果的寄存器，也可以用来实现计算机五大组成部分之一的存储器（即内存）。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://static001.geekbang.org/resource/image/dc/de/dc6dcce612b2fd51939d7ec44b3fe1de.jpeg",alt:""}})]),_._v(" "),v("p",[v("img",{attrs:{src:"https://static001.geekbang.org/resource/image/7d/a9/7dd38282b8862cb6541ee82e76e1e0a9.jpg",alt:""}})]),_._v(" "),v("p",[_._v("上述使用了两个"),v("strong",[_._v("异或门")]),_._v("的电路具有记忆功能，称之为"),v("strong",[_._v("触发器（Flip-Flop）")]),_._v("。")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("接通开关 R，输出变为 1，断开开关，输出仍为 1 。")])]),_._v(" "),v("li",[v("p",[_._v("接通开关 S，输出变为 0，断开开关，输出仍为 0。")])])]),_._v(" "),v("p",[_._v("也就是，"),v("strong",[_._v("当两个开关都断开的时候，最终的输出结果，取决于之前动作的输出结果")]),_._v("。")]),_._v(" "),v("p",[_._v("这个电路属于最简单的 RS 触发器（Reset-Set Flip Flop，复位置位触发器），R、S 都为 0 的时候，输出结果取决于上一次操作。")]),_._v(" "),v("p",[_._v("在上述电路基础上，通过添加两个与门以及"),v("strong",[_._v("时钟信号 CLK")]),_._v(" 作为电路输入：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://static001.geekbang.org/resource/image/9e/d8/9e9bc411aa8c7bf2f080f306a0fb8bd8.jpeg",alt:""}})]),_._v(" "),v("p",[_._v("在 CLK 为低电平的时候，R、S 与门的输出必定为 0，这是输出结果 Q 必定不会发生变化。")]),_._v(" "),v("p",[_._v("在 CLK 为高电平的时候，这时候输出结果就取决于 R、S 了。")]),_._v(" "),v("p",[_._v("再使用一个反相器将 R 与 S 连接起来，通过同一个开关控制 R、S，在 CLK 为高电平的时候，输出结果 Q 就能够快速在 0 跟 1 之间切换，输入的信号视作 D，这个就是 "),v("strong",[_._v("D 型触发器")]),_._v("：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://static001.geekbang.org/resource/image/d7/bb/d749acce21756d89c35ee19545cfebbb.jpeg",alt:""}})]),_._v(" "),v("blockquote",[v("p",[_._v("NOTE：CPU 里面的寄存器可以直接通过 D 型触发器来构造，也可以在 D 型触发器的基础上，加上更多的开关，来实现清 0 或者全部置为 1 这样的快捷操作。")])]),_._v(" "),v("h3",{attrs:{id:"_4-3-程序计数器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-程序计数器"}},[_._v("#")]),_._v(" 4.3 程序计数器")]),_._v(" "),v("p",[_._v("通过时钟信号，让 D 型触发器一直自增，便可以实现一个程序计数器：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://static001.geekbang.org/resource/image/1e/4c/1ed21092022057ed192a7d9aff76144c.jpg",alt:""}})]),_._v(" "),v("blockquote",[v("p",[_._v("NOTE：这也是为什么指令在内存中是顺序存放的，因为程序计数器也是顺序递增的。")])]),_._v(" "),v("p",[_._v("如果 PC 寄存器自增太快，前一次的运算结果还没有回写到对应寄存器里，下一条指令开始读取寄存器里的数据，那么就会导致错误。因此，我们需要保证一条最复杂的指令能够在一个时钟周期里完成，这样的 CPU 设计，称之为"),v("strong",[_._v("单指令周期处理器（Single Cycle Processor）")]),_._v("。")]),_._v(" "),v("blockquote",[v("p",[_._v("NOTE：这种设计过于浪费性能，即使是最简单的指令，也需要等待一个时钟周期。可通过流水线技术优化。")])]),_._v(" "),v("h3",{attrs:{id:"_4-4-译码器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-译码器"}},[_._v("#")]),_._v(" 4.4 译码器")]),_._v(" "),v("p",[_._v("从输入的信号，根据一定的开关和电路组合，选择出自己想要的信号，同时也可以把需要运行的指令码，通过译码器找出期望执行的指令（即 opcode），以及后面对应的操作数或者寄存器地址。")]),_._v(" "),v("h3",{attrs:{id:"_4-5-建立数据通路，构造一个最简单的-cpu"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-5-建立数据通路，构造一个最简单的-cpu"}},[_._v("#")]),_._v(" 4.5 建立数据通路，构造一个最简单的 CPU")]),_._v(" "),v("p",[_._v("通过 D 触发器、自动计数器以及译码器，再加上 ALU，可以构造出一个 CPU：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://static001.geekbang.org/resource/image/68/71/6863e10fc635791878d1ecd57618b871.jpeg",alt:""}})]),_._v(" "),v("ol",[v("li",[_._v("自动计数器随着时钟主频不断自增，作为一个程序计数器；")]),_._v(" "),v("li",[_._v("自动计数器后面连接一个译码器，译码器则连接着存储器（通常是内存）；")]),_._v(" "),v("li",[_._v("自动计数器从译码器当中找到计数所对应的内存地址，读取里面的 CPU 指令；")]),_._v(" "),v("li",[_._v("读取出来的 CPU 会通过事中控制，写入到一个 D 型触发器构成的寄存器，即指令寄存器；")]),_._v(" "),v("li",[_._v("指令寄存器后面跟着一个指令译码器，将其解析成 opcode 和对应的操作数；")]),_._v(" "),v("li",[_._v("对应的 opcode 以及操作数输出到 ALU，进行各种逻辑运算，再会写到寄存器或者内存中。")])]),_._v(" "),v("blockquote",[v("p",[_._v("NOTE：高级语言中的 if...else  被翻译成了 cmp 以及 jmp 指令而不是一条复杂的指令，其实就对应了电路层面的 “译码 - 执行 - 更新寄存器” 的步骤。")])]),_._v(" "),v("p",[_._v("执行一条指令，并不一定需要在一个时钟周期里完成，比如程序计数器的自增，写入指令到指令寄存器完全可以分在两个时钟周期完成。")]),_._v(" "),v("p",[v("strong",[_._v("由于从内存里读取指令的时间很长，这些不同指令执行速度的差异，也正是计算机指令有指令周期、CPU 周期和时钟周期之分的原因")]),_._v("。")])])}),[],!1,null,null,null);t.default=a.exports}}]);