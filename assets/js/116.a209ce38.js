(window.webpackJsonp=window.webpackJsonp||[]).push([[116],{838:function(t,s,a){"use strict";a.r(s);var n=a(70),r=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("数组元素在内存中是连续存在的，当需要对数组内容进行访问时，可以通过"),a("strong",[t._v("向量化")]),t._v("的方式增大单指令处理的数据量。")]),t._v(" "),a("p",[t._v("X86_64 体系架构上通用寄存器的大小为 64 位（即 8 个字节），无法暂存连续几个 int、long 这类超长的数据，因此会借助长度足够的 "),a("strong",[t._v("XMM 寄存器")]),t._v("来完成 int 数组与 long 数组的向量化读取和写入操作。")]),t._v(" "),a("blockquote",[a("p",[t._v("NOTE： byte 数组的向量化读取、写入操作同样使用了 XMM 寄存器。")])]),t._v(" "),a("p",[t._v("XMM 寄存器，是由 SSE（Streaming SIMD Extensions）指令集所引入的，仅有 128 位。CPU 引入 AVX（Advanced Vector Extensions）指令集后（2011 年），XMM 寄存器便升级为 256 位，并更名为 YMM 寄存器。原本的 XMM 寄存器指令，会使用 YMM 的低 128 位。ZMM 为更新的寄存器，有 512位。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/56/f2/56cb8c99ce8a80d1c510ef50122616f2.png",alt:""}})]),t._v(" "),a("p",[t._v("SSE 指令集以及之后的 AVX 指令集都涉及了一个重要的概念："),a("strong",[t._v("单指令流多数据流（Single Instruction Multiple Data，SIMD）")]),t._v("，即通过单条指令操控多组数据的计算操作。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/8a/cf/8ad6be0e44c4f14b45c7c8c4cf6eabcf.png",alt:""}})]),t._v(" "),a("p",[t._v("SIMD 指令将 XMM 寄存器（或 YMM 寄存器、ZMM 寄存器）中的值看成多个整数或者浮点数组成的"),a("strong",[t._v("向量")]),t._v("，并且"),a("strong",[t._v("批量进行计算")]),t._v("。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/d6/40/d61b5f38e3736acf3447412888a32b40.png",alt:""}})]),t._v(" "),a("p",[t._v("SIMD 指令PADDB、PADDW、PADDD以及PADDQ，将分别实现 byte 值、short 值、int 值或者 long 值的向量加法。")]),t._v(" "),a("blockquote",[a("p",[t._v("NOTE：内存右边为高位，寄存器左边为高位，因此相反。")])]),t._v(" "),a("h2",{attrs:{id:"_1-使用-simd-指令的-hotspot-intrinsic"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-使用-simd-指令的-hotspot-intrinsic"}},[t._v("#")]),t._v(" 1. 使用 SIMD 指令的 HotSpot Intrinsic")]),t._v(" "),a("p",[t._v("使用 SIMD 较为麻烦，需要解决各种问题，首先是不同平台有不同的 SIMD 指令，而由于 Java 字节码是平台无关的，在 JVM 中运行的时候，已经可以知道平台支持的指令了。")]),t._v(" "),a("p",[t._v("但是，Java 字节码的平台无关性却引发了另一个问题，那便是 Java 程序无法像 C++ 程序那样，直接使用由 Intel 提供的直接替换为具体 SIMD 指令的 intrinsic 方法。")]),t._v(" "),a("p",[t._v("HotSpot 虚拟机提供的替代方案是 "),a("strong",[t._v("Java 层面的 intrinsic 方法")]),t._v("，比起单个 SIMD 复杂得多。")]),t._v(" "),a("p",[t._v("HotSpot intrinsic 是虚拟机开发人员根据其语义定制的一套高效实现，调用了 SIMD ，维护成本较高，且覆盖面也较少，只能实现点的覆盖。")]),t._v(" "),a("blockquote",[a("p",[t._v("NOTE： 常见的 Java intrinsic 有 Math 库的函数，以及 System 库。")])]),t._v(" "),a("p",[t._v("在不少情况下，应用程序并不会用到这些 intrinsic 的语义，却又存在向量化优化的机会，这时候，需要借助 JIT 中的"),a("strong",[t._v("自动向量化（auto vectorization）")]),t._v("。")]),t._v(" "),a("h2",{attrs:{id:"_2-自动向量化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-自动向量化"}},[t._v("#")]),t._v(" 2. 自动向量化")]),t._v(" "),a("p",[t._v("JIT 的自动向量化将针对"),a("strong",[t._v("能够展开的计数循环")]),t._v("，进行向量化优化：")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" c"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" c"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    c"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br")])]),a("p",[t._v("自动向量化需要满足几个条件：")]),t._v(" "),a("ol",[a("li",[t._v("循环变量的增量应为 1，即能够遍历整个数组。")]),t._v(" "),a("li",[t._v("必须为计数循环。")]),t._v(" "),a("li",[t._v("循环迭代之间最好不要有数据依赖，例如出现类似于 "),a("code",[t._v("a[i] = a[i-1]")]),t._v(" 的语句。当循环展开之后，循环体内存在数据依赖，那么 C2 无法进行自动向量化。")]),t._v(" "),a("li",[t._v("循环体内不要有分支跳转。")]),t._v(" "),a("li",[a("strong",[t._v("不要手工进行循环展开")]),t._v("。如果 C2 无法自动展开，那么它也将无法进行自动向量化。")])])])}),[],!1,null,null,null);s.default=r.exports}}]);