(window.webpackJsonp=window.webpackJsonp||[]).push([[121],{844:function(_,t,v){"use strict";v.r(t);var e=v(70),r=Object(e.a)({},(function(){var _=this,t=_.$createElement,v=_._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"_1-性能"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-性能"}},[_._v("#")]),_._v(" 1. 性能")]),_._v(" "),v("p",[v("strong",[_._v("性能")]),_._v("，主要有两个衡量标准，一个是"),v("strong",[_._v("响应时间")]),_._v("（Response time）或者叫"),v("strong",[_._v("执行时间")]),_._v("（Execution time），还有一个叫做"),v("strong",[_._v("吞吐率")]),_._v("（Throughput）或者"),v("strong",[_._v("带宽")]),_._v("（Bandwidth）。")]),_._v(" "),v("p",[_._v("通常提升吞吐率较为简单，比如增加机器核数、数量等，但是响应时间较为难提升。因此一般可以将性能定义为响应时间的倒数：\n$$\n性能 = 1 / 响应时间\n$$\n通过时间来衡量存在一个问题，每次执行程序所花费的时间都不一样，这是由于计算机可能同时运行着好多个程序，CPU 在不同的程序之间来回切换，这期间就存在等待所耗费的时间，并且可能还存在着等待网络读取、磁硬盘读取等所耗费的时间。因此"),v("strong",[_._v("要想准确统计某个程序运行时间，进而去比较两个程序的实际性能，我们得把这些时间给刨除掉")]),_._v("。")]),_._v(" "),v("p",[_._v("Linux 有一个 time 命令，可以统计出在运行程序所花费的时间（"),v("strong",[_._v("real time")]),_._v("）里，有多少时间是真正在运行程序（"),v("strong",[_._v("user time")]),_._v(" + "),v("strong",[_._v("sys time")]),_._v("）的。")]),_._v(" "),v("blockquote",[v("p",[_._v("有时候看到 user time + sys time 大于 real time，是因为执行的计算机是多核。")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://static001.geekbang.org/resource/image/0b/00/0b340db019d7e389a2bde4c237ee4700.jpg",alt:""}})]),_._v(" "),v("p",[_._v("即使拿到了 CPU 时间，但 CPU 可能存在满载、降频等情况，所以比较结果也不一定准确，因此还需要对时间继续进行拆解，把程序的 CPU 执行时间变成 **CPU 时钟周期数（CPU Cycles）**和 **时钟周期时间（Clock Cycle）**的乘积：\n$$\n程序的 CPU 执行时间 =CPU 时钟周期数×时钟周期时间\n$$")]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("CPU 时钟周期时间")]),_._v("：CPU 的主频，表示 CPU 周期与周期之间的最小时间间隔，频率越高，间隔越小，这个是由晶体振荡器（Oscillator Crystal，晶振）完成的，将其作为 CPU 内部电子表，每一次转动就相当于一次周期时间。")]),_._v(" "),v("li",[v("strong",[_._v("CPU 时钟周期数")]),_._v("：在执行时间不变的前提下，CPU 时钟周期时间越小，时钟周期数越大。也就是说， CPU 频率越高，单位时间内所能够执行的周期数也就越多，而一个指令的完成往往需要几个周期。")])]),_._v(" "),v("p",[_._v("时钟周期时间取决于硬件，软件方面无法控制，因此从软件角度优化需要从 CPU 时钟周期数着手。")]),_._v(" "),v("p",[_._v("对于 CPU 时钟周期数，可以转化为 “"),v("strong",[_._v("指令数×每条指令的平均时钟周期数（Cycles Per Instruction，简称 CPI）")]),_._v("”。不同的指令需要的时钟周期也不一样，因此对于软件方面来说，最终程序的执行时间公式如下：\n$$\n程序的 CPU 执行时间 = 指令数×CPI×时钟周期时间\n$$")]),_._v(" "),v("hr"),_._v(" "),v("h2",{attrs:{id:"_2-功耗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-功耗"}},[_._v("#")]),_._v(" 2. 功耗")]),_._v(" "),v("p",[_._v("CPU，一般都被叫作超大规模集成电路（Very-Large-Scale Integration，VLSI），这些电路都是由一个个晶体管组合而成的，CPU 在运算的时候，就是借助晶体管来组合完成各种运算和功能。")]),_._v(" "),v("p",[_._v("因此，要提高 CPU 性能，可以通过两个途径：")]),_._v(" "),v("ol",[v("li",[_._v("在同样的 CPU 面积里，多放一些晶体管，即"),v("strong",[_._v("增加密度")]),_._v("（增加晶体管可以增加硬件能够支持的指令数量，增加数字通路的位数，以及利用好电路天然的并行性，从硬件层面更快地实现特定的指令）；")]),_._v(" "),v("li",[_._v("让晶体管速度更快，也就是"),v("strong",[_._v("提升主频")]),_._v("。这两者都会增加功耗，带来耗电和散热问题。")])]),_._v(" "),v("p",[_._v("一个 CPU 的功率，可以用这样一个公式来表示："),v("strong",[_._v("功耗 ~= 1/2 × 负载电容 × 电压^2 × 开关频率 × 晶体管数量")]),_._v("。")]),_._v(" "),v("p",[_._v("从公式来看，功耗跟电压的平方成正比，因此降低电压是一种收益较为明显的方式。")]),_._v(" "),v("p",[_._v("从增加密度这点来看，这也是为什么越是高端的芯片，越是对芯片的制程有要求。")]),_._v(" "),v("p",[_._v("但是 CPU 的主频到达一定瓶颈以后已经很难再上去了，会受到功耗的制约，因此只能转而"),v("strong",[_._v("通过并行提高性能")]),_._v("。")]),_._v(" "),v("p",[_._v("并行提高性能遵循"),v("strong",[_._v("阿姆达尔定律（Amdahl’s Law）")]),_._v("，对于一个程序进行优化之后，处理器并行运算之后效率提升的情况。具体可以用这样一个公式来表示：\n$$\n优化后的执行时间 = 受优化影响的执行时间 / 加速倍数 + 不受影响的执行时间\n$$\n也就是想要通过并行提高性能，首先得计算之间可以相互拆分，彼此之间没有依赖，这部分可以优化。至于无法拆分的那部分，就属于不受影响的执行时间。并行加速效果如下：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://static001.geekbang.org/resource/image/f1/e5/f1d05ec439e6377803df741bc07b09e5.jpeg",alt:""}})]),_._v(" "),v("p",[_._v("可以看到，并行加速的收益是逐渐下降的，总存在一部分时间是无法通过并行加速的。")]),_._v(" "),v("h2",{attrs:{id:"_3-总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-总结"}},[_._v("#")]),_._v(" 3. 总结")]),_._v(" "),v("p",[_._v("在优化性能可以从以下几方面入手：")]),_._v(" "),v("ol",[v("li",[v("p",[v("strong",[_._v("时钟周期时间")]),_._v("，取决于计算机主频，并且这个时间往往是按照"),v("strong",[_._v("放下最复杂的一条指令的时间长度")]),_._v("来算的。主频的提升可以参考"),v("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E6%91%A9%E5%B0%94%E5%AE%9A%E5%BE%8B",target:"_blank",rel:"noopener noreferrer"}},[_._v("摩尔定律"),v("OutboundLink")],1),_._v("，但近年来 CPU 的性能发展逐渐到达瓶颈，摩尔定律逐渐失效。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://static001.geekbang.org/resource/image/18/80/1826102a89e4cdd31f7573db53dd9280.png",alt:""}})])]),_._v(" "),v("li",[v("p",[_._v("每条指令的"),v("strong",[_._v("平均时钟周期数 CPI")]),_._v("，这里的，现代的 CPU 通过流水线技术（Pipeline），让一条指令需要的 CPU Cycle 尽可能地少。")])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("指令数")]),_._v("，表示我们的程序需要多少条指令，这个往往交由编译器去做，相同的代码，编译成计算机指令的时候，就有各种不同的表示方式。")])]),_._v(" "),v("li",[v("p",[_._v("并行计算。")])]),_._v(" "),v("li",[v("p",[_._v("加速大概率事件，比如向量和矩阵运算使用 GPU ，缓存，热点代码等。")])]),_._v(" "),v("li",[v("p",[_._v("通过流水线提高性能，将 CPU 指令执行的过程进行拆分，减少 CPI，但过长的流水线也会带来新的功耗和效率方面的影响。")])]),_._v(" "),v("li",[v("p",[_._v("通过预测提高性能，比如分支冒险（JVM 的 JIT 优化）、局部性原理、预读取等。")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);