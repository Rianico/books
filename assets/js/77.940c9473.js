(window.webpackJsonp=window.webpackJsonp||[]).push([[77],{799:function(v,_,t){"use strict";t.r(_);var a=t(70),s=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"cpu-的三种工作模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cpu-的三种工作模式"}},[v._v("#")]),v._v(" CPU 的三种工作模式")]),v._v(" "),t("p",[v._v("CPU 的工作模式有"),t("strong",[v._v("实模式、保护模式、长模式")]),v._v("：")]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("实模式")]),v._v("，早期 CPU 是为了支持单道程序运行而实现的，单道程序能掌控计算机所有的资源，仅支持 16 位地址空间，"),t("strong",[v._v("分段的内存模型")]),v._v("，"),t("strong",[v._v("对指令不加限制地运行")]),v._v("，对内存没有保护隔离作用。")]),v._v(" "),t("li",[v._v("保护模式，为了应对多道程序的出现，避免出现一个程序危害到其他程序的情况， CPU 实现了保护模式。通过增加了"),t("strong",[v._v("特权级")]),v._v("的概念，对指令及其访问的资源进行控制，对"),t("strong",[v._v("内存段与段之间")]),v._v("的访问进行严格检查，没有权限的不放行，对中断的响应也要进行严格的权限检查，扩展了 CPU 寄存器位宽，使之能够寻址 32 位的内存地址空间和处理 32 位的数据，从而 CPU 的性能大大提高。")]),v._v(" "),t("li",[v._v("长模式，又名 AMD64 模式，在保护模式的基础上，把寄存器扩展到 64 位同时增加了一些寄存器，使 CPU 具有了能处理 64 位数据和寻址 64 位的内存地址空间的能力。")])]),v._v(" "),t("p",[t("strong",[v._v("硬件中断")]),v._v("，由硬件（中断控制器）发起一个电子信号给 CPU，CPU 做出应答后，硬件发送中断信号给 CPU。")]),v._v(" "),t("p",[t("strong",[v._v("软件中断")]),v._v("，即 CPU 执行了 "),t("strong",[v._v("INT 指令")]),v._v("，后面跟着一个数字。")]),v._v(" "),t("p",[v._v("为了实现中断，需要在内存中维护一个"),t("strong",[v._v("中断向量表")]),v._v("，表中维护着描述符，CPU 能够根据中断中断号，通过中断向量表寻址到需要执行的代码及指令。")]),v._v(" "),t("h2",{attrs:{id:"虚拟内存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#虚拟内存"}},[v._v("#")]),v._v(" 虚拟内存")]),v._v(" "),t("p",[v._v("虚拟内存用于解决多个程序之间的内存共享问题，需要 MMU 结合 TLB，将程序的虚拟内存转换为实际的物理内存并传递给 CPU。")]),v._v(" "),t("p",[v._v("32 位地址模式下，使用 CPU 保护模式，最大只能表示 4G 内存空间：")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("高 10bit 地址表示"),t("strong",[v._v("页目录索引")]),v._v("，对应 1024 个页表")])]),v._v(" "),t("li",[t("p",[v._v("接下来 10bit 表示"),t("strong",[v._v("页表索引")]),v._v("，对应 1024 个物理页")])]),v._v(" "),t("li",[t("p",[v._v("低 12bit 表示偏移量，对应 4KB")])])]),v._v(" "),t("p",[v._v("三者相乘正好等于 4GB。")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://static001.geekbang.org/resource/image/00/f8/00b7f1ef4a1c4f6fc9e6b69109ae0bf8.jpg",alt:"img"}})]),v._v(" "),t("p",[v._v("CPU 长模式下则可以使用 64 位地址，但当前操作系统最多中用到了内存地址中的 0 到 47 位，剩余的 48 ~ 63 位作为保留。")]),v._v(" "),t("blockquote",[t("p",[v._v("NOTE：JVM 中的 ZGC 就是利用了保留的 bit ，实现了染色指针算法。")])]),v._v(" "),t("p",[v._v("不同进程拥有不同的页表，并且是由操作系统分配的，从而形成了进程空间隔离。")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://static001.geekbang.org/resource/image/d4/y0/d43c10bbb1a1159d9da7d3b14a3cfyy0.jpg",alt:"img"}})]),v._v(" "),t("h2",{attrs:{id:"高速缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#高速缓存"}},[v._v("#")]),v._v(" 高速缓存")]),v._v(" "),t("p",[t("strong",[v._v("局部性原理")]),v._v("：CPU 大多数时间在访问相同或者相邻的数据。")]),v._v(" "),t("p",[v._v("为了解决 CPU 与内存之间速度不一致的问题，通过一块小而块的存储器，放在 CPU 与内存之间，并借助局部性原理，批量的先办数据、指令加载到缓存中，CPU 则从缓存中获取自己想要的数据。缓存可以做成独立芯片放在总线上，也可以集成在 CPU 内部：")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://static001.geekbang.org/resource/image/47/56/474189597993406a01a2ae171b754756.jpg",alt:"img"}})]),v._v(" "),t("p",[v._v("高速缓存会把自己分成大小相同的行，一行大小通常为 32 bytes 或者 64 bytes，称为缓存行。通常多个行又会形成一组。")]),v._v(" "),t("p",[v._v("随着多核时代的来临，带来了"),t("strong",[v._v("多核心之间缓存不一致")]),v._v("的问题，多核心之间的结构通常如下：")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://static001.geekbang.org/resource/image/97/bd/976f5cf91bc656e2a876235a5d2efabd.jpg",alt:"img"}})]),v._v(" "),t("p",[v._v("在单核情况下，以 Java 为例，当 Java 在运行时修改了一处指令，这时这部分还只属于数据上的修改，因此新的指令数据会进入数据 Cache，写入地址 A。后续执行地址 A 处指令的时候，指令 Cache 的指令可能是过时的，因此需要把数据 Cache 中地址 A 的数据写入到内存中，并将指令 Cache 的指令置为失效，重新从内存中获取。")]),v._v(" "),t("p",[v._v("多核场景下，如果第一个核心修改了缓存内地址 A 的数据，如果第二个核心也需要访问地址 A 数据，那么也会在自己的缓存内存储一份相同的数据。但是当第一个核心修改地址 A 数据的时候，第二个核心内的缓存数据不一致了。")]),v._v(" "),t("p",[v._v("为了多核心缓存的解决一致性问题，硬件工程师开发了多种协议，其中最出名的就是 "),t("strong",[v._v("MESI 协议")]),v._v("。")]),v._v(" "),t("p",[v._v("MESI 协议定义了 4 种基本状态：M、E、S、I，即"),t("strong",[v._v("修改（Modified）")]),v._v("、"),t("strong",[v._v("独占（Exclusive）")]),v._v("、"),t("strong",[v._v("共享（Shared）"),t("strong",[v._v("和")]),v._v("无效（Invalid）")]),v._v("：")]),v._v(" "),t("ul",[t("li",[v._v("修改：当前数据在 Cache 内有效，仅存在一个核心缓存中，有经过修改且与内存中的数据不一致。")]),v._v(" "),t("li",[v._v("独占：当前数据在 Cache 内有效，仅存在一个核心缓存中，且与内存中数据一致。")]),v._v(" "),t("li",[v._v("共享：当前数据在 Cache 内有效，且存在多个核心缓存中，且与内存中数据一致。")]),v._v(" "),t("li",[v._v("无效：不属于前面几种状态下的数据都属于无效。")])]),v._v(" "),t("p",[v._v("这个协议是由硬件端保证的，对软件透明，但编写软件时需要注意这个问题。")]),v._v(" "),t("p",[v._v("由于一个缓存行通常能存储多条数据，且硬件判断无效的粒度为缓存行级别，因此一旦一条数据失效后，可能会导致相邻有效的数据也跟着被淘汰，即 CPU 中的为共享。")])])}),[],!1,null,null,null);_.default=s.exports}}]);