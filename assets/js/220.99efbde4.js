(window.webpackJsonp=window.webpackJsonp||[]).push([[220],{943:function(e,a,r){"use strict";r.r(a);var t=r(70),n=Object(t.a)({},(function(){var e=this,a=e.$createElement,r=e._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"cpu-cache-与缓存行"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cpu-cache-与缓存行"}},[e._v("#")]),e._v(" CPU Cache 与缓存行")]),e._v(" "),r("h2",{attrs:{id:"_1-cache-line-and-coherency"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-cache-line-and-coherency"}},[e._v("#")]),e._v(" 1. Cache Line and Coherency")]),e._v(" "),r("p",[e._v("现代处理器会使用多级缓存来加速处理，当处理器访问一个对象时，会对其进行缓存，同时根据"),r("strong",[e._v("空间局部性")]),e._v("原理，还会将其相邻的对象也一并放到"),r("strong",[e._v("缓存行（Cache Line）")]),e._v("，这种方式可以显著地提升应用的整体性能表现。")]),e._v(" "),r("p",[e._v("然而当多个处理器同时操作相邻内存的数据时，就会破坏这种优化，不同的处理器之间，需要有一个方式来维护彼此缓存行中相同对象的一致性（即"),r("strong",[e._v("缓存一致性")]),e._v("）。")]),e._v(" "),r("p",[e._v("有许多协议能够维护不同 CPU 核心之间的缓存一致性，其中最常见的就是 "),r("strong",[e._v("MESI 协议")]),e._v("。")]),e._v(" "),r("h3",{attrs:{id:"_1-1-mesi-协议"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-mesi-协议"}},[e._v("#")]),e._v(" 1.1. MESI 协议")]),e._v(" "),r("p",[e._v("在 MESI 协议中，每个缓存行只会处于四种状态中："),r("strong",[e._v("Modified, Exclusive, Shared 以及 Invalid")]),e._v("。")]),e._v(" "),r("p",[e._v("为了更好地理解，可以通过以下例子来说明：")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://www.baeldung.com/wp-content/uploads/2020/07/false-sharing-exclusive-1.png",alt:"img"}})]),e._v(" "),r("p",[e._v("Core A 从主存中读取对象 a ，这时候会连通相邻对象 b 也一并缓存到缓存行中，"),r("strong",[e._v("这时只有 Core A 在操作这个缓存行，因此这个缓存行会被标记为 Exclusive")]),e._v("。")]),e._v(" "),r("p",[e._v("过了一会，Core B 决定从主存中读取 b 对象，a 与 b 又被同时缓存到同一个缓存行，这时候 Core A 跟 Core B 都会将对应的缓存行标记为 "),r("strong",[e._v("Shared")]),e._v("：")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://www.baeldung.com/wp-content/uploads/2020/07/false-sharing-shared.png",alt:""}})]),e._v(" "),r("p",[e._v("接下来 Core A 决定修改 a 的值， Core A 会将缓存行标记为 "),r("strong",[e._v("Modified")]),e._v("，同时也会向 Core B 传递信息，Core B 则会将自己对应的缓存行标记为 "),r("strong",[e._v("Invalid")]),e._v("：")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://www.baeldung.com/wp-content/uploads/2020/07/false-sharing-invalid.png",alt:""}})]),e._v(" "),r("p",[e._v("由于 Core B 的缓存行被标记为 "),r("strong",[e._v("Invalid")]),e._v("，这时候如果要读取 b，只能重新从主存中获取，"),r("strong",[e._v("同时为了缓存 a 最新的值，还会触发 Core A 将 a 提前 flush 到主存中")]),e._v("。")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://www.baeldung.com/wp-content/uploads/2020/07/false-sharing-flush.png",alt:""}})]),e._v(" "),r("p",[e._v("在 Core B 重新缓存之后，两个 CPU 核心又重新处于 "),r("strong",[e._v("Shared")]),e._v(" 状态。")]),e._v(" "),r("p",[e._v("如果频繁发生这种情况，CPU 缓存的作用就失去了意义，一旦相邻的缓存值（即使是不相关的值）发生变化，就可能导致 CPU 需要重新从主存中取值，这种称之为"),r("strong",[e._v("伪共享")]),e._v("。")]),e._v(" "),r("h2",{attrs:{id:"_2-消除伪共享"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-消除伪共享"}},[e._v("#")]),e._v(" 2. 消除伪共享")]),e._v(" "),r("p",[e._v("消除伪共享的方式，主要就是通过"),r("strong",[e._v("字节填充")]),e._v("方式，使得一个对象能够刚好占用一个缓存行，在 Java 7 之前，都是通过添加一些无实际意义的字段来进行填充，但从 Java 7 开始，一些无意义的字段会被自动优化掉，这时候有两个选择：将无意义的填充字段放到父类中，或者使用 Java 8 的 "),r("code",[e._v("@Contended")]),e._v(" 注解。")]),e._v(" "),r("p",[r("code",[e._v("@Contended")]),e._v(" 注解会自动为对象添加填充内容，达到字节填充的效果，默认只对 JDK 内部实现的类生效，如果想要我们自定义的类生效，则需要为 JVM 添加  "),r("em",[r("a",{attrs:{href:"https://github.com/openjdk/jdk/blob/195c45a0e11207e15c277e7671b2a82b8077c5fb/src/hotspot/share/runtime/globals.hpp#L777",target:"_blank",rel:"noopener noreferrer"}},[e._v("-XX:-RestrictContended"),r("OutboundLink")],1)]),e._v(" 参数。")]),e._v(" "),r("p",[e._v("默认情况下，"),r("code",[e._v("@Contended")]),e._v(" 会添加 128 bytes 的字节填充，这主要是因为许多现代处理器的缓存行大小都是"),r("strong",[e._v("64/128 bytes")]),e._v("，该参数值可以通过  "),r("em",[r("a",{attrs:{href:"https://github.com/openjdk/jdk/blob/7436ef236e4826f93df1af53c4aa73429afde41f/src/hotspot/share/runtime/globals.hpp#L769",target:"_blank",rel:"noopener noreferrer"}},[e._v("-XX:ContendedPaddingWidth"),r("OutboundLink")],1)]),e._v(" 指定，取值范围为 0 ~ 8192。")]),e._v(" "),r("p",[e._v("如果要关闭 "),r("code",[e._v("@Contented")]),e._v(" ，则可以添加 "),r("em",[r("a",{attrs:{href:"https://github.com/openjdk/jdk/blob/7436ef236e4826f93df1af53c4aa73429afde41f/src/hotspot/share/runtime/globals.hpp#L774",target:"_blank",rel:"noopener noreferrer"}},[e._v("-XX:-EnableContended"),r("OutboundLink")],1)]),e._v(" ，在内存资源紧张的情况下可以考虑，但会损失一点（也可能是很多）性能。")]),e._v(" "),r("h2",{attrs:{id:"_3-伪共享对性能的影响"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-伪共享对性能的影响"}},[e._v("#")]),e._v(" 3. 伪共享对性能的影响")]),e._v(" "),r("p",[e._v("网上对伪共享的测试例子有很多，但见过最好的例子在这篇"),r("a",{attrs:{href:"https://www.baeldung.com/java-false-sharing-contended#example",target:"_blank",rel:"noopener noreferrer"}},[e._v("文章"),r("OutboundLink")],1),e._v("里，除了通过 Benchmark 进行压测外，还使用了 Perf 从 CPU 底层时间来进行对比，就结果而言，消除了伪共享的测试用例里 "),r("code",[e._v("L1-dcache-load-misses")]),e._v(" 低了一个量级。")]),e._v(" "),r("p",[e._v("这里有一些优秀的实现案例：")]),e._v(" "),r("ul",[r("li",[r("strong",[e._v("Thread#threadLocalRandomSeed")])]),e._v(" "),r("li",[r("strong",[e._v("RingBuffer")])]),e._v(" "),r("li",[e._v("The "),r("em",[r("a",{attrs:{href:"https://github.com/openjdk/jdk/blob/195c45a0e11207e15c277e7671b2a82b8077c5fb/src/java.base/share/classes/java/util/concurrent/atomic/Striped64.java#L124",target:"_blank",rel:"noopener noreferrer"}},[e._v("Striped64"),r("OutboundLink")],1)]),e._v(" class to implement "),r("a",{attrs:{href:"https://www.baeldung.com/java-longadder-and-longaccumulator#dynamic-striping",target:"_blank",rel:"noopener noreferrer"}},[e._v("counters and accumulators"),r("OutboundLink")],1),e._v(" with high throughput")]),e._v(" "),r("li",[e._v("The "),r("em",[r("a",{attrs:{href:"https://github.com/openjdk/jdk/blob/b0e1ee4b3b345b729d14b897d503777ff779d573/src/java.base/share/classes/java/lang/Thread.java#L2059",target:"_blank",rel:"noopener noreferrer"}},[e._v("Thread"),r("OutboundLink")],1)]),e._v(" class to facilitate the implementation of "),r("a",{attrs:{href:"https://www.baeldung.com/java-thread-local-random#implementation-details",target:"_blank",rel:"noopener noreferrer"}},[e._v("efficient random number generators"),r("OutboundLink")],1)]),e._v(" "),r("li",[e._v("The "),r("em",[r("a",{attrs:{href:"https://github.com/openjdk/jdk/blob/1e8806fd08aef29029878a1c80d6ed39fdbfe182/src/java.base/share/classes/java/util/concurrent/ForkJoinPool.java#L774",target:"_blank",rel:"noopener noreferrer"}},[e._v("ForkJoinPool"),r("OutboundLink")],1)]),e._v(" work-stealing queue")]),e._v(" "),r("li",[e._v("The "),r("em",[r("a",{attrs:{href:"https://github.com/openjdk/jdk/blob/f29d1d172b82a3481f665999669daed74455ae55/src/java.base/share/classes/java/util/concurrent/ConcurrentHashMap.java#L2565",target:"_blank",rel:"noopener noreferrer"}},[e._v("ConcurrentHashMap#CountCell"),r("OutboundLink")],1)]),e._v(" implementation")]),e._v(" "),r("li",[e._v("The "),r("a",{attrs:{href:"http://www.cs.rochester.edu/research/synchronization/pseudocode/duals.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("dual data structure"),r("OutboundLink")],1),e._v(" used in the "),r("em",[r("a",{attrs:{href:"https://github.com/openjdk/jdk/blob/4d1445f42ee5fd98609cb9977a648bf58ec2c6c7/src/java.base/share/classes/java/util/concurrent/Exchanger.java#L305",target:"_blank",rel:"noopener noreferrer"}},[e._v("Exchanger"),r("OutboundLink")],1)]),e._v(" class")])])])}),[],!1,null,null,null);a.default=n.exports}}]);