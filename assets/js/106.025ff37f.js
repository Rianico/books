(window.webpackJsonp=window.webpackJsonp||[]).push([[106],{828:function(t,a,s){"use strict";s.r(a);var n=s(70),e=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("Java 采用"),s("strong",[t._v("可达性分析算法")]),t._v("来标记垃圾，这个算法将一系列 GC Roots 作为初始的"),s("strong",[t._v("存活对象集合（live set）")]),t._v("，然后从该集合出发，探索该集合的引用链，并将链上的对象都加入该集合，这个过程也称为"),s("strong",[t._v("标记（mark）")]),t._v("。未被标记的集合将会被当做垃圾回收。")]),t._v(" "),s("p",[t._v("GC Roots：")]),t._v(" "),s("ul",[s("li",[t._v("Java 方法栈帧中的局部变量；")]),t._v(" "),s("li",[t._v("已加载类的静态变量；")]),t._v(" "),s("li",[t._v("JNI handles；")]),t._v(" "),s("li",[t._v("已启动且未停止的 Java 线程（多线程下容易出现内存泄漏的场景之一）。")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://static001.geekbang.org/resource/image/85/b9/8546a9b3c6660a31ae24bef0ef0a35b9.png",alt:""}})]),t._v(" "),s("p",[t._v("可达性分析算法在实践中需要解决一些问题，在多线程环境下，标记可能存在：")]),t._v(" "),s("ul",[s("li",[t._v("误报：某个被引用的对象在标记过后，又被其他线程将其引用修改为 null。")]),t._v(" "),s("li",[t._v("漏报：某个对象被标记为垃圾后，又被其他线程引用了。")])]),t._v(" "),s("p",[t._v("误报尚可接收，只不过失去了一次回收的机会，而漏报则会导致实质上引用的对象被回收，造成不可预期的错误。")]),t._v(" "),s("h2",{attrs:{id:"_1-stop-the-world-以及安全点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-stop-the-world-以及安全点"}},[t._v("#")]),t._v(" 1. Stop-the-world 以及安全点")]),t._v(" "),s("p",[t._v("传统的 GC 算法采用一种简单粗暴的算法：Stop-the-world，停止其他非垃圾回收线程的工作，直到 GC 完成。")]),t._v(" "),s("p",[t._v("Stop-the-world 是通过**安全点（safepoint）**机制来实现的，当需要 GC 时，会等待所有线程到达安全点，然后才允许 GC 线程执行一些独占的操作。")]),t._v(" "),s("blockquote",[s("p",[t._v("NOTE：安全点本身的目的并不是让其他线程停止，而是找到一个稳定的执行状态，这个状态下，JVM 的堆栈不会发生变化。")])]),t._v(" "),s("p",[t._v("比如 Java 通过 JNI 的 API 执行本地代码，这段本地代码不访问 Java 对象、调用  Java 代码或者返回至原 Java 代码，那么这段本地代码就可以作为一个安全点，同时这个 API 的入口处也可以进行安全点监测（safepoint poll），测试是否有其他线程请求停留在安全点里，可以在必要的时候挂起该线程。")]),t._v(" "),s("p",[t._v("除了"),s("strong",[t._v("执行 JNI 本地代码")]),t._v("外，Java 线程还有其他几种状态：")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("线程阻塞")]),t._v("：此时处于 JVM 线程调度器的掌控下，因此属于安全点。")]),t._v(" "),s("li",[s("strong",[t._v("解释执行字节码")]),t._v("：字节码与字节码之间皆可以作为安全点，当有安全点请求时，执行一条字节码便进行一次安全点检测。")]),t._v(" "),s("li",[s("strong",[t._v("执行即时编译器生成的机器码")]),t._v("：由于 JIT 生成的机器码是直接在底层硬件执行，不受 JVM 掌控，因此 JVM 采取的做法是在"),s("strong",[t._v("生成代码的方法出口")]),t._v("以及"),s("strong",[t._v("非计数循环回边（back-edge）处")]),t._v("插入安全点检测。")])]),t._v(" "),s("p",[t._v("不每条机器码都插入安全点的原因：")]),t._v(" "),s("ol",[s("li",[t._v("安全点本身也有一定的开销，JVM 中已经将机器码中安全点检测简化为一个内存访问操作。当有安全点请求时，JVM 会将安全点对应的内存设置为不可读，并设置一个 segfault 处理器，截获访问该不可读内存的的线程并挂起。")]),t._v(" "),s("li",[t._v("即时编译器生成的机器码打乱了原本栈桢上的对象分布状况。在进入安全点时，机器码还需提供一些额外的信息，来表明哪些寄存器，或者当前栈帧上的哪些内存空间存放着指向对象的引用，以便垃圾回收器能够枚举 GC Roots。")])]),t._v(" "),s("p",[t._v("避免机器码长时间不进入安全点的情况，可以减少垃圾回收的暂停时间。")]),t._v(" "),s("p",[s("strong",[t._v("计数循环默认没有安全点")]),t._v("，当需要 GC 时，如果循环体需要耗费较长时间，那么第一次 GC 时就会迟迟不进入安全点，从而导致莫名的长时间停顿。")]),t._v(" "),s("p",[t._v("GC 日志是不会打印出进入安全点耗时，可以通过 "),s("code",[t._v("-XX:+PrintGCApplicationStoppedTime")]),t._v("  将 JVM 的停顿时间（包括 GC 以及 进入安全点等）打印出来：")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Total")]),t._v(" time "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" which application threads were stopped"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("6.1575928")]),t._v(" seconds"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Stopping")]),t._v(" threads took"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("6.1519059")]),t._v(" seconds\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("同时还可以通过 "),s("code",[t._v("-XX:+PrintSafepointStatistics -XX:PrintSafepointStatisticsCount=1")]),t._v(" 打印安全点耗时统计：")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[t._v("         vmop                    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("threads"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" total initially_running wait_to_block"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("time"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" spin block sync cleanup vmop"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" page_trap_count\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.458")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ParallelGCFailedAllocation")]),t._v("       "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("      "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("12")]),t._v("          "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("              "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("      "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("6151")]),t._v("     "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("6151")]),t._v("     "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("     "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br")])]),s("ul",[s("li",[t._v("0.458：JVM 启动后经过的时间；")]),t._v(" "),s("li",[t._v("vmop：JVM 的操作类型，此处为 GC；")]),t._v(" "),s("li",[t._v("threads：\n"),s("ul",[s("li",[t._v("total：JVM 内的线程数；")]),t._v(" "),s("li",[t._v("initially_running：发起进入安全点信号时，还处于 RUNNING 状态的线程；")]),t._v(" "),s("li",[t._v("wait_to_block：所有线程都不Running时，仍不是Block状态的线程数")])])]),t._v(" "),s("li",[t._v("time：\n"),s("ul",[s("li",[t._v("spin：VMOP 线程自旋等待直到所有线程都不处于 RUNNING 的耗时；")]),t._v(" "),s("li",[t._v("block：VMOP   线程基于锁，等待所有线程处于 BLOCK 的耗时；")]),t._v(" "),s("li",[t._v("sync：spin + block，进入安全点的总耗时；")]),t._v(" "),s("li",[t._v("cleanup：退出清理所用时间；")]),t._v(" "),s("li",[t._v("vmop：真正执行 vmop 的耗时。")])])])]),t._v(" "),s("p",[t._v("有时候打印日志的开销可能比短暂的停顿还大，Hotspot 有提供 API 但没有挂到 JMX 上，可以考虑从应用内吐出：")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("sun"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("management")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("*\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("HotspotRuntimeMBean")]),t._v(" mbean "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("HotspotRuntimeMBean")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ManagementFactoryHelper")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getHotspotRuntimeMBean")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("long")]),t._v(" count "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" mbean"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getSafepointCount")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("long")]),t._v(" time "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" mbean"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getTotalSafepointTime")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("long")]),t._v(" syncTime "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" mbean"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getSafepointSyncTime")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br")])]),s("p",[t._v("或者利用 PerfData，详见 《围绕JVM的各种外挂技术》 以及 github 的一个项目 "),s("a",{attrs:{href:"https://github.com/vipshop/vjtools",target:"_blank",rel:"noopener noreferrer"}},[t._v("VJTools"),s("OutboundLink")],1),t._v("。")]),t._v(" "),s("p",[t._v("如果通过日志发现存在由于计数循环导致的长时间停顿（比如 GC 毛刺），可以通过增加 "),s("code",[t._v("-XX:+UseCountedLoopSafepoints")]),t._v(" 参数，强制每个循环都设置安全点，但这个可能会降低应用的吞吐量。")]),t._v(" "),s("h2",{attrs:{id:"_2-基于分代思想的-gc-算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-基于分代思想的-gc-算法"}},[t._v("#")]),t._v(" 2. 基于分代思想的 GC 算法")]),t._v(" "),s("p",[t._v("大部分场景下， Java 对象生命周期分布如下：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://static001.geekbang.org/resource/image/e2/89/e235d25ca15b60a511a2d90317eb9589.png",alt:""}})]),t._v(" "),s("p",[t._v("基于这个现象，出现了按照生命周期划分内存区域的 GC 算法：将堆空间划分为两代，分别叫做新生代和老年代。")]),t._v(" "),s("p",[t._v("新生代用来存储新建的对象，并使用 Minor GC 来回收垃圾：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("年轻代：Eden 以及两个大小相同的 Survivor 区。")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("动态分配："),s("code",[t._v("-XX:+UsePSAdaptiveSurvivorSizePolicy")]),t._v("，根据生成对象的速率，以及 Survivor 区的使用情况动态调整 Eden 区和 Survivor 区的比例。")])]),t._v(" "),s("li",[s("p",[t._v("固定比例："),s("code",[t._v("-XX:SurvivorRatio")]),t._v("，Eden : Survivor 的比例，比例越低，Survivor 越大，浪费的空间越多。")])]),t._v(" "),s("li",[s("p",[t._v("Eden 区域新建对象，每个线程使用 "),s("code",[t._v("TLAB（ThreadLocal Allocation Buffer）")]),t._v("，申请自己的私有内存空间：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("维护最主要的两个指针，一个指向 TLAB 起始位置，一个指向结束位置；")])]),t._v(" "),s("li",[s("p",[t._v("使用指针加法（bump the pointer）实现 new 指令；")])]),t._v(" "),s("li",[s("p",[t._v("加法后指向空闲位置的指针如果小于结束位置，则表示分配成功，否则申请新的 TLAB。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("Eden 区内存耗尽时，则触发 Minor GC")]),t._v("，收集存活的对象，并送往 Survivor 区。")])])])]),t._v(" "),s("li",[s("p",[t._v("Survivor 区域分为 from 与 to：")]),t._v(" "),s("ul",[s("li",[t._v("Minor GC 时将 Eden 以及 from 区的对象复制到 to 区域，并交换 from 与 to 的指针。")]),t._v(" "),s("li",[t._v("对象生命周期（对象复制次数）到达一定阈值（"),s("code",[t._v("-XX:+MaxTenuringThreshold")]),t._v("，默认 15，动态变化）时，会**晋升（promote）**到老年代。")]),t._v(" "),s("li",[t._v("单个 Survivor 区占用较高（"),s("code",[t._v("-XX:TargetSurvivorRatio")]),t._v("，默认 50%）以上时，较高复制次数的对象也会被晋升至老年代。")])])])])])]),t._v(" "),s("p",[t._v("Minor GC 以对象的年龄分布为前提，避免了整个堆进行扫描，但无法解决跨代引用的问题（老年代对象有新生代的引用），而将老年代作为 GC ROOT 又等于几乎扫描了真个堆。")]),t._v(" "),s("h2",{attrs:{id:"_3-卡表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-卡表"}},[t._v("#")]),t._v(" 3. 卡表")]),t._v(" "),s("p",[t._v("HotSpot 对于跨代引用的解决方案是"),s("strong",[t._v("卡表（Card Table）")]),t._v("，将整个堆划分为一个个 512 byte 的卡，并维护一个卡表，用来存储每张卡的一个标识位，标识位代表对应的卡是否"),s("strong",[t._v("可能")]),t._v("存在跨代引用，如果可能存在，就认为是脏卡。")]),t._v(" "),s("p",[t._v("Minor GC 时，会将卡表中的脏卡加入 GC ROOT 里，完成所有脏卡扫描后，脏卡的标识位便会被清零。")]),t._v(" "),s("p",[t._v("Minor GC 在移动存活对象的时候，又会重新设置引用所在卡的标识位，这时，可以确保脏卡中必定存在指向新生代对象的引用。")]),t._v(" "),s("blockquote",[s("p",[t._v("NOTE：在 Minor GC 之前，无法确保脏卡中必定包含指向新生代对象的引用，这与 JVM 设置脏卡的策略有关。")])]),t._v(" "),s("p",[t._v("为了保证每个指向新生代对象的引用都能被标记为脏卡，JVM 需要截获每个引用型实例变量的写操作，并作出对应的写标识位操作：")]),t._v(" "),s("ul",[s("li",[t._v("解释执行器中容易实现；")]),t._v(" "),s("li",[t._v("JIT 生成的机器码则需要插入额外的逻辑，即写屏障（"),s("code",[t._v("write barrier")]),t._v("，与 volatile 字段的写屏障不同）。")])]),t._v(" "),s("p",[t._v("为了保持简洁，而不是在每条引用型实例变量的写指令后面注入一大串指令，"),s("strong",[t._v("写屏障并不会判断更新后的引用是否指向新生代中的对象，而是一律当成可能指向新生代对象的引用")]),t._v("，这也是为什么脏卡只是可能持有指向新生代对象的引用。")]),t._v(" "),s("p",[t._v("精简后的写屏障：")]),t._v(" "),s("div",{staticClass:"language-c line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[t._v("# "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("9")]),t._v(" 对应着 "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("512")]),t._v(" byte\nCARD_TABLE "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("this address "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("9")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" DIRTY"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br")])]),s("p",[t._v("写屏障不可避免地带来一些开销，但是它能够加大 Minor GC 的吞吐率（ 应用运行时间 /(应用运行时间 + 垃圾回收时间) ）。")]),t._v(" "),s("p",[t._v("卡表由于频繁的写，会带来"),s("strong",[t._v("伪共享")]),t._v("问题，在 HotSpot 中，卡表是通过 byte 数组来实现的。对于一个 64 字节的缓存行来说，如果用它来加载部分卡表，那么它将对应 64 张卡，也就是 32KB 的内存，如果其中一张卡表被修改了，则会导致其他卡表的回写，无效化或者同步操作，间接影响程序性能，可以通过 "),s("code",[t._v("-XX:+UseCondCardMark")]),t._v(" 尽量减少卡表的操作，伪代码如下：")]),t._v(" "),s("div",{staticClass:"language-c line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("CARD_TABLE "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("this address "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("9")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" DIRTY"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" \n  CARD_TABLE "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("this address "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("9")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" DIRTY"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br")])]),s("h2",{attrs:{id:"_4-gc-算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-gc-算法"}},[t._v("#")]),t._v(" 4. GC 算法")]),t._v(" "),s("p",[t._v("新生代：Serial，Parallel Scavenge 和 Parallel New，都采用 "),s("strong",[t._v("标记-复制")]),t._v(" 算法：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("Serial：单线程。")])]),t._v(" "),s("li",[s("p",[t._v("Parallel New： Serial 的多线程版本。")])]),t._v(" "),s("li",[s("p",[t._v("Parallel Scavenge：与 Parallel New 类似，更加注重吞吐率，不能与 CMS 一起使用。")])])]),t._v(" "),s("p",[t._v("老年代：Serial Old、Parallel Old、CMS 以及 G1：")]),t._v(" "),s("ul",[s("li",[t._v("Serial Old：单线程，"),s("strong",[t._v("标记-压缩")]),t._v(" 算法。")]),t._v(" "),s("li",[t._v("Parallel Old：多线程，"),s("strong",[t._v("标记-压缩")]),t._v(" 算法。")]),t._v(" "),s("li",[t._v("CMS：多线程，"),s("strong",[t._v("标记-清除")]),t._v(" 算法，除了少数操作需要 STW，可以在应用程序运行过程中进行 GC。在并发收集失败时，JVM会使用其他两个垃圾回收期进行一次 GC，Java 9 开始被 G1 替代。")]),t._v(" "),s("li",[t._v("G1：横跨新生代和老年代，不再按照分代思想固定划分内存区域，而是将内存划分为多个块。每个块都可以充当 Eden 区、Survivor 区或者老年代中的一个，采用 标记 - 压缩算法，可以在应用程序运行过程中进行 GC。G1 能够针对每个细分的区域来进行垃圾回收，在选择进行垃圾回收的区域时，优先回收死亡对象较多的区域。")]),t._v(" "),s("li",[t._v("ZGC："),s("a",{attrs:{href:"https://www.zhihu.com/question/287945354/answer/458761494",target:"_blank",rel:"noopener noreferrer"}},[t._v("ZGC 原理是什么，它为什么能做到低延时？"),s("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=e.exports}}]);