(window.webpackJsonp=window.webpackJsonp||[]).push([[112],{834:function(t,s,n){"use strict";n.r(s);var a=n(70),r=Object(a.a)({},(function(){var t=this,s=t.$createElement,n=t._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("p",[t._v("intrinsic 从 JDK 9 开始正式引入（JDK 8 只有少量），通过 "),n("code",[t._v("@HotSpotIntrinsicCandidate")]),t._v(" 标记。")]),t._v(" "),n("p",[t._v("HotSpot 虚拟机将为 "),n("code",[t._v("@HotSpotIntrinsicCandidate")]),t._v(" 注解的方法额外维护了一套高效实现。")]),t._v(" "),n("p",[t._v("intrinsic  主要是直接利用处理器的指令来实现比源码更高效的运行方式，当处理器有对应的指令支持时，会忽略 JDK 源码，转而使用高效实现。")]),t._v(" "),n("p",[t._v("比如查看 int 相加是否溢出，intrinsic  会直接访问寄存器的溢出标识位（overflow flag）来判断是否溢出，伪代码如下：")]),t._v(" "),n("div",{staticClass:"language-java line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("addExact")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" x"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" y"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" r "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" x "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" y"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    jo LABEL_OVERFLOW"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// jump if overflow flag set")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" r"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    LABEL_OVERFLOW"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n      "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("throw")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ArithmeticException")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"integer overflow"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// or deoptimize")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[t._v("1")]),n("br"),n("span",{staticClass:"line-number"},[t._v("2")]),n("br"),n("span",{staticClass:"line-number"},[t._v("3")]),n("br"),n("span",{staticClass:"line-number"},[t._v("4")]),n("br"),n("span",{staticClass:"line-number"},[t._v("5")]),n("br"),n("span",{staticClass:"line-number"},[t._v("6")]),n("br"),n("span",{staticClass:"line-number"},[t._v("7")]),n("br"),n("span",{staticClass:"line-number"},[t._v("8")]),n("br")])]),n("h2",{attrs:{id:"intrinsic-与方法内联"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#intrinsic-与方法内联"}},[t._v("#")]),t._v(" intrinsic 与方法内联")]),t._v(" "),n("p",[t._v("HotSpot 虚拟机中，intrinsic 的实现方式分为两种：")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("独立的程序桩，可以被解释执行器利用，直接替换对原方法的调用；也可以被即时编译器所利用，它把代表对原方法的调用的 IR 节点，替换为对这些桩程序的调用的 IR 节点。以这种形式实现的 intrinsic 比较少，主要包括 Math 类中的一些方法。")])]),t._v(" "),n("li",[n("p",[t._v("特殊的编译器 IR 节点，只能够被 JIT 利用，JIT 会对将原方法的 IR 节点替换成特殊的 IR 节点，并参与接下来的优化过程。最终，即时编译器的后端将根据这些特殊的 IR 节点，生成指定的 CPU 指令。")])])]),t._v(" "),n("p",[t._v("大部分的 intrinsic 都是通过第二种方式实现的。这个替换过程是在方法内联时进行的。当即时编译器碰到方法调用节点时，它将查询目标方法是不是 intrinsic，"),n("strong",[t._v("如果是，则插入特殊的 IR 节点，否则进行原本的内联工作")]),t._v("。")]),t._v(" "),n("p",[n("strong",[t._v("不少被标记为 intrinsic 的方法都是 native 方法")]),t._v("。原本对这些 native 方法的调用需要经过 JNI（Java Native Interface），其性能开销十分巨大。但是，经过即时编译器的 intrinsic 优化之后，这部分 JNI 开销便直接消失不见，并且最终的结果也十分高效。")]),t._v(" "),n("p",[t._v("但与此同时，这部分代码对于内联来说属于未知代码，此时"),n("strong",[t._v("并不会对齐进行内联操作")]),t._v("。")])])}),[],!1,null,null,null);s.default=r.exports}}]);