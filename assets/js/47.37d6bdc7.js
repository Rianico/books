(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{789:function(t,n,e){"use strict";e.r(n);var a=e(70),s=Object(a.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"cpu-cache-与缓存行"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cpu-cache-与缓存行"}},[t._v("#")]),t._v(" CPU Cache 与缓存行")]),t._v(" "),e("p",[t._v("详见："),e("a",{attrs:{href:"https://www.cnkirito.moe/cache-line/",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.cnkirito.moe/cache-line/"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("CPU 缓存行中如果有多个对象，其中一个对象（或者对象部分数据）被修改了，那么对于 CPU 来说，该缓存行就是失效的，需要重新从主存中获取，这样一来，就会影响其他并不需要修改的对象。如果一个缓存行中经常有部分对象需要修改，那么就令 CPU CACHE 失去了意义。")]),t._v(" "),e("p",[t._v("通过字节填充（注意对象头填充 8 字节），使得某个对象直接占用了一个缓存行，这样一来，即使修改了其他对象，也不会使得缓存失效，从而保证能被 CPU CACHE 命中。")]),t._v(" "),e("p",[t._v("在 某些 JDK 版本（>= 1.7）,JVM 可能会将填充的字节当做无效代码优化掉，有两种方法可以避免优化：")]),t._v(" "),e("ul",[e("li",[t._v("将填充字段定义在一个抽象父类，并继承。")]),t._v(" "),e("li",[t._v("使用 Java 8 的官方注解 "),e("code",[t._v("@Contended")]),t._v(" 自动填充对齐，同时 JVM 需要开启 "),e("code",[t._v("-XX:-RestrictContended=false")])])]),t._v(" "),e("div",{staticClass:"language-vim line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-vim"}},[e("code",[t._v("@"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("Retention")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("RetentionPolicy"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),t._v("RUNTIME"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n@"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("Target")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("ElementType"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),t._v("FIELD"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" ElementType"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),t._v("TYPE"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\npublic @interface Contended "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    String "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("value")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" default "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('""')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br")])]),e("blockquote",[e("p",[t._v("NOTE：@Contended 注解会增加目标实例大小，要谨慎使用。默认情况下，除了 JDK 内部的类，JVM 会忽略该注解。要应用代码支持的话，要设置 -XX:-RestrictContended=false，它默认为 true（意味仅限 JDK 内部的类使用）。当然，也有个 –XX: EnableContented 的配置参数，来控制开启和关闭该注解的功能，默认是 true，如果改为 false，可以减少 Thread 和 ConcurrentHashMap 类的大小。参加《Java 性能权威指南》210 页。")]),t._v(" "),e("p",[t._v("— @Im 的补充")])]),t._v(" "),e("p",[t._v("一些官方代码以及优秀开源软件的最佳实践：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("ConcurrentHashMap#CountCell")])]),t._v(" "),e("li",[e("strong",[t._v("Thread#threadLocalRandomSeed")])]),t._v(" "),e("li",[e("strong",[t._v("RingBuffer")])])])])}),[],!1,null,null,null);n.default=s.exports}}]);