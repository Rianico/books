(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{966:function(e,t,a){"use strict";a.r(t);var r=a(70),s=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"_1-并发容器及其注意事项"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-并发容器及其注意事项"}},[e._v("#")]),e._v(" 1. 并发容器及其注意事项")]),e._v(" "),a("p",[e._v("Java 提供了很多并发安全的容器，但在部分场景下使用不当，仍会导致线程不安全，如组合操作隐含竞态条件、容器迭代等。")]),e._v(" "),a("p",[e._v("Java 提供的并发容器主要包含四大类：List、Map、Set 和 Queue：")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/a2/1d/a20efe788caf4f07a4ad027639c80b1d.png",alt:""}})]),e._v(" "),a("h2",{attrs:{id:"_2-list"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-list"}},[e._v("#")]),e._v(" 2. List")]),e._v(" "),a("p",[e._v("List 只提供了一个 CopyOnWriteArrayList 的并发容器，对 CopyOnWriteArrayList 进行读操作的时候，实际上读取的只是它的一个视图；对 CopyOnWriteArrayList 进行写操作时，则会复制一份数据，对其进行写操作后，再将引用指向新的数组。")]),e._v(" "),a("p",[e._v("CopyOnWriteArrayList 适合读多写少的情况，能够容忍短暂的数据不一致问题，并且其迭代器是不能进行增删改操作的。")]),e._v(" "),a("h2",{attrs:{id:"_3-map"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-map"}},[e._v("#")]),e._v(" 3. Map")]),e._v(" "),a("p",[e._v("Map 接口的两个实现是 ConcurrentHashMap 和 ConcurrentSkipListMap，前者的 key 是无序的，后者为有序的，且两者 key、value 都不能为 null。")]),e._v(" "),a("p",[e._v("各 Map 实现的容器对 key、value 要求如下：")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://static001.geekbang.org/resource/image/6d/be/6da9933b6312acf3445f736262425abe.png",alt:""}})]),e._v(" "),a("blockquote",[a("p",[e._v("NOTE：在 HashMap 冲突严重的情况下，可以考虑使用 SkipListMap（跳表），插入、删除、查询操作的平均时间复杂度为 O(logn)。")])]),e._v(" "),a("h2",{attrs:{id:"_3-set"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-set"}},[e._v("#")]),e._v(" 3. Set")]),e._v(" "),a("p",[e._v("Set 接口的两个实现是 CopyOnWriteArraySet 和 ConcurrentSkipListSet，使用场景可以参考前面讲述的 CopyOnWriteArrayList 和 ConcurrentSkipListMap。")]),e._v(" "),a("h2",{attrs:{id:"_4-queue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-queue"}},[e._v("#")]),e._v(" 4. Queue")]),e._v(" "),a("p",[e._v("Queue 的实现较多，可以从两个维度来区分：")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("阻塞和非阻塞")]),e._v("：当队列已满时，入队操作阻塞；当队列已空时，出队操作阻塞。")]),e._v(" "),a("li",[a("strong",[e._v("单端与双端")]),e._v("：单端指的是只能队尾入队，队首出队；而双端指的是队首队尾皆可入队出队。")])]),e._v(" "),a("p",[e._v("Java 并发包中"),a("strong",[e._v("阻塞队列都用 Blocking 关键字标识，单端队列使用 Queue 标识，双端队列使用 Deque 标识")]),e._v("。")]),e._v(" "),a("p",[e._v("因此可以分为四大类：")]),e._v(" "),a("ol",[a("li",[a("p",[a("strong",[e._v("单端阻塞队列")]),e._v("：其实现有 ArrayBlockingQueue（"),a("strong",[e._v("有界")]),e._v("、数组）、LinkedBlockingQueue（"),a("strong",[e._v("有界")]),e._v("、链表）、SynchronousQueue（无队列）、LinkedTransferQueue（性能更好）、PriorityBlockingQueue（优先级） 和 DelayQueue（延时出队）。")])]),e._v(" "),a("li",[a("p",[e._v("双端阻塞队列：LinkedBlockingDeque。")])]),e._v(" "),a("li",[a("p",[e._v("单端非阻塞队列：ConcurrentLinkedQueue。")])]),e._v(" "),a("li",[a("p",[e._v("双端非阻塞队列：ConcurrentLinkedDeque。")])])]),e._v(" "),a("p",[e._v("实际使用中，通常都是使用有界队列，避免队列长度无限制导致的 OOM。")]),e._v(" "),a("h3",{attrs:{id:"_4-1-blockingqueue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-blockingqueue"}},[e._v("#")]),e._v(" 4.1 BlockingQueue")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/zhxuankun/Image/raw/master/Avator/image-20210606173332065.png",alt:"image-20210606173332065"}})]),e._v(" "),a("h2",{attrs:{id:"_5-延伸"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-延伸"}},[e._v("#")]),e._v(" 5. 延伸")]),e._v(" "),a("p",[e._v("JDK8 之前，多线程写 HashMap 在扩容时（尾插入）可能会形成循环数组，导致 CPU 100% 的问题。JDK 8 之后，HashMap 扩容时则是将某个节点上的链表/红黑树分为两条队列，一条插入到新数组的原始下标位置，一条插入到新数组"),a("strong",[e._v("原始下标 + 原始数组长度")]),e._v("的位置。")])])}),[],!1,null,null,null);t.default=s.exports}}]);