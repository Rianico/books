(window.webpackJsonp=window.webpackJsonp||[]).push([[129],{851:function(t,e,r){"use strict";r.r(e);var _=r(70),a=Object(_.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"_1-三种冒险"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-三种冒险"}},[t._v("#")]),t._v(" 1. 三种冒险")]),t._v(" "),r("h3",{attrs:{id:"_1-1-结构冒险"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-结构冒险"}},[t._v("#")]),t._v(" 1.1 结构冒险")]),t._v(" "),r("p",[t._v("如果内存只有一个地址译码器作为地址输入，那就只能在一个时钟周期里面读取一条数据。这样一来，同一时钟周期只能有一条指令对内存进行读取（造成硬件资源的竞争），访问内存数据以及读取内存指令就会造成冲突。")]),t._v(" "),r("p",[t._v("现代处理器借鉴了 “哈佛架构” 的思想，将 CPU 的高速缓存划分为"),r("strong",[t._v("存放指令的缓存")]),t._v("和"),r("strong",[t._v("存放数据的缓存")]),t._v("。")]),t._v(" "),r("p",[t._v("现代的 CPU 并不会直接从内存中读取数据以及指令，而是将其加载到高速缓存中在再进行访问，避免了硬件资源的竞争。")]),t._v(" "),r("h3",{attrs:{id:"_1-2-数据冒险"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-数据冒险"}},[t._v("#")]),t._v(" 1.2 数据冒险")]),t._v(" "),r("p",[t._v("数据依赖可以分为先写后读（Read After Write）、先读后写（Write After Read）、写后再写（Write After Write）。")]),t._v(" "),r("p",[t._v("如果后面一条指令依依赖于前一条指令的结果，由于流水线，可能导致后一条指令的流水级先行发生于前一条指令发生，导致结果错误。")]),t._v(" "),r("p",[t._v("目前解决数据冒险的方式为"),r("strong",[t._v("流水线停顿（Pipeline Stall）")]),t._v("，或者叫"),r("strong",[t._v("流水线冒泡（Pipeline Bubbling）")]),t._v("。如果检测到指令之间有数据冒险，则根据依赖关系，在后面指令的流水线前面添加 NOP 来填充时钟周期，推迟指令流水线的运行。")]),t._v(" "),r("p",[t._v("最坏情况下，会让 CPU 退化为单指令周期 CPU。")])])}),[],!1,null,null,null);e.default=a.exports}}]);